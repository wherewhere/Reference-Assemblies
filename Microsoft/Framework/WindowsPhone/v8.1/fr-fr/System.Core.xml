<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Core</name>
  </assembly>
  <members>
    <member name="T:System.Action`10">
      <summary>Encapsule une méthode ayant 10 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`11">
      <summary>Encapsule une méthode ayant 11 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`12">
      <summary>Encapsule une méthode ayant 12 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`13">
      <summary>Encapsule une méthode ayant 13 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`14">
      <summary>Encapsule une méthode ayant 14 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`15">
      <summary>Encapsule une méthode ayant 15 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg15">Quinzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T15">Type du quinzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`16">
      <summary>Encapsule une méthode ayant 16 paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg15">Quinzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg16">Seizième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T15">Type du quinzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T16">Type du seizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Action`9">
      <summary>Encapsule une méthode ayant neuf paramètres et ne retournant aucune valeur.</summary>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
    </member>
    <member name="T:System.Func`10">
      <summary>Encapsule une méthode ayant neuf paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`11">
      <summary>Encapsule une méthode ayant 10 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`12">
      <summary>Encapsule une méthode ayant 11 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`13">
      <summary>Encapsule une méthode ayant 12 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`14">
      <summary>Encapsule une méthode ayant 13 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`15">
      <summary>Encapsule une méthode ayant 14 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`16">
      <summary>Encapsule une méthode ayant 15 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg15">Quinzième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T15">Type du quinzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`17">
      <summary>Encapsule une méthode ayant 16 paramètres et retournant une valeur du type spécifié par le paramètre <paramref name="TResult" />.</summary>
      <returns>Valeur renvoyée de la méthode encapsulée par ce délégué.</returns>
      <param name="arg1">Premier paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg2">Deuxième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg3">Troisième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg4">Quatrième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg5">Cinquième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg6">Sixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg7">Septième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg8">Huitième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg9">Neuvième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg10">Dixième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg11">Onzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg12">Douzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg13">Treizième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg14">Quatorzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg15">Quinzième paramètre de la méthode encapsulée par ce délégué.</param>
      <param name="arg16">Seizième paramètre de la méthode encapsulée par ce délégué.</param>
      <typeparam name="T1">Type du premier paramètre de la méthode encapsulée par ce délégué.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Type du deuxième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T3">Type du troisième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T4">Type du quatrième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T5">Type du cinquième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T6">Type du sixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T7">Type du septième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T8">Type du huitième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T9">Type du neuvième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T10">Type du dixième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T11">Type du onzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T12">Type du douzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T13">Type du treizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T14">Type du quatorzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T15">Type du quinzième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="T16">Type du seizième paramètre de la méthode encapsulée par ce délégué.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée de la méthode encapsulée par ce délégué.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Collections.Generic.HashSet`1">
      <summary>Représente un ensemble de valeurs.</summary>
      <typeparam name="T">Type d'éléments de l'ensemble de hachages.</typeparam>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> vide et utilise le comparateur d'égalité par défaut pour le type d'ensemble.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui utilise le comparateur d'égalité par défaut pour le type d'ensemble, contient des éléments copiés à partir de la collection spécifiée et possède une capacité suffisante pour accueillir le nombre d'éléments copiés.</summary>
      <param name="collection">Collection dont les éléments sont copiés dans le nouvel ensemble.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> qui utilise le comparateur d'égalité spécifié pour le type d'ensemble, contient des éléments copiés à partir de la collection spécifiée et possède une capacité suffisante pour accueillir le nombre d'éléments copiés.</summary>
      <param name="collection">Collection dont les éléments sont copiés dans le nouvel ensemble.</param>
      <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des valeurs de l'ensemble, ou null pour utiliser l'implémentation <see cref="T:System.Collections.Generic.EqualityComparer`1" /> par défaut pour le type d'ensemble.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Generic.HashSet`1" /> vide et utilise le comparateur d'égalité spécifié pour le type d'ensemble.</summary>
      <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser lors de la comparaison des valeurs de l'ensemble, ou null pour utiliser l'implémentation <see cref="T:System.Collections.Generic.EqualityComparer`1" /> par défaut pour le type d'ensemble.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
      <summary>Ajoute l'élément spécifié à un ensemble.</summary>
      <returns>La valeur est true si l'élément est ajouté à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> ou false si l'élément est déjà présent.</returns>
      <param name="item">Élément à ajouter à l'ensemble.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Clear">
      <summary>Supprime tous les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Comparer">
      <summary>Obtient l'objet <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> qui est utilisé pour déterminer l'égalité des valeurs de l'ensemble.</summary>
      <returns>Objet <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> qui est utilisé pour déterminer l'égalité des valeurs de l'ensemble.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> contient l'élément spécifié.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> contient l'élément spécifié, sinon false.</returns>
      <param name="item">Élément à localiser dans l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
      <summary>Copie les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau.</summary>
      <param name="array">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
      <summary>Copie les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau, en commençant au niveau de l'index de tableau spécifié.</summary>
      <param name="array">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
      <param name="arrayIndex">Index de base zéro dans le <paramref name="array" /> au niveau duquel commence la copie.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> est null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> est inférieur à 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayIndex" /> est supérieur à la longueur du <paramref name="array" /> de destination.– ou –<paramref name="count" /> est supérieur à la taille du <paramref name="array" /> de destination.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
      <summary>Copie le nombre spécifié d'éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> dans un tableau, en commençant à l'index spécifié du tableau.</summary>
      <param name="array">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
      <param name="arrayIndex">Index de base zéro dans le <paramref name="array" /> au niveau duquel commence la copie.</param>
      <param name="count">Nombre d'éléments à copier dans <paramref name="array" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> est null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> est inférieur à 0.– ou –<paramref name="count" /> est inférieur à 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayIndex" /> est supérieur à la longueur du <paramref name="array" /> de destination.– ou –Le nombre d'éléments dans le <paramref name="count" /> est supérieur à la quantité d'espace disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Count">
      <summary>Obtient le nombre d'éléments contenus dans un ensemble.</summary>
      <returns>Nombre d'éléments contenus dans l'ensemble.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Supprime tous les éléments dans la collection spécifiée de l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</summary>
      <param name="other">Collection d'éléments à supprimer de l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.GetEnumerator">
      <summary>Retourne un énumérateur qui itère au sein d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>Objet <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> pour l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne uniquement les éléments qui sont présents dans cet objet et dans la collection spécifiée.</summary>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble propre à la collection spécifiée.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble propre à <paramref name="other" />, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble propre à la collection spécifiée.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble propre à <paramref name="other" />, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble de la collection spécifiée.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sous-ensemble de <paramref name="other" />, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble de la collection spécifiée.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est un sur-ensemble de <paramref name="other" />, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actuel et une collection spécifiée partagent des éléments communs.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> et <paramref name="other" /> partagent au moins un élément commun, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
      <summary>Supprime l'élément spécifié d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>La valeur est true si l'élément a été trouvé et supprimé, sinon false.  Cette méthode renvoie la valeur false si <paramref name="item" /> est introuvable dans l'objet <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
      <param name="item">Élément à supprimer.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
      <summary>Supprime tous les éléments qui correspondent aux conditions définies par le prédicat spécifié de la collection <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>Nombre d'éléments supprimés de la collection <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
      <param name="match">Délégué <see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à supprimer.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="match" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
      <summary>Détermine si un objet <see cref="T:System.Collections.Generic.HashSet`1" /> et la collection spécifiée contiennent les mêmes éléments.</summary>
      <returns>La valeur est true si l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> est égal à <paramref name="other" />, sinon false.</returns>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne uniquement les éléments présents dans cet objet ou dans la collection spécifiée, mais pas dans les deux à la fois.</summary>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
      <summary>Ajoute un élément à un objet <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
      <param name="item">Objet à ajouter à l'objet <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">La <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtient une valeur indiquant si une collection est en lecture seule.</summary>
      <returns>true si la collection est en lecture seule, sinon false.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Renvoie un énumérateur qui itère au sein d'une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.Generic.IEnumerator`1" /> pouvant être utilisé pour parcourir la collection.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Renvoie un énumérateur qui itère au sein d'une collection.</summary>
      <returns>Objet <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour parcourir la collection.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.TrimExcess">
      <summary>Définit la capacité d'un objet <see cref="T:System.Collections.Generic.HashSet`1" /> sur le nombre réel d'éléments qu'il contient, arrondi à une valeur proche spécifique à l'implémentation.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifie l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif afin qu'il contienne tous les éléments qui sont présents à la fois dans cet objet et dans la collection spécifiée.</summary>
      <param name="other">Collection à comparer à l'objet <see cref="T:System.Collections.Generic.HashSet`1" /> actif.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="other" /> est null.</exception>
    </member>
    <member name="T:System.Collections.Generic.HashSet`1.Enumerator">
      <summary>Énumère les éléments d'un objet <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Enumerator.Current">
      <summary>Obtient l'élément dans la position actuelle de l'énumérateur.</summary>
      <returns>Élément dans la <see cref="T:System.Collections.Generic.HashSet`1" /> collection à la position actuelle de l'énumérateur.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.Dispose">
      <summary>Libère toutes les ressources utilisées par un objet <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.MoveNext">
      <summary>Avance l'énumérateur à l'élément suivant de la collection <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>La valeur est true si l'énumérateur a pu avancer jusqu'à l'élément suivant ou false si l'énumérateur a dépassé la fin de la collection.</returns>
      <exception cref="T:System.InvalidOperationException">La collection a été modifiée après la création de l'énumérateur. </exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtient l'élément dans la position actuelle de l'énumérateur.</summary>
      <returns>Élément dans la collection à la position actuelle de l'énumérateur en tant que <see cref="T:System.Object" />.</returns>
      <exception cref="T:System.InvalidOperationException">L’énumérateur précède le premier élément ou suit le dernier élément de la collection. </exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Affecte à l'énumérateur sa position initiale, qui précède le premier élément de la collection.</summary>
      <exception cref="T:System.InvalidOperationException">La collection a été modifiée après la création de l'énumérateur. </exception>
    </member>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Représente l'opération dynamique binaire au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Type d'opération binaire.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération binaire dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération binaire dynamique.</param>
      <param name="arg">Opérande droit de l'opération binaire dynamique.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique binaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération binaire dynamique.</param>
      <param name="arg">Opérande droit de l'opération binaire dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>Type d'opération binaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant le type d'opération binaire.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Représente un jeu de restrictions de liaison sur le <see cref="T:System.Dynamic.DynamicMetaObject" /> sous lequel la liaison dynamique est valide.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combine les restrictions de liaison de la liste d'instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un jeu de restrictions.</summary>
      <returns>Nouveau jeu de restrictions de liaison.</returns>
      <param name="contributingObjects">Liste des instances de <see cref="T:System.Dynamic.DynamicMetaObject" /> à partir desquelles combiner les restrictions.</param>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Représente un jeu de restrictions de liaison vide.Ce champ est en lecture seule.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Crée la restriction de liaison vérifiant si l'expression contient des propriétés immuables arbitraires.</summary>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
      <param name="expression">Expression représentant les restrictions.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Crée la restriction de liaison vérifiant l'identité de l'instance de l'objet dans l'expression.</summary>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
      <param name="expression">Expression à tester.</param>
      <param name="instance">Instance exacte de l'objet à tester.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée la restriction de liaison vérifiant l'identité du type au moment de l'exécution dans l'expression.</summary>
      <returns>Restrictions applicables à la nouvelle liaison.</returns>
      <param name="expression">Expression à tester.</param>
      <param name="type">Type exact à tester.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Fusionne le jeu de restrictions de liaison avec les restrictions de liaison actuelles.</summary>
      <returns>Nouveau jeu de restrictions de liaison.</returns>
      <param name="restrictions">Jeu de restrictions à fusionner avec les restrictions de liaison actuelles.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Crée le <see cref="T:System.Linq.Expressions.Expression" /> représentant les restrictions de liaison.</summary>
      <returns>Arborescence de l'expression représentant les restrictions.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Décrit des arguments dans le processus de liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Crée un nouveau CallInfo représentant des arguments dans le processus de liaison dynamique.</summary>
      <param name="argCount">Nombre d'arguments.</param>
      <param name="argNames">Noms d'arguments.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Crée une nouvelle PositionalArgumentInfo.</summary>
      <param name="argCount">Nombre d'arguments.</param>
      <param name="argNames">Noms d'arguments.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>Nombre d'arguments.</summary>
      <returns>Nombre d'arguments.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Noms d'arguments.</summary>
      <returns>Collection en lecture seule de noms d'arguments.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Détermine si l'instance de CallInfo spécifiée est considérée comme étant égale à l'instance en cours.</summary>
      <returns>La valeur est true si l'instance spécifiée est égale à l'instance actuelle, sinon, false.</returns>
      <param name="obj">Instance de <see cref="T:System.Dynamic.CallInfo" /> à comparer à l'instance actuelle.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Sert de fonction de hachage pour le <see cref="T:System.Dynamic.CallInfo" /> en cours.</summary>
      <returns>Code de hachage pour le <see cref="T:System.Dynamic.CallInfo" /> en cours.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Représente l'opération de conversion dynamique sur le site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.ConvertBinder" />..</summary>
      <param name="type">Type dans lequel convertir.</param>
      <param name="explicit">A la valeur true si la conversion doit prendre en compte les conversions de type explicite ; sinon, false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de conversion dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de conversion dynamique.</param>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Obtient la valeur indiquant si la conversion doit prendre en compte les conversions de type explicite.</summary>
      <returns>La valeur est True en cas de conversion de type explicite, sinon false.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de conversion dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de conversion dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>Type dans lequel convertir.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type vers lequel effectuer la conversion.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Représente l'opération de création dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de création dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de création dynamique.</param>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Arguments de l'opération de création dynamique.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de création dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de création dynamique.</param>
      <param name="args">Arguments de l'opération de création dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Représente l'opération de suppression d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.DeleteIndexBinder" />..</summary>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de suppression d'index dynamique.</param>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de suppression d'index dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de suppression d'index dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Représente l'opération de suppression de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.DeleteIndexBinder" />..</summary>
      <param name="name">Nom du membre à supprimer.</param>
      <param name="ignoreCase">La valeur est true si la correspondance avec le nom doit ignorer la casse, sinon false.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de suppression de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de suppression de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de suppression de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>La valeur est true si la comparaison de chaînes doit ignorer la casse, sinon false.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Obtient le nom du membre à supprimer.</summary>
      <returns>Nom du membre à supprimer.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Représente la liaison dynamique et une logique de liaison d'un objet qui participe à la liaison dynamique.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expression représentant cet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expression représentant cet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
      <param name="restrictions">Ensemble de restrictions de liaisons sous lequel la liaison est valide.</param>
      <param name="value">Valeur d'exécution représentée par l'<see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération binaire dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.BinaryOperationBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="arg">Instance d'<see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le côté droit de l'opération binaire.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Exécute la liaison de l'opération de conversion dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.ConvertBinder" /> représentant les détails de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de création d'instance dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.CreateInstanceBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances d'<see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération de création d'instance.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de suppression d'index dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.DeleteIndexBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances d'<see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de suppression d'index.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Exécute la liaison de l'opération de suppression de membre dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.DeleteMemberBinder" /> représentant les détails de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.GetIndexBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances <see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération d'obtention d'index.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.GetMemberBinder" /> représentant les détails de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.InvokeBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances d'<see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.InvokeMemberBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="args">Tableau d'instances d'<see cref="T:System.Dynamic.DynamicMetaObject" />, arguments de l'opération d'appel de membre.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.SetIndexBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="indexes">Tableau d'instances d'<see cref="T:System.Dynamic.DynamicMetaObject" />, index pour l'opération de définition d'index.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition d'index.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.SetMemberBinder" /> représentant les détails de l'opération dynamique.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant la valeur pour l'opération de définition d'index.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Exécute la liaison de l'opération unaire dynamique.</summary>
      <returns>Nouvel <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="binder">Instance de <see cref="T:System.Dynamic.UnaryOperationBinder" /> représentant les détails de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Crée un objet méta pour l'objet spécifié.</summary>
      <returns>Si l'objet spécifié implémente <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> et n'est pas un objet distant extérieur au AppDomain actuel, renvoie l'objet méta spécifique à l'objet renvoyé par <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />.Sinon, un nouvel objet méta brut sans restrictions est créé et renvoyé.</returns>
      <param name="value">Objet pour lequel obtenir un objet méta.</param>
      <param name="expression">Expression représentant cet <see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</param>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Représente un tableau vide du type <see cref="T:System.Dynamic.DynamicMetaObject" />.Ce champ est en lecture seule.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>Expression représentant l'<see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</summary>
      <returns>Expression représentant l'<see cref="T:System.Dynamic.DynamicMetaObject" /> durant le processus de liaison dynamique.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Renvoie l'énumération de tous les noms de membres dynamiques.</summary>
      <returns>Liste des noms de membres dynamiques.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Obtient une valeur indiquant si l'<see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d'exécution.</summary>
      <returns>La valeur est true si l'<see cref="T:System.Dynamic.DynamicMetaObject" /> a la valeur d'exécution, sinon false.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Obtient le type de limite de l'<see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si la valeur d'exécution est disponible, sinon type de <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>Ensemble de restrictions de liaisons sous lequel la liaison est valide.</summary>
      <returns>Ensemble de restrictions de liaison.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Obtient le <see cref="T:System.Type" /> de la valeur d'exécution ou null si l'<see cref="T:System.Dynamic.DynamicMetaObject" /> n'est associé à aucune valeur.</summary>
      <returns>
        <see cref="T:System.Type" /> de la valeur d'exécution ou null.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>Valeur d'exécution représentée par cet <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>Valeur d'exécution représentée par cet <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Binder de site d'appel dynamique participant au protocole de liaison <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Exécute la liaison au moment de l'exécution de l'opération dynamique sur un ensemble d'arguments.</summary>
      <returns>Expression qui exécute des tests sur les arguments d'opération dynamique, et qui exécute l'opération dynamique si les tests sont valides.Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire une nouvelle <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel">LabelTarget utilisé pour renvoyer le résultat de la liaison dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Diffère la liaison de l'opération jusqu'à ce que les valeurs d'exécution de tous les arguments d'opération dynamique soient calculées.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Obtient une expression entraînant la mise à jour de la liaison.Indique que la liaison de l'expression n'est plus valide.Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <returns>Expression de mise à jour.</returns>
      <param name="type">Propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'expression résultante ; tous les types sont autorisés.</param>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Fournit une classe de base pour la spécification du comportement dynamique pendant l'exécution.Cette classe doit être héritée ; vous ne pouvez pas l'instancier directement.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Permet aux types dérivés d'initialiser une nouvelle instance du type <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Renvoie l'énumération de tous les noms de membres dynamiques. </summary>
      <returns>Séquence contenant des noms de membre dynamiques.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Fournit un <see cref="T:System.Dynamic.DynamicMetaObject" /> qui distribue aux méthodes virtuelles dynamiques.L'objet peut être encapsulé dans un autre <see cref="T:System.Dynamic.DynamicMetaObject" /> pour définir un comportement personnalisé pour des actions individuelles.Cette méthode prend en charge l'infrastructure Dynamic Language Runtime pour les implémenteurs de langage et n'est pas conçue pour être utilisée directement dans votre code.</summary>
      <returns>Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
      <param name="parameter">Expression représentant le <see cref="T:System.Dynamic.DynamicMetaObject" /> à distribuer aux méthodes virtuelles dynamiques.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Fournit une implémentation pour les opérations binaires.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'addition et la multiplication.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération binaire.La propriété binder.Operation renvoie un objet <see cref="T:System.Linq.Expressions.ExpressionType" />.Par exemple, pour l'instruction sum = first + second où first et second sont dérivés de la classe DynamicObject, binder.Operation renvoie ExpressionType.Add.</param>
      <param name="arg">Opérande droit pour l'opération binaire.Par exemple, pour l'instruction sum = first + second où first et second sont dérivés de la classe DynamicObject, <paramref name="arg" /> est égal à second.</param>
      <param name="result">Résultat de l'opération binaire.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations de conversion de type.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations convertissant un objet d'un type en un autre.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération de conversion.La propriété binder.Type fournit le type en lequel l'objet doit être converti.Par exemple, pour l'instruction (String)sampleObject en C# (CType(sampleObject, Type) en Visual Basic) où sampleObject est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, binder.Type renvoie le type <see cref="T:System.String" />.La propriété binder.Explicit fournit des informations sur le genre de conversion qui se produit.Elle renvoie la valeur true pour la conversion explicite et la valeur false pour la conversion implicite.</param>
      <param name="result">Résultat de l'opération de conversion de type.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations initialisant une nouvelle instance d'un objet dynamique.Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération d'initialisation.</param>
      <param name="args">Arguments passés à l'objet pendant l'initialisation.Par exemple, pour l'opération new SampleType(100) où SampleType est le type dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> est égal à 100.</param>
      <param name="result">Résultat de l'initialisation.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Fournit l'implémentation pour les opérations supprimant un objet par index.Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur la suppression.</param>
      <param name="indexes">Index à supprimer.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Fournit l'implémentation pour les opérations supprimant un membre objet.Cette méthode n'est pas destinée à être utilisée en C# ou en Visual Basic.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur la suppression.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations obtenant une valeur par index.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour les opérations d'indexation.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération. </param>
      <param name="indexes">Index utilisés pendant l'opération.Par exemple, pour l'opération sampleObject[3] en C# (sampleObject(3) en Visual Basic) où sampleObject est dérivé de la classe DynamicObject, <paramref name="indexes[0]" /> est égal à 3.</param>
      <param name="result">Résultat de l'opération d'indexation.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations obtenant des valeurs de membre.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'obtention d'une valeur pour une propriété.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime est levée.)</returns>
      <param name="binder">Fournit des informations sur l'objet qui a appelé l'opération dynamique.La propriété binder.Name fournit le nom du membre sur lequel l'opération dynamique est exécutée.Par exemple, pour l'instruction Console.WriteLine(sampleObject.SampleProperty), où sampleObject est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, binder.Name renvoie « SampleProperty ».La propriété binder.IgnoreCase spécifie si le nom du membre respecte la casse.</param>
      <param name="result">Résultat de l'opération d'extraction.Par exemple, si la méthode est appelée pour une propriété, vous pouvez assigner la valeur de la propriété à <paramref name="result" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations appelant un objet.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'un objet ou d'un délégué.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
      <param name="binder">Fournit des informations sur l'opération d'appel.</param>
      <param name="args">Arguments passés à l'objet pendant l'opération d'appel.Par exemple, pour l'opération sampleObject(100) où sampleObject est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> est égal à 100.</param>
      <param name="result">Résultat de l'appel de l'objet.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Fournit l'implémentation pour les opérations appelant un membre.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que l'appel d'une méthode.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération dynamique.La propriété binder.Name fournit le nom du membre sur lequel l'opération dynamique est exécutée.Par exemple, pour l'instruction sampleObject.SampleMethod(100), où sampleObject est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, binder.Name renvoie « SampleMethod ».La propriété binder.IgnoreCase spécifie si le nom du membre respecte la casse.</param>
      <param name="args">Arguments passés au membre d'objet pendant l'opération d'appel.Par exemple, pour l'instruction sampleObject.SampleMethod(100) où sampleObject est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> est égal à 100.</param>
      <param name="result">Résultat de l'appel du membre.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Fournit l'implémentation pour les opérations définissant une valeur par index.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode pour spécifier le comportement dynamique pour certaines opérations accédant aux objets par un index spécifié.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.</returns>
      <param name="binder">Fournit des informations sur l'opération. </param>
      <param name="indexes">Index utilisés pendant l'opération.Par exemple, pour l'opération sampleObject[3] = 10 en C# (sampleObject(3) = 10 en Visual Basic) où sampleObject est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="indexes[0]" /> est égal à 3.</param>
      <param name="value">Valeur à définir pour l'objet qui a l'index spécifié.Par exemple, pour l'opération sampleObject[3] = 10 en C# (sampleObject(3) = 10 en Visual Basic) où sampleObject est dérivé de la classe <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> est égal à 10.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Fournit l'implémentation pour les opérations définissant des valeurs de membre.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la définition d'une valeur pour une propriété.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'objet qui a appelé l'opération dynamique.La propriété binder.Name fournit le nom du membre auquel la valeur est assignée.Par exemple, pour l'instruction sampleObject.SampleProperty = "Test", où sampleObject est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, binder.Name renvoie « SampleProperty ».La propriété binder.IgnoreCase spécifie si le nom du membre respecte la casse.</param>
      <param name="value">Valeur à affecter au membre.Par exemple, pour sampleObject.SampleProperty = "Test", où sampleObject est une instance de la classe dérivée de la classe <see cref="T:System.Dynamic.DynamicObject" />, la <paramref name="value" /> est « Test ».</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Fournit l'implémentation pour les opérations unaires.Les classes dérivées de la classe <see cref="T:System.Dynamic.DynamicObject" /> peuvent substituer cette méthode afin de spécifier le comportement dynamique pour certaines opérations telles que la négation, l'incrémentation ou la décrémentation.</summary>
      <returns>La valeur est true si l'opération réussit, sinon false.Si cette méthode renvoie false, le binder d'exécution du langage détermine le comportement.(Dans la plupart des cas, une exception runtime spécifique au langage est levée.)</returns>
      <param name="binder">Fournit des informations sur l'opération unaire.La propriété binder.Operation renvoie un objet <see cref="T:System.Linq.Expressions.ExpressionType" />.Par exemple, pour l'instruction negativeNumber = -number où number est dérivé de la classe DynamicObject, binder.Operation renvoie « Negate ».</param>
      <param name="result">Résultat de l'opération unaire.</param>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Représente un objet dont les membres peuvent être ajoutés et supprimés de manière dynamique au moment de l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Initialise un nouveau ExpandoObject qui n'a pas de membres.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Ajoute la valeur spécifiée à la <see cref="T:System.Collections.Generic.ICollection`1" /> ayant la clé spécifiée.</summary>
      <param name="item">Structure <see cref="T:System.Collections.Generic.KeyValuePair`2" /> représentant la clé et la valeur à ajouter à la collection.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Clear">
      <summary>Supprime tous les éléments de la collection.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Détermine si la <see cref="T:System.Collections.Generic.ICollection`1" /> contient une clé et une valeur spécifiques.</summary>
      <returns>La valeur est true si la collection contient une clé et une valeur spécifiques, sinon false.</returns>
      <param name="item">Structure <see cref="T:System.Collections.Generic.KeyValuePair`2" /> à rechercher dans la <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>Copie les éléments de la <see cref="T:System.Collections.Generic.ICollection`1" /> dans un tableau de type <see cref="T:System.Collections.Generic.KeyValuePair`2" />, en commençant au niveau de l'index de tableau spécifié.</summary>
      <param name="array">Tableau unidimensionnel de type <see cref="T:System.Collections.Generic.KeyValuePair`2" /> constituant la destination des éléments <see cref="T:System.Collections.Generic.KeyValuePair`2" /> copiés à partir de la <see cref="T:System.Collections.Generic.ICollection`1" />.Ce tableau doit avoir une indexation de base zéro.</param>
      <param name="arrayIndex">Index de base zéro dans le <paramref name="array" /> où commence la copie.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Count">
      <summary>Obtient le nombre d'éléments dans la <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
      <returns>Nombre d'éléments dans la <see cref="T:System.Collections.Generic.ICollection`1" />..</returns>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtient une valeur indiquant si la <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule.</summary>
      <returns>La valeur est true si <see cref="T:System.Collections.Generic.ICollection`1" /> est en lecture seule, sinon false.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Supprime une clé et une valeur de la collection.</summary>
      <returns>La valeur est true si la recherche et la suppression de la clé et de la valeur réussissent, sinon false.Cette méthode renvoie false si la clé et la valeur sont introuvables dans <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
      <param name="item">Structure <see cref="T:System.Collections.Generic.KeyValuePair`2" /> qui représente la clé et la valeur à supprimer de la collection.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Add(System.String,System.Object)">
      <summary>Ajoute la clé et la valeur spécifiées au dictionnaire.</summary>
      <param name="key">Objet à utiliser comme clé.</param>
      <param name="value">Objet à utiliser comme valeur.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#ContainsKey(System.String)">
      <summary>Détermine si le dictionnaire contient la clé spécifiée.</summary>
      <returns>La valeur est true si le dictionnaire contient un élément qui possède la clé spécifiée, sinon false.</returns>
      <param name="key">Clé à rechercher dans le dictionnaire.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Item(System.String)">
      <summary>Obtient ou définit l'élément qui contient la clé spécifiée.</summary>
      <returns>Élément qui contient la clé spécifiée.</returns>
      <param name="key">Clé de l'élément à obtenir ou définir.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Keys">
      <summary>Obtient un <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les clés du <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les clés de l'objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(System.String)">
      <summary>Supprime l'élément ayant la clé spécifiée du <see cref="T:System.Collections.IDictionary" />..</summary>
      <returns>La valeur est true si la suppression de l'entité a réussi, sinon false.Cette méthode renvoie également false si <paramref name="key" /> est introuvable dans le <see cref="T:System.Collections.Generic.IDictionary`2" /> d'origine.</returns>
      <param name="key">Clé de l'élément à supprimer.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#TryGetValue(System.String,System.Object@)">
      <summary>Obtient la valeur associée à la clé spécifiée.</summary>
      <returns>La valeur est true si l'objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" /> contient un élément comportant la clé spécifiée, sinon false.</returns>
      <param name="key">Clé de la valeur à obtenir.</param>
      <param name="value">Cette méthode renvoie la valeur associée à la clé spécifiée, si la clé est trouvée ; sinon, renvoie la valeur par défaut pour le type du paramètre <paramref name="value" />.Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Values">
      <summary>Obtient un objet <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les valeurs du <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" /> contenant les valeurs de l'objet qui implémente <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Renvoie un énumérateur itérant au sein de la collection.</summary>
      <returns>Objet <see cref="T:System.Collections.Generic.IEnumerator`1" /> qui peut être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Renvoie un énumérateur itérant au sein de la collection.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> pouvant être utilisé pour itérer au sein de la collection.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Se produit lorsqu'une valeur de propriété est modifiée.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Le MetaObject fourni est distribué aux méthodes virtuelles dynamiques.L'objet peut être encapsulé dans un autre MetaObject pour définir un comportement personnalisé pour des actions individuelles.</summary>
      <returns>Objet de type <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
      <param name="parameter">Expression qui représente le MetaObject à distribuer aux méthodes virtuelles dynamiques.</param>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Représente l'opération d'obtention d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.GetIndexBinder" />..</summary>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention d'index dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'obtention d'index dynamique.</param>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération d'obtention d'index dynamique.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération d'obtention d'index dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Représente l'opération d'obtention de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.GetMemberBinder" />..</summary>
      <param name="name">Nom du membre à obtenir.</param>
      <param name="ignoreCase">La valeur est true si la correspondance avec le nom doit ignorer la casse, sinon false.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'obtention de membre dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'obtention de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'obtention de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'obtention de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>La valeur est true si la casse est ignorée, sinon false.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Obtient le nom du membre à obtenir.</summary>
      <returns>Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Représente un objet dynamique, dont les opérations peuvent être liées pendant l'exécution.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Renvoie le <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de la liaison des opérations effectuées sur cet objet.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> à lier à cet objet.</returns>
      <param name="parameter">Représentation de l'arborescence de l'expression de la valeur d'exécution.</param>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Représente les informations relatives à une opération d'obtention de membre dynamique indiquant si l'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Obtient la valeur indiquant si cette opération d'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction.La valeur par défaut lorsque cette interface n'est pas présente est true.</summary>
      <returns>La valeur est true si cette opération d'obtention de membre doit appeler des propriétés lorsqu'elles exécutent l'opération d'extraction, sinon false.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Représente l'opération d'appel dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.InvokeBinder" />..</summary>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'appel dynamique.</param>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Représente l'opération d'appel de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.InvokeMemberBinder" />..</summary>
      <param name="name">Nom du membre à appeler.</param>
      <param name="ignoreCase">La valeur est true si la correspondance avec le nom doit ignorer la casse, sinon false.</param>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération d'appel de membre dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération d'appel de membre dynamique.</param>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel dynamique.</param>
      <param name="args">Arguments de l'opération d'appel dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Effectue la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Arguments de l'opération d'appel de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération d'appel de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération d'appel de membre dynamique.</param>
      <param name="args">Arguments de l'opération d'appel de membre dynamique.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>La valeur est true si la casse est ignorée, sinon false.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Obtient le nom du membre à appeler.</summary>
      <returns>Nom du membre à appeler.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Représente l'opération de définition d'index dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.SetIndexBinder" />..</summary>
      <param name="callInfo">Signature des arguments au site d'appel.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de définition d'index dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de définition d'index dynamique.</param>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Obtient la signature des arguments au site d'appel.</summary>
      <returns>Signature des arguments au site d'appel.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value">Valeur à affecter à la collection.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>En cas de substitution dans la classe dérivée, exécute la liaison de l'opération de définition d'index dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition d'index dynamique.</param>
      <param name="indexes">Arguments de l'opération de définition d'index dynamique.</param>
      <param name="value">Valeur à affecter à la collection.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Représente l'opération de définition de membre dynamique au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Dynamic.SetMemberBinder" />..</summary>
      <param name="name">Nom du membre à obtenir.</param>
      <param name="ignoreCase">La valeur est true si la correspondance avec le nom doit ignorer la casse, sinon false.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération de définition de membre dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération de définition de membre dynamique.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value">Valeur à affecter au membre.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération de définition de membre dynamique si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération de définition de membre dynamique.</param>
      <param name="value">Valeur à affecter au membre.</param>
      <param name="errorSuggestion">Résultat de liaison à utiliser si la liaison échoue, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Obtient la valeur indiquant si la comparaison de chaîne doit ignorer la casse du nom du membre.</summary>
      <returns>La valeur est true si la casse est ignorée, sinon false.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Obtient le nom du membre à obtenir.</summary>
      <returns>Nom du membre à obtenir.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Représente l'opération dynamique unaire au site d'appel, en fournissant la sémantique de liaison et les détails de l'opération.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Type d'opération unaire.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Exécute la liaison de l'opération unaire dynamique.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération dynamique.</param>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération unaire dynamique.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Effectue la liaison de l'opération dynamique unaire si l'objet dynamique cible ne peut pas être lié.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> représentant le résultat de la liaison.</returns>
      <param name="target">Cible de l'opération unaire dynamique.</param>
      <param name="errorSuggestion">Résultat de la liaison en cas d'échec, ou valeur null.</param>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>Type d'opération unaire.</summary>
      <returns>Objet de <see cref="T:System.Linq.Expressions.ExpressionType" /> qui représente le type d'opération unaire.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>Type de résultat de l'opération.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de résultat de l'opération.</returns>
    </member>
    <member name="T:System.Linq.Enumerable">
      <summary>Fournit un ensemble de méthodes statiques (Shared en Visual Basic) pour interroger des structures de données implémentant <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
      <summary>Applique une fonction d'accumulation sur une séquence.</summary>
      <returns>Valeur d'accumulation finale.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> pour l'agrégat.</param>
      <param name="func">Fonction d'accumulation à appeler sur chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="func" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>Applique une fonction d'accumulation sur une séquence.La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale.</summary>
      <returns>Valeur d'accumulation finale.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> pour l'agrégat.</param>
      <param name="seed">Valeur d'accumulation initiale.</param>
      <param name="func">Fonction d'accumulation à appeler sur chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="func" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
      <summary>Applique une fonction d'accumulation sur une séquence.La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale et la fonction spécifiée permet de sélectionner la valeur de résultat.</summary>
      <returns>Valeur d'accumulation finale transformée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> pour l'agrégat.</param>
      <param name="seed">Valeur d'accumulation initiale.</param>
      <param name="func">Fonction d'accumulation à appeler sur chaque élément.</param>
      <param name="resultSelector">Fonction permettant de transformer la valeur d'accumulation finale en valeur de résultat.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
      <typeparam name="TResult">Type de la valeur résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="func" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Détermine si tous les éléments d'une séquence satisfont à une condition.</summary>
      <returns>La valeur est true si tous les éléments de la séquence source réussissent le test dans le prédicat spécifié ou si la séquence est vide, sinon false.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments auxquels appliquer le prédicat.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Détermine si une séquence contient des éléments.</summary>
      <returns>La valeur est true si la séquence source contient des éléments, sinon false..</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à vérifier pour savoir si des éléments y sont présents.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Détermine si des éléments d'une séquence satisfont à une condition.</summary>
      <returns>La valeur est true si des éléments de la séquence source réussissent le test dans le prédicat spécifié, sinon false.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments auxquels appliquer le prédicat.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie l'entrée typée comme <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>Séquence d'entrées typées comme <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <param name="source">Séquence à saisir comme <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une moyenne.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de la source.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme des éléments de la séquence est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou valeur null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)">
      <summary>Convertit les éléments d'un <see cref="T:System.Collections.IEnumerable" /> vers le type spécifié.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant chaque élément de la séquence source converti dans le type spécifié.</returns>
      <param name="source">
        <see cref="T:System.Collections.IEnumerable" /> contenant les éléments à convertir.</param>
      <typeparam name="TResult">Type vers lequel convertir les éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidCastException">Impossible de caster un élément de la séquence en type <paramref name="TResult" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Concatène deux séquences.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments concaténés des deux séquences d'entrée.</returns>
      <param name="first">Première séquence à concaténer.</param>
      <param name="second">Séquence à concaténer à la première séquence.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>Détermine si une séquence contient un élément spécifié à l'aide du comparateur d'égalité par défaut.</summary>
      <returns>La valeur est true si la séquence source contient un élément avec la valeur spécifiée, sinon false.</returns>
      <param name="source">Séquence dans laquelle localiser une valeur.</param>
      <param name="value">Valeur à localiser dans la séquence.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Détermine si une séquence contient un élément spécifié à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> indiqué.</summary>
      <returns>La valeur est true si la séquence source contient un élément avec la valeur spécifiée, sinon false.</returns>
      <param name="source">Séquence dans laquelle localiser une valeur.</param>
      <param name="value">Valeur à localiser dans la séquence.</param>
      <param name="comparer">Comparateur d'égalité à l'aide duquel comparer des valeurs.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie le nombre total d'éléments dans une séquence.</summary>
      <returns>Nombre total d'éléments dans la séquence d'entrée.</returns>
      <param name="source">Séquence contenant les éléments à compter.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie un nombre représentant les éléments de la séquence spécifiée qui satisfont à une condition.</summary>
      <returns>Nombre représentant les éléments de la séquence spécifiée qui satisfont à la condition dans la fonction de prédicat.</returns>
      <param name="source">Séquence contenant les éléments à tester et à compter.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie les éléments de la séquence spécifiée ou la valeur par défaut du paramètre de type dans une collection de singletons si la séquence est vide.</summary>
      <returns>Objet <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant la valeur par défaut pour le type <paramref name="TSource" /> si <paramref name="source" /> est vide, sinon <paramref name="source" />.</returns>
      <param name="source">Séquence pour laquelle renvoyer une valeur par défaut si aucun élément n'y figure.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>Renvoie les éléments de la séquence spécifiée ou la valeur indiquée dans une collection de singletons si la séquence est vide.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant <paramref name="defaultValue" /> si <paramref name="source" /> est vide, sinon <paramref name="source" />.</returns>
      <param name="source">Séquence pour laquelle renvoyer la valeur spécifiée si aucun élément n'y figure.</param>
      <param name="defaultValue">Valeur à renvoyer si la séquence est vide.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie des éléments distincts d'une séquence et utilise le comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments distincts de la séquence source.</returns>
      <param name="source">Séquence de laquelle supprimer les éléments en double.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Renvoie des éléments distincts d'une séquence et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments distincts de la séquence source.</returns>
      <param name="source">Séquence de laquelle supprimer les éléments en double.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Renvoie l'élément à une position d'index spécifiée dans une séquence.</summary>
      <returns>Élément situé à la position spécifiée dans la séquence source.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="index">Index de base zéro de l'élément à récupérer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> est inférieur à 0 ou supérieur ou égal au nombre d’éléments contenus dans <paramref name="source" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Renvoie l'élément situé à un index spécifié dans une séquence ou une valeur par défaut si l'index est hors limites.</summary>
      <returns>default(<paramref name="TSource" />) si l'index est en dehors des limites de la séquence source ; sinon, l'élément situé à la position spécifiée dans la séquence source.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="index">Index de base zéro de l'élément à récupérer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Empty``1">
      <summary>Renvoie un <see cref="T:System.Collections.Generic.IEnumerable`1" /> vide qui a l'argument de type spécifié.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> vide dont l'argument de type est <paramref name="TResult" />.</returns>
      <typeparam name="TResult">Type à assigner au paramètre de type du <see cref="T:System.Collections.Generic.IEnumerable`1" /> générique renvoyé.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit la différence entre deux séquences à l'aide du comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>Séquence contenant la différence entre les éléments de deux séquences.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments qui ne se trouvent pas également dans <paramref name="second" /> seront renvoyés.</param>
      <param name="second">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments figurent également dans la première séquence sera supprimé de la séquence renvoyée.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit la différence entre deux séquences à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>Séquence contenant la différence entre les éléments de deux séquences.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments qui ne se trouvent pas également dans <paramref name="second" /> seront renvoyés.</param>
      <param name="second">Un <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments figurent également dans la première séquence sera supprimé de la séquence renvoyée.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie le premier élément d'une séquence.</summary>
      <returns>Premier élément de la séquence spécifiée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer le premier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie le premier élément d'une séquence à satisfaire à la condition spécifiée.</summary>
      <returns>Premier élément d'une séquence qui réussit le test dans la fonction de prédicat spécifiée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie le premier élément d'une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide, sinon premier élément de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer le premier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie le premier élément de la séquence à satisfaire à une condition ou une valeur par défaut si aucun élément correspondant n'est trouvé.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide ou si aucun élément ne réussit le test spécifié par <paramref name="predicate" /> ; sinon, premier élément de <paramref name="source" /> qui réussit le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# ou IEnumerable(Of IGrouping(Of TKey, TSource)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets et une clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et compare les clés à l'aide du comparateur indiqué.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# ou IEnumerable(Of IGrouping(Of TKey, TSource)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets et une clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et projette les éléments de chaque groupe à l'aide de la fonction indiquée.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# ou IEnumerable(Of IGrouping(Of TKey, TElement)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une collection d'objets de type <paramref name="TElement" /> et une clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon une fonction de sélection de clé.Les clés sont comparées à l'aide d'un comparateur et les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifique.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# ou IEnumerable(Of IGrouping(Of TKey, TElement)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une collection d'objets de type <paramref name="TElement" /> et une clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de sa clé.Les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifiée.</summary>
      <returns>Collection d'éléments de type <paramref name="TResult" /> où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de sa clé.Les valeurs de clé sont comparées à l'aide du comparateur spécifié et les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifique.</summary>
      <returns>Collection d'éléments de type <paramref name="TResult" /> où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de sa clé.</summary>
      <returns>Collection d'éléments de type <paramref name="TResult" /> où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de sa clé.Les clés sont comparées à l'aide d'un comparateur spécifié.</summary>
      <returns>Collection d'éléments de type <paramref name="TResult" /> où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
      <summary>Met en corrélation les éléments de deux séquences en fonction de l'égalité des clés et regroupe les résultats.Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure groupée de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d'un élément de la première séquence ainsi qu'une collection d'éléments correspondants à partir de la deuxième séquence.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Met en corrélation les éléments de deux séquences en fonction de l'égalité des clés et regroupe les résultats.Le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure groupée de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d'un élément de la première séquence ainsi qu'une collection d'éléments correspondants à partir de la deuxième séquence.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour hacher et comparer les clés.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit l'intersection de deux séquences à l'aide du comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>Séquence contenant les éléments constituant l'intersection des deux séquences.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans <paramref name="second" /> seront renvoyés.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans la première séquence seront renvoyés.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit l'intersection entre deux séquences à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>Séquence contenant les éléments constituant l'intersection des deux séquences.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans <paramref name="second" /> seront renvoyés.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans la première séquence seront renvoyés.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
      <summary>Met en corrélation les éléments de deux séquences en fonction des clés correspondantes.Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure interne de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Met en corrélation les éléments de deux séquences en fonction des clés correspondantes.Le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure interne de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour hacher et comparer les clés.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie le dernier élément d'une séquence.</summary>
      <returns>Valeur à la dernière position de la séquence source.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie le dernier élément d'une séquence à satisfaire à la condition spécifiée.</summary>
      <returns>Dernier élément de la séquence qui réussit le test dans la fonction de prédicat spécifiée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie le dernier élément d'une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
      <returns>default(<paramref name="TSource" />) si la séquence source est vide, sinon le dernier élément de <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie le dernier élément d'une séquence à satisfaire à une condition ou une valeur par défaut si aucun élément correspondant n'est trouvé.</summary>
      <returns>default(<paramref name="TSource" />) si la séquence est vide ou si aucun élément ne réussit le test dans la fonction de prédicat ; sinon, le dernier élément qui réussit le test dans cette fonction.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie un <see cref="T:System.Int64" /> représentant le nombre total d'éléments dans une séquence.</summary>
      <returns>Nombre total d'éléments dans la séquence source.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments à compter.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie un <see cref="T:System.Int64" /> représentant le nombre total d'éléments dans une séquence à satisfaire à une condition.</summary>
      <returns>Nombre représentant les éléments de la séquence spécifiée qui satisfont à la condition dans la fonction de prédicat.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments à compter.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Decimal&gt; en C# ou Nullable(Of Decimal) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Double&gt; en C# ou Nullable(Of Double) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Int32&gt; en C# ou Nullable(Of Int32) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Int64&gt; en C# ou Nullable(Of Int64) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Single&gt; en C# ou Nullable(Of Single) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Renvoie la valeur maximale d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie la valeur maximale d'une séquence générique.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Decimal" /> maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Double" /> maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int32" /> maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int64" /> maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Decimal" /> Nullable maximale.</summary>
      <returns>Valeur de type Nullable&lt;Decimal&gt; en C# ou Nullable(Of Decimal) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Double" /> Nullable maximale.</summary>
      <returns>Valeur de type Nullable&lt;Double&gt; en C# ou Nullable(Of Double) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int32" /> Nullable maximale.</summary>
      <returns>Valeur de type Nullable&lt;Int32&gt; en C# ou Nullable(Of Int32) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int64" /> Nullable maximale.</summary>
      <returns>Valeur de type Nullable&lt;Int64&gt; en C# ou Nullable(Of Int64) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Single" /> Nullable maximale.</summary>
      <returns>Valeur de type Nullable&lt;Single&gt; en C# ou Nullable(Of Single) en Visual Basic qui correspond à la valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Single" /> maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence générique et renvoie la valeur résultante maximale.</summary>
      <returns>Valeur maximale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur maximale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Decimal&gt; en C# ou Nullable(Of Decimal) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Double&gt; en C# ou Nullable(Of Double) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Int32&gt; en C# ou Nullable(Of Int32) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable pour laquelle déterminer la valeur maximale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Int64&gt; en C# ou Nullable(Of Int64) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Valeur de type Nullable&lt;Single&gt; en C# ou Nullable(Of Single) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Renvoie la valeur minimale d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> pour laquelle déterminer la valeur minimale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie la valeur minimale d'une séquence générique.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Decimal" /> minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Double" /> minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int32" /> minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int64" /> minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Decimal" /> Nullable minimale.</summary>
      <returns>Valeur de type Nullable&lt;Decimal&gt; en C# ou Nullable(Of Decimal) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Double" /> Nullable minimale.</summary>
      <returns>Valeur de type Nullable&lt;Double&gt; en C# ou Nullable(Of Double) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int32" /> Nullable minimale.</summary>
      <returns>Valeur de type Nullable&lt;Int32&gt; en C# ou Nullable(Of Int32) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Int64" /> Nullable minimale.</summary>
      <returns>Valeur de type Nullable&lt;Int64&gt; en C# ou Nullable(Of Int64) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Single" /> Nullable minimale.</summary>
      <returns>Valeur de type Nullable&lt;Single&gt; en C# ou Nullable(Of Single) en Visual Basic qui correspond à la valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence et renvoie la valeur <see cref="T:System.Single" /> minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Appelle une fonction de transformation sur chaque élément d'une séquence générique et renvoie la valeur résultante minimale.</summary>
      <returns>Valeur minimale de la séquence.</returns>
      <param name="source">Séquence de valeurs pour laquelle déterminer la valeur minimale.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)">
      <summary>Filtre les éléments d'un <see cref="T:System.Collections.IEnumerable" /> en fonction du type spécifié.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de la séquence d'entrée de type <paramref name="TResult" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.IEnumerable" /> dont les éléments doivent être filtrés.</param>
      <typeparam name="TResult">Type en fonction duquel filtrer les éléments de la séquence.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre croissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre croissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre décroissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre décroissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)">
      <summary>Génère une séquence de nombres entiers dans une plage spécifiée.</summary>
      <returns>IEnumerable&lt;Int32&gt; en C# ou IEnumerable(Of Int32) en Visual Basic qui contient une plage d'entiers séquentiels.</returns>
      <param name="start">Valeur du premier entier de la séquence.</param>
      <param name="count">Nombre d'entiers séquentiels à générer.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> est inférieur à 0.– ou –<paramref name="start" /> + <paramref name="count" /> -1 est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)">
      <summary>Génère une séquence contenant une valeur répétée.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant une valeur répétée.</returns>
      <param name="element">Valeur à répéter.</param>
      <param name="count">Nombre de fois où la valeur doit être répétée dans la séquence générée.</param>
      <typeparam name="TResult">Type de la valeur à répéter dans la séquence de résultat.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Inverse l'ordre des éléments dans une séquence.</summary>
      <returns>Séquence dont les éléments correspondent à ceux de la séquence d'entrée dans l'ordre inverse.</returns>
      <param name="source">Séquence de valeurs à inverser.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Projette chaque élément d'une séquence dans un nouveau formulaire.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments résultent d'un appel de la fonction de transformation sur chaque élément de <paramref name="source" />.</returns>
      <param name="source">Séquence de valeurs pour laquelle appeler une fonction de transformation.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
      <summary>Projette chaque élément d'une séquence dans un nouveau formulaire en incorporant l'index de l'élément.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments résultent d'un appel de la fonction de transformation sur chaque élément de <paramref name="source" />.</returns>
      <param name="source">Séquence de valeurs pour laquelle appeler une fonction de transformation.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément source ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" />, aplatit les séquences résultantes en une seule séquence et appelle une fonction de sélection de résultat sur chaque élément inclus.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont le résultat de l'appel de la fonction de transformation un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" />, puis du mappage de chacun de ces éléments de séquence et de leur élément source correspondant en un élément de résultat.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="collectionSelector">Fonction de transformation à appliquer à chaque élément de la séquence d'entrée.</param>
      <param name="resultSelector">Fonction de transformation à appliquer à chaque élément de la séquence intermédiaire.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Type des éléments intermédiaires collectés par <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et aplatit les séquences résultantes en une séquence.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments résultent d'un appel de la fonction de transformation de type un-à-plusieurs sur chaque élément de la séquence d'entrée.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" />, aplatit les séquences résultantes en une seule séquence et appelle une fonction de sélection de résultat sur chaque élément inclus.L'index de chaque élément source est utilisé dans le formulaire intermédiaire projeté de l'élément.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont le résultat de l'appel de la fonction de transformation un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" />, puis du mappage de chacun de ces éléments de séquence et de leur élément source correspondant en un élément de résultat.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="collectionSelector">Fonction de transformation à appliquer à chaque élément source ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <param name="resultSelector">Fonction de transformation à appliquer à chaque élément de la séquence intermédiaire.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Type des éléments intermédiaires collectés par <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et aplatit les séquences résultantes en une séquence.L'index de chaque élément source est utilisé dans le formulaire projeté de l'élément.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments résultent d'un appel de la fonction de transformation de type un-à-plusieurs sur chaque élément d'une séquence d'entrée.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément source ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence renvoyée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Détermine si deux séquences sont égales par une comparaison des types d'élément réalisée à l'aide du comparateur d'égalité par défaut.</summary>
      <returns>La valeur est true si les deux séquences source sont de même longueur et si les types de leurs éléments correspondants sont égaux selon le comparateur d'égalité par défaut, sinon false.</returns>
      <param name="first">Objet <see cref="T:System.Collections.Generic.IEnumerable`1" /> à comparer à <paramref name="second" />.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à comparer à la première séquence.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Détermine si deux séquences sont égales en comparant leurs éléments à l'aide d'un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</summary>
      <returns>La valeur est true si les deux séquences sources sont de longueur égale et que leurs éléments correspondants sont égaux d'après <paramref name="comparer" />, sinon false.</returns>
      <param name="first">Objet <see cref="T:System.Collections.Generic.IEnumerable`1" /> à comparer à <paramref name="second" />.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à comparer à la première séquence.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser pour comparer les éléments.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> a plusieurs éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie l'élément unique d'une séquence ou lève une exception si cette séquence ne contient pas un seul élément.</summary>
      <returns>Élément unique de la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer l'élément unique.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence d'entrée contient plusieurs éléments.– ou –La séquence d'entrée est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie le seul élément d'une séquence qui satisfait à une condition spécifique ou lève une exception si cette séquence contient plusieurs éléments satisfaisant à cette condition.</summary>
      <returns>Seul élément de la séquence d'entrée à satisfaire à une condition.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> duquel renvoyer un élément unique.</param>
      <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –Plusieurs éléments satisfont à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Renvoie l'élément unique d'une séquence ou une valeur par défaut. Cette méthode lève une exception si cette séquence contient plusieurs éléments.</summary>
      <returns>Élément unique de la séquence d'entrée ou default(<paramref name="TSource" />) si la séquence ne contient aucun élément.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> duquel renvoyer l'élément unique.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence d'entrée contient plusieurs éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie l'élément unique d'une séquence ou une valeur par défaut si cette séquence ne contient pas d'élément respectant cette condition. Cette méthode lève une exception si cette séquence contient plusieurs éléments satisfaisant à cette condition.</summary>
      <returns>Seul élément de la séquence d'entrée satisfaisant à la condition ou default(<paramref name="TSource" />) si cet élément n'est pas trouvé.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> duquel renvoyer un élément unique.</param>
      <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Ignore un nombre spécifié d'éléments dans une séquence, puis renvoie les éléments restants.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments se trouvant après l'index spécifié dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="count">Nombre d'éléments à ignorer avant de renvoyer les éléments restants.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Ignore des éléments dans une séquence tant que la condition spécifiée a la valeur true, puis renvoie les éléments restants.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments de la séquence d'entrée, à partir du premier élément de la série linéaire à ne pas réussir le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Ignore des éléments dans une séquence tant que la condition spécifiée a la valeur true, puis renvoie les éléments restants.L'index de l'élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments de la séquence d'entrée, à partir du premier élément de la série linéaire à ne pas réussir le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément source pour une condition ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" /> Nullable obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" /> obtenues en appelant une fonction de transformation sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une somme.</param>
      <param name="selector">Fonction de transformation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Renvoie un nombre spécifié d'éléments contigus à partir du début d'une séquence.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant le nombre spécifié d'éléments à partir du début de la séquence d'entrée.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="count">Nombre d'éléments à renvoyer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Renvoie des éléments d'une séquence tant que la condition spécifiée a la valeur true.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments de la séquence d'entrée se trouvant avant l'élément à partir duquel le test échoue.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Renvoie des éléments d'une séquence tant que la condition spécifiée a la valeur true.L'index de l'élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments de la séquence d'entrée se trouvant avant l'élément à partir duquel le test échoue.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément source pour une condition ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre croissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> contenant les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre croissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> contenant les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre décroissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> contenant les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre décroissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> contenant les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Crée un tableau à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>Tableau contenant les éléments de la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un tableau.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Crée un <see cref="T:System.Collections.Generic.Dictionary`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.Dictionary`2" /> contenant des clés et des valeurs.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.– ou –<paramref name="keySelector" /> produit une clé qui a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> produit des clés en double pour deux éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crée un <see cref="T:System.Collections.Generic.Dictionary`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée et un comparateur de clé.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.Dictionary`2" /> contenant des clés et des valeurs.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.– ou –<paramref name="keySelector" /> produit une clé qui a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> produit des clés en double pour deux éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Crée un <see cref="T:System.Collections.Generic.Dictionary`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon des fonctions de sélection de clé et de sélection d'élément spécifiées.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.Dictionary`2" /> contenant des valeurs de type <paramref name="TElement" /> sélectionnées dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="elementSelector">Fonction de transformation permettant de produire une valeur d'élément de résultat à partir de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type de la valeur renvoyée par <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.– ou –<paramref name="keySelector" /> produit une clé qui a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> produit des clés en double pour deux éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crée un <see cref="T:System.Collections.Generic.Dictionary`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée, un comparateur et une fonction de sélection d'élément.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.Dictionary`2" /> contenant des valeurs de type <paramref name="TElement" /> sélectionnées dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="elementSelector">Fonction de transformation permettant de produire une valeur d'élément de résultat à partir de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type de la valeur renvoyée par <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.– ou –<paramref name="keySelector" /> produit une clé qui a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> produit des clés en double pour deux éléments.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Crée un <see cref="T:System.Collections.Generic.List`1" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.List`1" /> contenant les éléments de la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer une <see cref="T:System.Collections.Generic.List`1" />.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Crée un <see cref="T:System.Linq.Lookup`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Lookup`2" /> contenant des clés et des valeurs.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crée un <see cref="T:System.Linq.Lookup`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée et un comparateur de clé.</summary>
      <returns>
        <see cref="T:System.Linq.Lookup`2" /> contenant des clés et des valeurs.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Crée un <see cref="T:System.Linq.Lookup`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon des fonctions de sélection de clé et de sélection d'élément spécifiées.</summary>
      <returns>
        <see cref="T:System.Linq.Lookup`2" /> contenant des valeurs de type <paramref name="TElement" /> sélectionnées dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="elementSelector">Fonction de transformation permettant de produire une valeur d'élément de résultat à partir de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type de la valeur renvoyée par <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crée un <see cref="T:System.Linq.Lookup`2" /> à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> selon une fonction de sélection de clé spécifiée, un comparateur et une fonction de sélection d'élément.</summary>
      <returns>
        <see cref="T:System.Linq.Lookup`2" /> contenant des valeurs de type <paramref name="TElement" /> sélectionnées dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à partir duquel créer un <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="elementSelector">Fonction de transformation permettant de produire une valeur d'élément de résultat à partir de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type de la valeur renvoyée par <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit l'union de deux séquences à l'aide du comparateur d'égalité par défaut.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments des deux séquences d'entrée, à l'exception des éléments en double.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts constituent le premier ensemble de l'union.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts constituent le deuxième ensemble de l'union.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit l'union de deux séquences à l'aide d'un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments des deux séquences d'entrée, à l'exception des éléments en double.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts constituent le premier ensemble de l'union.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts constituent le deuxième ensemble de l'union.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Filtre une séquence de valeurs selon un prédicat.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de la séquence d'entrée satisfaisant à la condition.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à filtrer.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Filtre une séquence de valeurs selon un prédicat.L'index de chaque élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des éléments de la séquence d'entrée satisfaisant à la condition.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> à filtrer.</param>
      <param name="predicate">Fonction permettant de tester chaque élément source pour une condition ; le deuxième paramètre de la fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
      <summary>Fusionne deux séquences en utilisant la fonction de prédicat spécifiée.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant les éléments fusionnés des deux séquences d'entrée.</returns>
      <param name="first">Première séquence à fusionner.</param>
      <param name="second">Deuxième séquence à fusionner.</param>
      <param name="resultSelector">Fonction spécifiant comment fusionner les éléments des deux séquences.</param>
      <typeparam name="TFirst">Type des éléments de la première séquence d'entrée.</typeparam>
      <typeparam name="TSecond">Type des éléments de la deuxième séquence d'entrée.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> ou <paramref name="second" /> est null.</exception>
    </member>
    <member name="T:System.Linq.EnumerableExecutor">
      <summary>Représente une arborescence de l'expression et fournit les fonctionnalités pour exécuter l'arborescence d'expression après l'avoir réécrite.</summary>
    </member>
    <member name="M:System.Linq.EnumerableExecutor.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.EnumerableExecutor" />.</summary>
    </member>
    <member name="T:System.Linq.EnumerableExecutor`1">
      <summary>Représente une arborescence de l'expression et fournit les fonctionnalités pour exécuter l'arborescence d'expression après l'avoir réécrit.</summary>
      <typeparam name="T">Type de données de la valeur résultant de l'exécution de l'arborescence de l'expression.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableExecutor`1.#ctor(System.Linq.Expressions.Expression)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.EnumerableExecutor`1" />.</summary>
      <param name="expression">Arborescence de l'expression à associer à la nouvelle instance.</param>
    </member>
    <member name="T:System.Linq.EnumerableQuery">
      <summary>Représente une <see cref="T:System.Collections.IEnumerable" /> sous la forme d'une source de données <see cref="T:System.Linq.EnumerableQuery" />. </summary>
    </member>
    <member name="M:System.Linq.EnumerableQuery.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.EnumerableQuery" />.</summary>
    </member>
    <member name="T:System.Linq.EnumerableQuery`1">
      <summary>Représente une <see cref="T:System.Collections.Generic.IEnumerable`1" /> sous la forme d'une source de données <see cref="T:System.Linq.IQueryable`1" />.</summary>
      <typeparam name="T">Type des données contenues dans la collection.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.EnumerableQuery`1" /> et l'associe à une collection <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="enumerable">Collection à associer à la nouvelle instance.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.#ctor(System.Linq.Expressions.Expression)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.EnumerableQuery`1" /> et associe l'instance à une arborescence de l'expression.</summary>
      <param name="expression">Arborescence de l'expression à associer à la nouvelle instance.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Renvoie un énumérateur pouvant itérer au sein de la collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> associée, ou, si sa valeur est null, la collection résultant de la réécriture de l'arborescence de l'expression associée en tant que requête sur une source de données <see cref="T:System.Collections.Generic.IEnumerable`1" /> et de son exécution.</summary>
      <returns>Énumérateur pouvant itérer au sein de la source de données associée.</returns>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Renvoie un énumérateur pouvant itérer au sein de la collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> associée, ou, si sa valeur est null, la collection résultant de la réécriture de l'arborescence de l'expression associée en tant que requête sur une source de données <see cref="T:System.Collections.Generic.IEnumerable`1" /> et de son exécution.</summary>
      <returns>Énumérateur pouvant itérer au sein de la source de données associée.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#ElementType">
      <summary>Obtient le type de données dans la collection que représente cette instance.</summary>
      <returns>Type de données dans la collection que représente cette instance.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#Expression">
      <summary>Obtient l'arborescence de l'expression associée à cette instance ou qui la représente.</summary>
      <returns>Arborescence de l'expression associée à cette instance ou qui la représente.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette instance.</summary>
      <returns>Fournisseur de requêtes associé à cette instance.</returns>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.EnumerableQuery`1" /> et l'associe à une arborescence de l'expression spécifiée représentant une collection de données <see cref="T:System.Linq.IQueryable`1" />.</summary>
      <returns>Objet EnumerableQuery associé à <paramref name="expression" />.</returns>
      <param name="expression">Arborescence de l'expression à exécuter.</param>
      <typeparam name="S">Type de données contenues dans la collection que représente <paramref name="expression" />.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.EnumerableQuery`1" /> et l'associe à une arborescence de l'expression spécifiée représentant une collection de données <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>Objet <see cref="T:System.Linq.EnumerableQuery`1" /> associé à <paramref name="expression" />.</returns>
      <param name="expression">Arborescence de l'expression représentant une collection de données <see cref="T:System.Linq.IQueryable" />.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute une expression après l'avoir réécrit pour appeler des méthodes <see cref="T:System.Linq.Enumerable" /> à la place des méthodes <see cref="T:System.Linq.Queryable" /> sur des sources de données énumérables ne pouvant pas être interrogées par les méthodes <see cref="T:System.Linq.Queryable" />.</summary>
      <returns>Valeur qui résulte de l'exécution de <paramref name="expression" />.</returns>
      <param name="expression">Arborescence de l'expression à exécuter.</param>
      <typeparam name="S">Type de données contenues dans la collection que représente <paramref name="expression" />.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute une expression après l'avoir réécrit pour appeler des méthodes <see cref="T:System.Linq.Enumerable" /> à la place des méthodes <see cref="T:System.Linq.Queryable" /> sur des sources de données énumérables ne pouvant pas être interrogées par les méthodes <see cref="T:System.Linq.Queryable" />.</summary>
      <returns>Valeur résultant de l'exécution de <paramref name="expression" />.</returns>
      <param name="expression">Arborescence de l'expression à exécuter.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.ToString">
      <summary>Renvoie une représentation textuelle de la collection énumérable ou, si la valeur est null, de l'arborescence de l'expression associée à cette instance.</summary>
      <returns>Représentation textuelle de la collection énumérable ou, si la valeur est null, de l'arborescence de l'expression associée à cette instance.</returns>
    </member>
    <member name="T:System.Linq.IGrouping`2">
      <summary>Représente une collection d'objets qui ont une clé commune.</summary>
      <typeparam name="TKey">Type de la clé de <see cref="T:System.Linq.IGrouping`2" />.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="TElement">Type des valeurs de <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
    </member>
    <member name="P:System.Linq.IGrouping`2.Key">
      <summary>Obtient la clé de <see cref="T:System.Linq.IGrouping`2" />.</summary>
      <returns>Clé de <see cref="T:System.Linq.IGrouping`2" />.</returns>
    </member>
    <member name="T:System.Linq.ILookup`2">
      <summary>Définit un indexeur, la propriété de taille et la méthode de recherche booléenne pour les structures de données mappant des clés sur des séquences de valeurs <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <typeparam name="TKey">Type des clés contenues dans <see cref="T:System.Linq.ILookup`2" />.</typeparam>
      <typeparam name="TElement">Type des éléments contenus dans les séquences <see cref="T:System.Collections.Generic.IEnumerable`1" /> constituant les valeurs de <see cref="T:System.Linq.ILookup`2" />.</typeparam>
    </member>
    <member name="M:System.Linq.ILookup`2.Contains(`0)">
      <summary>Détermine si une clé spécifiée se trouve dans <see cref="T:System.Linq.ILookup`2" />.</summary>
      <returns>La valeur est true si <paramref name="key" /> figure dans <see cref="T:System.Linq.ILookup`2" />, sinon false.</returns>
      <param name="key">Clé à rechercher dans <see cref="T:System.Linq.ILookup`2" />.</param>
    </member>
    <member name="P:System.Linq.ILookup`2.Count">
      <summary>Obtient le nombre de paires clé/collection de valeurs contenues dans <see cref="T:System.Linq.ILookup`2" />.</summary>
      <returns>Nombre de paires clé/collection de valeurs contenues dans <see cref="T:System.Linq.ILookup`2" />.</returns>
    </member>
    <member name="P:System.Linq.ILookup`2.Item(`0)">
      <summary>Obtient la séquence de valeurs <see cref="T:System.Collections.Generic.IEnumerable`1" /> indexées par une clé spécifiée.</summary>
      <returns>Séquence de valeurs <see cref="T:System.Collections.Generic.IEnumerable`1" /> indexées par la clé spécifiée.</returns>
      <param name="key">Clé de la séquence de valeurs souhaitée.</param>
    </member>
    <member name="T:System.Linq.IOrderedEnumerable`1">
      <summary>Représente une séquence triée.</summary>
      <typeparam name="TElement">Type des éléments de la séquence.</typeparam>
    </member>
    <member name="M:System.Linq.IOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
      <summary>Effectue un classement postérieur sur les éléments d'un <see cref="T:System.Linq.IOrderedEnumerable`1" /> d'après une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="keySelector">
        <see cref="T:System.Func`2" /> utilisé pour extraire la clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> utilisé pour comparer des clés en vue de leur positionnement dans la séquence renvoyée.</param>
      <param name="descending">La valeur est true pour trier les éléments par ordre décroissant, false pour les trier par ordre croissant.</param>
      <typeparam name="TKey">Type de la clé produite par <paramref name="keySelector" />.</typeparam>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Représente le résultat d'une opération de tri.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Représente le résultat d'une opération de tri.</summary>
      <typeparam name="T">Type du contenu de la source de données.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données n'est pas défini.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtient le type du ou des éléments renvoyés lors de l'exécution de l'arborescence d'expression associée à cette instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> représentant le type du ou des éléments renvoyés lorsque l'arborescence d'expression associée à cet objet est exécutée.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtient l'arborescence d'expression associée à l'instance de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> associé à cette instance de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtient le fournisseur de requêtes associé à cette source de données.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> associé à cette source de données.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Fournit les fonctionnalités permettant d'évaluer les requêtes appliquées à une source de données spécifique dont le type de données est connu.</summary>
      <typeparam name="T">Type des données contenues dans la source de données.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Définit des méthodes destinées à créer et exécuter des requêtes décrites par un objet <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression représentant une requête LINQ.</param>
      <typeparam name="TElement">Type des éléments du <see cref="T:System.Linq.IQueryable`1" /> renvoyé.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construit un objet <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> capable d'évaluer la requête représentée par l'arborescence d'expression spécifiée.</returns>
      <param name="expression">Arborescence d'expression représentant une requête LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête fortement typée représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur résultant de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression représentant une requête LINQ.</param>
      <typeparam name="TResult">Type de la valeur résultant de l'exécution de la requête.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Exécute la requête représentée par une arborescence d'expression spécifiée.</summary>
      <returns>Valeur résultant de l'exécution de la requête spécifiée.</returns>
      <param name="expression">Arborescence d'expression représentant une requête LINQ.</param>
    </member>
    <member name="T:System.Linq.Lookup`2">
      <summary>Représente une collection de clés, chacune mappée sur une ou plusieurs valeurs.</summary>
      <typeparam name="TKey">Type des clés contenues dans <see cref="T:System.Linq.Lookup`2" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque valeur <see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Linq.Lookup`2" />.</typeparam>
    </member>
    <member name="M:System.Linq.Lookup`2.ApplyResultSelector``1(System.Func{`0,System.Collections.Generic.IEnumerable{`1},``0})">
      <summary>Applique une fonction de transformation à chaque clé et à ses valeurs associées, puis renvoie les résultats.</summary>
      <returns>Collection qui contient une valeur pour chaque paire clé/collection de valeurs présente dans <see cref="T:System.Linq.Lookup`2" />.</returns>
      <param name="resultSelector">Fonction destinée à projeter une valeur de résultat à partir de chaque clé et de ses valeurs associées.</param>
      <typeparam name="TResult">Type des valeurs de résultat produites par <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Lookup`2.Contains(`0)">
      <summary>Détermine si une clé spécifiée se trouve dans <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>La valeur est true si <paramref name="key" /> figure dans <see cref="T:System.Linq.Lookup`2" />, sinon false.</returns>
      <param name="key">Clé à rechercher dans <see cref="T:System.Linq.Lookup`2" />.</param>
    </member>
    <member name="P:System.Linq.Lookup`2.Count">
      <summary>Obtient le nombre de paires clé/collection de valeurs contenues dans <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>Nombre de paires clé/collection de valeurs contenues dans <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="M:System.Linq.Lookup`2.GetEnumerator">
      <summary>Renvoie un énumérateur générique qui itère au sein de <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>Énumérateur pour <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="P:System.Linq.Lookup`2.Item(`0)">
      <summary>Obtient la collection de valeurs indexées par la clé spécifiée.</summary>
      <returns>Collection de valeurs indexées par la clé spécifiée.</returns>
      <param name="key">Clé de la collection de valeurs souhaitée.</param>
    </member>
    <member name="M:System.Linq.Lookup`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>Renvoie un énumérateur qui itère au sein de <see cref="T:System.Linq.Lookup`2" />.Cette classe ne peut pas être héritée.</summary>
      <returns>Énumérateur pour <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="T:System.Linq.Queryable">
      <summary>Fournit un jeu de méthodes statiques (Shared dans Visual Basic) pour interroger des structures de données implémentant <see cref="T:System.Linq.IQueryable`1" />.</summary>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})">
      <summary>Applique une fonction d'accumulation sur une séquence.</summary>
      <returns>Valeur d'accumulation finale.</returns>
      <param name="source">Séquence à regrouper.</param>
      <param name="func">Fonction d'accumulation à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="func" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})">
      <summary>Applique une fonction d'accumulation sur une séquence.La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale.</summary>
      <returns>Valeur d'accumulation finale.</returns>
      <param name="source">Séquence à regrouper.</param>
      <param name="seed">Valeur d'accumulation initiale.</param>
      <param name="func">Fonction d'accumulation à appeler sur chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="func" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
      <summary>Applique une fonction d'accumulation sur une séquence.La valeur initiale spécifiée est utilisée comme valeur d'accumulation initiale et la fonction spécifiée permet de sélectionner la valeur de résultat.</summary>
      <returns>Valeur d'accumulation finale transformée.</returns>
      <param name="source">Séquence à regrouper.</param>
      <param name="seed">Valeur d'accumulation initiale.</param>
      <param name="func">Fonction d'accumulation à appeler sur chaque élément.</param>
      <param name="selector">Fonction permettant de transformer la valeur d'accumulation finale en valeur de résultat.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Type de la valeur d'accumulation.</typeparam>
      <typeparam name="TResult">Type de la valeur résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="func" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Détermine si tous les éléments d'une séquence satisfont à une condition.</summary>
      <returns>La valeur est true si tous les éléments de la séquence source réussissent le test dans le prédicat spécifié ou si la séquence est vide, sinon false.</returns>
      <param name="source">Séquence dont les éléments doivent être testés par rapport à une condition.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})">
      <summary>Détermine si une séquence contient des éléments.</summary>
      <returns>La valeur est true si la séquence source contient des éléments, sinon false..</returns>
      <param name="source">Séquence à vérifier pour y détecter l'absence de données.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Détermine si des éléments d'une séquence satisfont à une condition.</summary>
      <returns>La valeur true si des éléments de la séquence source réussissent le test dans le prédicat spécifié, sinon false.</returns>
      <param name="source">Séquence dont les éléments doivent être testés par rapport à une condition.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Convertit un <see cref="T:System.Collections.Generic.IEnumerable`1" /> générique en <see cref="T:System.Linq.IQueryable`1" /> générique.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> représentant la séquence d'entrée.</returns>
      <param name="source">Séquence à convertir.</param>
      <typeparam name="TElement">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)">
      <summary>Convertit un <see cref="T:System.Collections.IEnumerable" /> en <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> représentant la séquence d'entrée.</returns>
      <param name="source">Séquence à convertir.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="source" /> n’implémente pas <see cref="T:System.Collections.Generic.IEnumerable`1" /> pour certains <paramref name="T" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence source est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> dont la moyenne doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs utilisées pour calculer une moyenne.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence <paramref name="source" /> est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Double" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence <paramref name="source" /> est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence <paramref name="source" /> est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence <paramref name="source" /> est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs ou null si la séquence <paramref name="source" /> est vide ou ne contient que des valeurs null.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Calcule la moyenne d'une séquence de valeurs <see cref="T:System.Single" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Moyenne de la séquence de valeurs.</returns>
      <param name="source">Séquence de valeurs dont la moyenne doit être calculée.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> ne contient aucun élément.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)">
      <summary>Convertit les éléments d'un <see cref="T:System.Linq.IQueryable" /> vers le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant chaque élément de la séquence source converti dans le type spécifié.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable" /> contenant les éléments à convertir.</param>
      <typeparam name="TResult">Type vers lequel convertir les éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidCastException">Impossible de caster un élément de la séquence en type <paramref name="TResult" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Concatène deux séquences.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments concaténés des deux séquences d'entrée.</returns>
      <param name="source1">Première séquence à concaténer.</param>
      <param name="source2">Séquence à concaténer à la première séquence.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)">
      <summary>Détermine si une séquence contient un élément spécifié à l'aide du comparateur d'égalité par défaut.</summary>
      <returns>La valeur est true si la séquence d'entrée contient un élément avec la valeur spécifiée, sinon false.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dans lequel localiser <paramref name="item" />.</param>
      <param name="item">Objet à localiser dans la séquence.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Détermine si une séquence contient un élément spécifié à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> indiqué.</summary>
      <returns>La valeur est true si la séquence d'entrée contient un élément avec la valeur spécifiée, sinon false.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dans lequel localiser <paramref name="item" />.</param>
      <param name="item">Objet à localiser dans la séquence.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie le nombre total d'éléments dans une séquence.</summary>
      <returns>Nombre total d'éléments dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments à compter.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le nombre d'éléments dans la séquence spécifiée qui satisfait à une condition.</summary>
      <returns>Nombre d'éléments de la séquence qui satisfont à la condition dans la fonction de prédicat.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments à compter.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dans <paramref name="source" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie les éléments de la séquence spécifiée ou la valeur par défaut du paramètre de type dans une collection de singletons si la séquence est vide.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant default(<paramref name="TSource" />) si <paramref name="source" /> est vide, sinon <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> pour lequel renvoyer une valeur par défaut si vide.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)">
      <summary>Renvoie les éléments de la séquence spécifiée ou la valeur indiquée dans une collection de singletons si la séquence est vide.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant <paramref name="defaultValue" /> si <paramref name="source" /> est vide, sinon <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> pour lequel renvoyer la valeur spécifiée si vide.</param>
      <param name="defaultValue">Valeur à renvoyer si la séquence est vide.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie des éléments distincts d'une séquence et utilise le comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments distincts de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dans lequel supprimer les doublons.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Renvoie des éléments distincts d'une séquence et utilise le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments distincts de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dans lequel supprimer les doublons.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Renvoie l'élément à une position d'index spécifiée dans une séquence.</summary>
      <returns>Élément à la position spécifiée dans <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="index">Index de base zéro de l'élément à récupérer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> est inférieur à zéro.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Renvoie l'élément situé à un index spécifié dans une séquence ou une valeur par défaut si l'index est hors limites.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="index" /> est hors des limites de <paramref name="source" />, sinon élément à la position spécifiée dans <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="index">Index de base zéro de l'élément à récupérer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit la différence entre deux séquences à l'aide du comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant la différence des deux séquences.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments ne se trouvent pas également dans <paramref name="source2" /> seront renvoyés.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments apparaissent également dans la première séquence ne figurera pas dans la séquence renvoyée.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit la différence entre deux séquences à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant la différence des deux séquences.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments ne se trouvent pas également dans <paramref name="source2" /> seront renvoyés.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments apparaissent également dans la première séquence ne figurera pas dans la séquence renvoyée.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie le premier élément d'une séquence.</summary>
      <returns>Premier élément de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le premier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le premier élément d'une séquence qui satisfait à la condition spécifiée.</summary>
      <returns>Premier élément de <paramref name="source" /> qui réussit le test dans <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie le premier élément d'une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide, sinon premier élément de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le premier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le premier élément d'une séquence qui satisfait à une condition spécifiée ou une valeur par défaut si aucun élément ne correspond.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide ou si aucun élément ne réussit le test spécifié par <paramref name="predicate" />, sinon premier élément de <paramref name="source" /> qui réussit le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# ou IQueryable(Of IGrouping(Of TKey, TSource)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets et une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et compare les clés à l'aide du comparateur indiqué.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# ou IQueryable(Of IGrouping(Of TKey, TSource)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets et une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et projette les éléments de chaque groupe à l'aide de la fonction indiquée.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# ou IQueryable(Of IGrouping(Of TKey, TElement)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets de type <paramref name="TElement" /> et une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence et projette les éléments pour chaque groupe en utilisant une fonction spécifiée.Les valeurs de clés sont comparées à l'aide d'un comparateur spécifié.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# ou IQueryable(Of IGrouping(Of TKey, TElement)) en Visual Basic, où chaque objet <see cref="T:System.Linq.IGrouping`2" /> contient une séquence d'objets de type <paramref name="TElement" /> et une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante.Les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifique.</summary>
      <returns>T:System.Linq.IQueryable`1 disposant d'un argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante.Les clés sont comparées à l'aide du comparateur spécifié et les éléments de chaque groupe sont projetés à l'aide d'une fonction spécifique.</summary>
      <returns>T:System.Linq.IQueryable`1 disposant d'un argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="elementSelector">Fonction permettant de mapper chaque élément source à un élément de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Type des éléments de chaque <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" />, <paramref name="resultSelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante.</summary>
      <returns>T:System.Linq.IQueryable`1 disposant d'un argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Regroupe les éléments d'une séquence selon la fonction de sélection de clé spécifiée et crée une valeur de résultat à partir de chaque groupe et de la clé correspondante.Les clés sont comparées à l'aide d'un comparateur spécifié.</summary>
      <returns>T:System.Linq.IQueryable`1 disposant d'un argument de type <paramref name="TResult" /> et où chaque élément représente une projection sur un groupe et sa clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments doivent être regroupés.</param>
      <param name="keySelector">Fonction permettant d'extraire la clé de chaque élément.</param>
      <param name="resultSelector">Fonction permettant de créer une valeur de résultat à partir de chaque groupe.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée dans <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Type de la valeur de résultat renvoyée par <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" />, <paramref name="resultSelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})">
      <summary>Met en corrélation les éléments de deux séquences en fonction de l'égalité des clés et regroupe les résultats.Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus en exécutant une jointure groupée sur deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d'un élément de la première séquence, ainsi qu'une collection d'éléments correspondants à partir de la deuxième séquence.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Met en corrélation les éléments de deux séquences en fonction de l'égalité des clés et regroupe les résultats.<see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus en exécutant une jointure groupée sur deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir d'un élément de la première séquence, ainsi qu'une collection d'éléments correspondants à partir de la deuxième séquence.</param>
      <param name="comparer">Comparateur pour hacher et comparer des clés.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit l'intersection de deux séquences à l'aide du comparateur d'égalité par défaut pour comparer les valeurs.</summary>
      <returns>Séquence qui contient l'intersection définie des deux séquences.</returns>
      <param name="source1">Séquence dont les éléments distincts qui apparaissent également dans <paramref name="source2" /> sont renvoyés.</param>
      <param name="source2">Séquence dont les éléments distincts qui apparaissent également dans la première séquence sont renvoyés.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit l'intersection entre deux séquences à l'aide du <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer les valeurs.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant l'intersection des deux séquences.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments distincts qui apparaissent également dans <paramref name="source2" /> sont renvoyés.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments distincts qui apparaissent également dans la première séquence sont renvoyés.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
      <summary>Met en corrélation les éléments de deux séquences en fonction des clés qui correspondent.Le comparateur d'égalité par défaut est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure interne de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Met en corrélation les éléments de deux séquences en fonction des clés qui correspondent.Le <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié est utilisé pour comparer les clés.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant des éléments de type <paramref name="TResult" /> obtenus à la suite d'une jointure interne de deux séquences.</returns>
      <param name="outer">Première séquence à joindre.</param>
      <param name="inner">Séquence à joindre à la première séquence.</param>
      <param name="outerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la première séquence.</param>
      <param name="innerKeySelector">Fonction permettant d'extraire la clé de jointure de chaque élément de la deuxième séquence.</param>
      <param name="resultSelector">Fonction permettant de créer un élément de résultat à partir de deux éléments correspondants.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour hacher et comparer les clés.</param>
      <typeparam name="TOuter">Type des éléments de la première séquence.</typeparam>
      <typeparam name="TInner">Type des éléments de la deuxième séquence.</typeparam>
      <typeparam name="TKey">Type des clés renvoyées par les fonctions de sélecteur de clé.</typeparam>
      <typeparam name="TResult">Type des éléments de résultat.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie le dernier élément d'une séquence.</summary>
      <returns>Valeur située à la dernière position de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le dernier élément d'une séquence à satisfaire à la condition spécifiée.</summary>
      <returns>Le dernier élément de <paramref name="source" /> qui réussit le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie le dernier élément d'une séquence ou une valeur par défaut si la séquence ne contient aucun élément.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide, sinon dernier élément de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le dernier élément d'une séquence à satisfaire à une condition ou une valeur par défaut si aucun élément correspondant n'est trouvé.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> est vide ou si aucun élément ne réussit le test de la fonction de prédicat, sinon dernier élément de <paramref name="source" /> qui réussit le test de cette fonction.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> depuis lequel renvoyer un élément.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie un <see cref="T:System.Int64" /> représentant le nombre total d'éléments dans une séquence.</summary>
      <returns>Nombre d'éléments de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments à compter.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie un <see cref="T:System.Int64" /> représentant le nombre d'éléments dans une séquence qui satisfont à une condition.</summary>
      <returns>Nombre d'éléments de <paramref name="source" /> qui satisfont à la condition définie dans la fonction de prédicat.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments à compter.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.OverflowException">Le nombre d’éléments dépasse <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie la valeur maximale dans un <see cref="T:System.Linq.IQueryable`1" /> générique.</summary>
      <returns>Valeur maximale dans la séquence.</returns>
      <param name="source">Séquence de valeurs dans laquelle rechercher la valeur maximale.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Appelle une fonction de projection sur chaque élément d'un <see cref="T:System.Linq.IQueryable`1" /> générique et renvoie la valeur résultante maximale.</summary>
      <returns>Valeur maximale dans la séquence.</returns>
      <param name="source">Séquence de valeurs dans laquelle rechercher la valeur maximale.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie la valeur minimale d'un <see cref="T:System.Linq.IQueryable`1" /> générique.</summary>
      <returns>Valeur minimale dans la séquence.</returns>
      <param name="source">Séquence de valeurs dans laquelle rechercher la valeur minimale.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Appelle une fonction de projection sur chaque élément d'un <see cref="T:System.Linq.IQueryable`1" /> générique et renvoie la valeur résultante minimale.</summary>
      <returns>Valeur minimale dans la séquence.</returns>
      <param name="source">Séquence de valeurs dans laquelle rechercher la valeur minimale.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)">
      <summary>Filtre les éléments d'un <see cref="T:System.Linq.IQueryable" /> en fonction du type spécifié.</summary>
      <returns>Collection contenant les éléments de <paramref name="source" /> qui ont le type <paramref name="TResult" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable" /> dont les éléments doivent être filtrés.</param>
      <typeparam name="TResult">Type en fonction duquel filtrer les éléments de la séquence.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Trie les éléments d'une séquence dans l'ordre croissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre croissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Trie les éléments d'une séquence dans l'ordre décroissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Trie les éléments d'une séquence dans l'ordre décroissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">Séquence de valeurs à classer.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé d'un élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})">
      <summary>Inverse l'ordre des éléments dans une séquence.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments correspondent à ceux de la séquence d'entrée dans l'ordre inverse.</returns>
      <param name="source">Séquence de valeurs à inverser.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Projette chaque élément d'une séquence dans un nouveau formulaire.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel d'une fonction de projection sur chaque élément de <paramref name="source" />.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})">
      <summary>Projette chaque élément d'une séquence dans un nouveau formulaire en incorporant l'index de l'élément.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel d'une fonction de projection sur chaque élément de <paramref name="source" />.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type de la valeur renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et appelle une fonction du sélecteur de résultat sur chaque élément obtenu.Les valeurs résultantes de chaque séquence intermédiaire sont combinées en une séquence unique, unidimensionnelle et renvoyées.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel de la fonction de projection un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" />, puis du mappage de chacun de ces éléments de séquence et de leur élément <paramref name="source" /> correspondant en un élément de résultat.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="collectionSelector">Fonction de projection à appliquer à chaque élément de la séquence d'entrée.</param>
      <param name="resultSelector">Fonction de projection à appliquer à chaque élément de chaque séquence intermédiaire.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Type des éléments intermédiaires rassemblé par la fonction représentée par <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et combine les séquences résultantes en une séquence.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel d'une fonction de projection d'un-à-plusieurs sur chaque élément de la séquence d'entrée.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Projette chaque élément d'une séquence en un <see cref="T:System.Collections.Generic.IEnumerable`1" /> qui incorpore l'index de l'élément source qui l'a produit.Une fonction de sélecteur du résultat est appelée sur chaque élément de chaque séquence intermédiaire, et les valeurs résultantes sont combinées en une séquence unique, unidimensionnelle et renvoyées.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel de la fonction de projection un-à-plusieurs <paramref name="collectionSelector" /> sur chaque élément de <paramref name="source" />, puis du mappage de chacun de ces éléments de séquence et de leur élément <paramref name="source" /> correspondant en un élément de résultat.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="collectionSelector">Fonction de projection à appliquer à chaque élément de la séquence d'entrée ; le deuxième paramètre de cette fonction représente l'index de l'élément source.</param>
      <param name="resultSelector">Fonction de projection à appliquer à chaque élément de chaque séquence intermédiaire.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Type des éléments intermédiaires rassemblé par la fonction représentée par <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>Projette chaque élément d'une séquence sur un <see cref="T:System.Collections.Generic.IEnumerable`1" /> et combine les séquences résultantes en une séquence.L'index de chaque élément source est utilisé dans le formulaire projeté de l'élément.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont le résultat de l'appel d'une fonction de projection d'un-à-plusieurs sur chaque élément de la séquence d'entrée.</returns>
      <param name="source">Séquence de valeurs à projeter.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément ; le deuxième paramètre de cette fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence renvoyée par la fonction représentée par <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Détermine si deux séquences sont égales à l'aide du comparateur d'égalité par défaut pour comparer des éléments.</summary>
      <returns>La valeur est true si les deux séquences sources sont de longueur égale et que leurs éléments correspondants sont égaux, sinon false.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont à comparer à ceux de <paramref name="source2" />.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont à comparer à ceux de la première séquence.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Détermine si deux séquences sont égales à l'aide d'un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié pour comparer des éléments.</summary>
      <returns>La valeur est true si les deux séquences sources sont de longueur égale et que leurs éléments correspondants sont égaux, sinon false.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> dont les éléments sont à comparer à ceux de <paramref name="source2" />.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> dont les éléments sont à comparer à ceux de la première séquence.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> à utiliser pour comparer les éléments.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie l'élément unique d'une séquence ou lève une exception si cette séquence ne contient pas un seul élément.</summary>
      <returns>Seul élément de la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> a plusieurs éléments.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie le seul élément d'une séquence qui satisfait à une condition spécifique ou lève une exception si cette séquence contient plusieurs éléments respectant cette condition.</summary>
      <returns>L'élément unique de la séquence d'entrée qui satisfait à la condition dans <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> duquel renvoyer le seul élément.</param>
      <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun élément ne satisfait à la condition dans <paramref name="predicate" />.– ou –Plusieurs éléments satisfont à la condition dans <paramref name="predicate" />.– ou –La séquence source est vide.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Renvoie l'élément unique d'une séquence ou une valeur par défaut. Cette méthode lève une exception si cette séquence contient plusieurs éléments.</summary>
      <returns>Élément unique de la séquence d'entrée ou default(<paramref name="TSource" />) si la séquence ne contient aucun élément.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer le dernier élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie l'élément unique d'une séquence ou une valeur par défaut si cette séquence ne contient pas d'élément respectant cette condition. Cette méthode lève une exception si cette séquence contient plusieurs éléments satisfaisant à cette condition.</summary>
      <returns>Seul élément de la séquence d'entrée qui satisfait à la condition dans <paramref name="predicate" /> ou default(<paramref name="TSource" />) si cet élément n'est pas trouvé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> duquel renvoyer le seul élément.</param>
      <param name="predicate">Fonction permettant de tester un élément pour une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Ignore un nombre spécifié d'éléments dans une séquence, puis renvoie les éléments restants.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments se trouvant après l'index spécifié dans la séquence d'entrée.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="count">Nombre d'éléments à ignorer avant de renvoyer les éléments restants.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Ignore des éléments dans une séquence tant que la condition spécifiée a la valeur true, puis renvoie les éléments restants.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de <paramref name="source" />, en commençant par le premier élément de la série linéaire qui ne réussit pas le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Ignore des éléments dans une séquence tant que la condition spécifiée a la valeur true, puis renvoie les éléments restants.L'index de l'élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> qui contient des éléments de <paramref name="source" />, en commençant par le premier élément de la série linéaire qui ne réussit pas le test spécifié par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à partir duquel renvoyer des éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément source par rapport à une condition ; le deuxième paramètre de cette fonction représente l'index de l'élément source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Decimal" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Decimal" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Double" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Double" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int32" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int32" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Int64" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Int64" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" /> Nullable.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> Nullable dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})">
      <summary>Calcule la somme d'une séquence de valeurs <see cref="T:System.Single" />.</summary>
      <returns>Somme des valeurs de la séquence.</returns>
      <param name="source">Séquence de valeurs <see cref="T:System.Single" /> dont la somme doit être calculée.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Decimal" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Double" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Int32" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Int64" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Decimal" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Double" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Int32" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Int64" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
      <exception cref="T:System.OverflowException">La somme est supérieure à <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Single" /> Nullable obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Calcule la somme de la séquence de valeurs <see cref="T:System.Single" /> obtenue en appelant une fonction de projection sur chaque élément de la séquence d'entrée.</summary>
      <returns>Somme des valeurs projetées.</returns>
      <param name="source">Séquence de valeurs de type <paramref name="TSource" />.</param>
      <param name="selector">Fonction de projection à appliquer à chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="selector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Renvoie un nombre spécifié d'éléments contigus à partir du début d'une séquence.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant le nombre spécifié d'éléments à partir du début de <paramref name="source" />.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="count">Nombre d'éléments à renvoyer.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Renvoie des éléments d'une séquence tant que la condition spécifiée a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments de la séquence d'entrée placés avant l'élément à partir duquel le test spécifié par <paramref name="predicate" /> ne réussit plus.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Renvoie des éléments d'une séquence tant que la condition spécifiée a la valeur true.L'index de l'élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments de la séquence d'entrée placés avant l'élément à partir duquel le test spécifié par <paramref name="predicate" /> ne réussit plus.</returns>
      <param name="source">Séquence à partir de laquelle renvoyer les éléments.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition ; le deuxième paramètre de la fonction représente l'index de l'élément dans la séquence source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre croissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre croissant à l'aide d'un comparateur spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés d'après une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre décroissant selon une clé.</summary>
      <returns>
        <see cref="T:System.Linq.IOrderedQueryable`1" /> dont les éléments sont triés dans l'ordre décroissant selon une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> qui contient les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction représentée par <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="keySelector" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Réalise un classement des éléments d'une séquence dans l'ordre décroissant à l'aide d'un comparateur spécifié.</summary>
      <returns>Collection dont les éléments sont triés par ordre décroissant selon une clé.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> contenant les éléments à trier.</param>
      <param name="keySelector">Fonction permettant d'extraire une clé de chaque élément.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> pour comparer les clés.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Type de la clé renvoyée par la fonction <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="comparer" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Produit l'union de deux séquences à l'aide du comparateur d'égalité par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> qui contient les éléments des deux séquences d'entrée, à l'exception des éléments en double.</returns>
      <param name="source1">Séquence dont les éléments distincts forment le premier jeu pour l'opération d'union.</param>
      <param name="source2">Séquence dont les éléments distincts forment le second jeu pour l'opération d'union.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Produit l'union de deux séquences à l'aide d'un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments des deux séquences d'entrée, à l'exception des éléments en double.</returns>
      <param name="source1">Séquence dont les éléments distincts forment le premier jeu pour l'opération d'union.</param>
      <param name="source2">Séquence dont les éléments distincts forment le second jeu pour l'opération d'union.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> pour comparer les valeurs.</param>
      <typeparam name="TSource">Type des éléments des séquences d'entrée.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Filtre une séquence de valeurs selon un prédicat.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments de la séquence d'entrée qui satisfont à la condition spécifiée par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à filtrer.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Filtre une séquence de valeurs selon un prédicat.L'index de chaque élément est utilisé dans la logique de la fonction de prédicat.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments de la séquence d'entrée qui satisfont à la condition spécifiée par <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> à filtrer.</param>
      <param name="predicate">Fonction permettant de tester chaque élément par rapport à une condition ; le deuxième paramètre de la fonction représente l'index de l'élément dans la séquence source.</param>
      <typeparam name="TSource">Type des éléments de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> ou <paramref name="predicate" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Fusionne deux séquences en utilisant la fonction de prédicat spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> contenant les éléments fusionnés des deux séquences d'entrée.</returns>
      <param name="source1">Première séquence à fusionner.</param>
      <param name="source2">Deuxième séquence à fusionner.</param>
      <param name="resultSelector">Fonction qui spécifie comment fusionner les éléments des deux séquences.</param>
      <typeparam name="TFirst">Type des éléments de la première séquence d'entrée.</typeparam>
      <typeparam name="TSecond">Type des éléments de la deuxième séquence d'entrée.</typeparam>
      <typeparam name="TResult">Type des éléments de la séquence résultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> ou <paramref name="source2 " /> est null.</exception>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Représente une expression comportant un opérateur binaire.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtient une valeur indiquant si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>La valeur est True si le nœud d'arborescence de l'expression peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtient la fonction de conversion de type utilisée par une opération de fusion ou d'assignation composée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> représentant une fonction de conversion de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtient une valeur indiquant si le nœud d'arborescence d'expression représente un appel lifted vers un opérateur.</summary>
      <returns>La valeur est true si le nœud représente un appel levé, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur indiquant si le nœud d'arborescence d'expression représente un appel lifted vers un opérateur dont le type de renvoi est levé vers un type Nullable.</summary>
      <returns>La valeur est true si le type de renvoi de l'opérateur est levé vers un type nullable, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtient l'opérande gauche de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande gauche de l'opération binaire.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtient l'opérande droit de l'opération binaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande droit de l'opération binaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="left">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> du résultat. </param>
      <param name="conversion">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> du résultat.</param>
      <param name="right">Propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Représente un bloc contenant une séquence d'expressions où les variables peuvent être définies.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtient les expressions contenues dans ce bloc.</summary>
      <returns>Collection en lecture seule contenant toutes les expressions contenues dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtient la dernière expression contenue dans ce bloc.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant la dernière expression contenue dans ce bloc.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> du résultat. </param>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtient les variables définies dans ce bloc.</summary>
      <returns>Collection en lecture seule contenant toutes les variables définies dans ce bloc.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Représente une instruction catch dans un bloc try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtient le corps du bloc catch.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtient le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du filtre <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtient le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de <see cref="T:System.Exception" /> que ce gestionnaire intercepte.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Renvoie un <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="variable">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> du résultat.</param>
      <param name="filter">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtient une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Représente une expression comportant un opérateur conditionnel.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtient l'expression à exécuter si le test a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'expression à exécuter si le test a la valeur false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtient l'expression à exécuter si le test a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'expression à exécuter si le test a la valeur true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtient le test de l'opération conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le test de l'opération conditionnelle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, cette expression est renvoyée</summary>
      <returns>Cette expression si aucun enfant n'est modifié ou une expression avec les enfants mis à jour.</returns>
      <param name="test">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> du résultat.</param>
      <param name="ifTrue">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> du résultat.</param>
      <param name="ifFalse">Propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Représente une expression ayant une valeur de constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtient la valeur de l'expression constante.</summary>
      <returns>
        <see cref="T:System.Object" /> égal à la valeur de l'expression représentée.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Émet ou efface un point de séquence pour les informations de débogage.Cela permet au débogueur de mettre en surbrillance le code source correct lors du débogage.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> représentant le fichier source.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> représentant le fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtient la colonne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtient la ligne de fin de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de fin du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtient la valeur qui indique si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence.</summary>
      <returns>La valeur est true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> a pour but d'effacer un point de séquence, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtient la colonne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la colonne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtient la ligne de début de ce <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Numéro de la ligne de début du code qui a été utilisé pour générer l'expression incluse dans un wrapper.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Représente la valeur par défaut d'un type ou une expression vide.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Représente une opération dynamique.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Obtient les arguments pour l'opération dynamique.</summary>
      <returns>Collections en lecture seule contenant les arguments de l'opération dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Obtient le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l'exécution du site dynamique.</summary>
      <returns>Obtient le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, qui détermine le comportement au moment de l'exécution du site dynamique.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Obtient le type de délégué utilisé par <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de délégué utilisé par <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="returnType">Type de résultat de l'expression dynamique.</param>
      <param name="arguments">Arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arguments">Arguments de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et un argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arg0">Argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni et quatre arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arg0">Premier argument de l'opération dynamique.</param>
      <param name="arg1">Deuxième argument de l'opération dynamique.</param>
      <param name="arg2">Troisième argument de l'opération dynamique.</param>
      <param name="arg3">Quatrième argument de l'opération dynamique.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DynamicExpression" /> représentant une opération dynamique liée par le <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> fourni.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> et dont les propriétés <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> et <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">Type du délégué utilisé par l'objet <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Binder d'exécution de l'opération dynamique.</param>
      <param name="arguments">Arguments de l'opération dynamique.</param>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Compare la valeur envoyée au paramètre (arguments) à la propriété Arguments de l'instance actuelle de DynamicExpression.Si les valeurs du paramètre et de la propriété sont identiques, l'instance actuelle est renvoyée.Si elles sont différentes, une nouvelle instance DynamicExpression est renvoyée. Celle-ci est identique à l'instance actuelle. La seule différence est que la propriété Arguments est définie sur la valeur du paramètre arguments.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Représente un visiteur ou un module de réécriture pour les arborescences d'expression dynamique.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <returns>Renvoie <see cref="T:System.Linq.Expressions.Expression" />, l'expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Représente un initialiseur pour un élément unique d'une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtient la méthode d'instance utilisée pour ajouter un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'instance qui ajoute un élément à une collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtient la collection d'arguments passés à une méthode qui ajoute un élément à une collection <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments d'une méthode qui ajoute un élément à une collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Renvoie une représentation textuelle d'un objet <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Représentation textuelle de l'objet <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Fournit la classe de base dont les classes représentant des nœuds d'arborescence d'expression sont dérivées.Il contient également des méthodes de fabrique static (Shared en Visual Basic) pour créer les divers types de nœuds.Il s'agit d'une classe abstraite.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Construit une nouvelle instance de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> à définir comme type de nœud.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de cette <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'addition arithmétique ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur d’addition n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'addition arithmétique ne comportant pas de vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur d’addition n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation d'addition comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'addition arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur d’addition n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'addition arithmétique comportant une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur d’addition n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de bits AND n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération AND au niveau du bit.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.And" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de bits AND n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première a la valeur true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de bits AND n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération AND conditionnelle évaluant la deuxième opérande uniquement si la première a la valeur true.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de bits AND n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation AND au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau multidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="array">Expression représentant le tableau multidimensionnel.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> pour accéder à un tableau.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="array">Expression représentant le tableau à indexer.</param>
      <param name="indexes">Tableau contenant des expressions utilisées pour indexer le tableau.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant l'application d'un opérateur index de tableau à un tableau de rang supérieur à un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale.</param>
      <param name="indexes">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.– ou –Le rang de <paramref name="array" />.Type ne correspond pas au nombre d’éléments dans <paramref name="indexes" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'application d'un opérateur index de tableau à un tableau de rang un.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="index">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="index" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.– ou –<paramref name="array" />.Type représente un type de tableau dont le rang n’est pas 1.– ou –<paramref name="index" />.Type ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant l'application d'un opérateur d'index de tableau à un tableau multidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="array">Tableau d'instances <see cref="T:System.Linq.Expressions.Expression" />, index pour l'opération d'indexation de tableau.</param>
      <param name="indexes">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> ou <paramref name="indexes" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.– ou –Le rang de <paramref name="array" />.Type ne correspond pas au nombre d’éléments dans <paramref name="indexes" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="indexes" /> ne représente pas le type <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une expression permettant d'obtenir la longueur d'un tableau unidimensionnel.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> et la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> est égale à <paramref name="array" />.</returns>
      <param name="array">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type ne représente pas un type de tableau.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberAssignment" /> représentant l'initialisation d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont le <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égal à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> et les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.– ou –La propriété représentée par <paramref name="member" /> n’a pas d’accesseur set.– ou –<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberAssignment" /> représentant l'initialisation d'un membre à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur le <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />, et dont la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> a la valeur <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d’accesseur de propriété.– ou –La propriété accédée par <paramref name="propertyAccessor" /> n’a pas d’accesseur set.– ou –<paramref name="expression" />.Type ne peut pas être assigné au type du champ ou de la propriété que <paramref name="member" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant les expressions données et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant variables et expressions données.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant variables et expressions données.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant deux expressions et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant trois expressions et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant quatre expressions et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant cinq expressions et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="arg0">Première expression contenue dans le bloc.</param>
      <param name="arg1">Deuxième expression contenue dans le bloc.</param>
      <param name="arg2">Troisième expression contenue dans le bloc.</param>
      <param name="arg3">Quatrième expression contenue dans le bloc.</param>
      <param name="arg4">Cinquième expression contenue dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant les expressions données et aucune variable.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant les expressions données, aucune variable et un type de résultat spécifique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant variables et expressions données.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant variables et expressions données.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="variables">Variables contenues dans le bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BlockExpression" /> contenant les expressions données, aucune variable et un type de résultat spécifique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BlockExpression" /> créée.</returns>
      <param name="type">Type de résultat du bloc.</param>
      <param name="expressions">Expressions contenues dans le bloc.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction break.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction break avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction break avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode d'instance ne prenant pas d'argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> spécifiant l'instance d'un appel de méthode d'instance (passer null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.– ou –<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode prenant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> doit être égale (passer null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.– ou –<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d’instance.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.– ou –Le nombre d’éléments dans <paramref name="arguments" /> n’est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.– ou –Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static prenant deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> spécifiant l'instance d'un appel d'instance.(Passer la valeur null pour une méthode static (Shared en Visual Basic).)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode ne prenant aucun argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> spécifiant l'instance d'un appel d'instance.(Passer la valeur null pour une méthode static (Shared en Visual Basic).)</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode cible.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le troisième argument.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode prenant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> spécifiant l'instance d'un appel de méthode d'instance (passer null pour une méthode static (Shared en Visual Basic)).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.– ou –<paramref name="instance" /> est null et <paramref name="method" /> représente une méthode d’instance.– ou –<paramref name="arguments" /> n’est pas null et un ou plusieurs de ses éléments sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="method" />.– ou –Le nombre d’éléments dans <paramref name="arguments" /> n’est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.– ou –Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode d'instance en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> est égale à <paramref name="instance" />, dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'instance spécifiée, et dont <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> dont la valeur de propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> fera l'objet d'une recherche pour une méthode spécifique.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit avoir la valeur null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> ou <paramref name="methodName" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n’est trouvée dans <paramref name="instance" />.Type ou ses types de base.– ou –La recherche a trouvé plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> dans <paramref name="instance" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static (Shared en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode cible.</param>
      <param name="arguments">Collection de <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments d'appel.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static (Shared en Visual Basic) prenant un argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static prenant deux arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static prenant trois arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le troisième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static prenant quatre arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le quatrième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static prenant cinq arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arg0">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le premier argument.</param>
      <param name="arg1">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le deuxième argument.</param>
      <param name="arg2">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le troisième argument.</param>
      <param name="arg3">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le quatrième argument.</param>
      <param name="arg4">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le cinquième argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static (Shared en Visual Basic) comportant des arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> et <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode static (Shared en Visual Basic) à laquelle la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le nombre d’éléments dans <paramref name="arguments" /> n’est pas égal au nombre de paramètres pour la méthode représentée par <paramref name="method" />.– ou –Un ou plusieurs des éléments de <paramref name="arguments" /> ne peuvent pas être assignés au paramètre correspondant pour la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MethodCallExpression" /> représentant un appel à une méthode static (Shared en Visual Basic) en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> a pour valeur <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode static (Shared en Visual Basic) spécifiée, et dont la propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> a pour valeur les arguments spécifiés.</returns>
      <param name="type">
        <see cref="T:System.Type" /> spécifiant le type contenant la méthode static (Shared en Visual Basic) spécifiée.</param>
      <param name="methodName">Nom de la méthode.</param>
      <param name="typeArguments">Tableau d'objets <see cref="T:System.Type" /> spécifiant les paramètres de type de la méthode générique.Cet argument doit avoir la valeur null lorsque methodName spécifie une méthode non générique.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="methodName" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode appelée <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> n’est trouvée dans <paramref name="type" />.Type ou ses types de base.– ou –La recherche a trouvé plusieurs méthodes appelées <paramref name="methodName" />, dont les paramètres de type correspondent à <paramref name="typeArguments" /> et dont les types de paramètres correspondent à <paramref name="arguments" /> dans <paramref name="type" />.Type ou ses types de base.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indique que le nœud peut être réduit à un nœud plus simple.Si la valeur renvoyée est true, Reduce() peut être appelé pour produire la forme réduite.</summary>
      <returns>La valeur est true si le nœud peut être réduit, sinon false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction catch avec une référence à l'objet <see cref="T:System.Exception" /> intercepté pour une utilisation dans le corps du gestionnaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction catch avec un filtre <see cref="T:System.Exception" /> et une référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction catch.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'<see cref="T:System.Exception" /> que ce <see cref="T:System.Linq.Expressions.CatchBlock" /> gèrera.</param>
      <param name="body">Corps de l'instruction catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction catch avec un filtre <see cref="T:System.Exception" /> mais aucune référence à l'objet <see cref="T:System.Exception" /> intercepté.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'<see cref="T:System.Exception" /> que ce <see cref="T:System.Linq.Expressions.CatchBlock" /> gèrera.</param>
      <param name="body">Corps de l'instruction catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour la suppression d'un point de séquence.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> pour le nettoyage d'un point de séquence.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> représentant le fichier source.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de fusion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de fusion, à partir d'une fonction de conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type ne peut pas être converti en <paramref name="right" />.Type, et inversement.– ou –<paramref name="conversion" /> n’est pas null et <paramref name="conversion" />.Type est un type délégué qui ne prend pas exactement un argument.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> ne représente pas un type référence ou un type valeur Nullable.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> représente un type qui ne peut pas être assigné au type de paramètre du type délégué <paramref name="conversion" />.Type.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> n’est pas égale au type de retour du type délégué <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConditionalExpression" /> représentant une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" />, <paramref name="ifTrue" /> ou <paramref name="ifFalse" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type n’est pas <see cref="T:System.Boolean" />.– ou –<paramref name="ifTrue" />.Type n’est pas égal à <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConditionalExpression" /> représentant une instruction conditionnelle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> a la valeur spécifiée.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="value">
        <see cref="T:System.Object" /> auquel la propriété <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> n’est pas null et <paramref name="type" /> ne peut pas être assigné à partir du type dynamique de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à break, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction continue avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de conversion de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> à auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n’est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de conversion pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n’est défini entre <paramref name="expression" />.Type et <paramref name="type" />.– ou –<paramref name="expression" />.Type ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.– ou –Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.– ou –<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n’est pas égal au type d’argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de conversion levant une exception en cas de dépassement du type cible.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n’est défini entre <paramref name="expression" />.Type et <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de conversion levant une exception en cas de dépassement du type cible et pour laquelle la méthode d'implémentation est spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">Aucun opérateur de conversion n’est défini entre <paramref name="expression" />.Type et <paramref name="type" />.– ou –<paramref name="expression" />.Type ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.– ou –Le type de retour de la méthode représentée par <paramref name="method" /> ne peut pas être assigné à <paramref name="type" />.– ou –<paramref name="expression" />.Type ou <paramref name="type" /> est un type valeur Nullable et le type valeur autre que Nullable correspondant n’est pas égal au type d’argument ou au type de retour, respectivement, de la méthode représentée par <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondant à la description <paramref name="method" /> ont été trouvées.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> avec l'étendue spécifiée.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> représentant le fichier source.</param>
      <param name="startLine">Ligne de début de cette <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="startColumn">Colonne de début de cette <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure à 0.</param>
      <param name="endLine">Ligne de fin de cette <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Doit être supérieure ou égale à la ligne de début.</param>
      <param name="endColumn">Colonne de fin de cette <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la ligne de fin est la même que la ligne de début, elle doit être supérieure ou égale à la colonne de début.Dans tous les cas, elle doit être supérieure à 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant la décrémentation de 1 de l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant la décrémentation de 1 de l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression décrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à décrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et dont la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> a le type spécifié.</returns>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de division arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle affecter la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle affecter la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de division n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de division arithmétique.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de division n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de division ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de division ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de division ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" />, à partir d'un <see cref="T:System.Collections.Generic.IEnumerable`1" /> comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> auxquels la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par <paramref name="addMethod" /> n’est pas nommée "Add" (non respect de la casse).– ou –La méthode représentée par <paramref name="addMethod" /> n’est pas une méthode d’instance.– ou –<paramref name="arguments" /> ne contient pas le même nombre d’éléments que le nombre de paramètres pour la méthode représentée par <paramref name="addMethod" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée un <see cref="T:System.Linq.Expressions.ElementInit" /> à partir d'un tableau de valeurs comme deuxième argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> dont les propriétés <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> et <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> auquel la propriété <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> ou <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La méthode représentée par addMethod n'est pas nommée "Add" (non respect de la casse).– ou –La méthode représentée par addMethod n'est pas une méthode d'instance.– ou –arguments ne contient pas le même nombre d'éléments que le nombre de paramètres pour la méthode représentée par addMethod.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant de la méthode représentée par <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crée une expression vide du type <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> et la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> est a la valeur <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'égalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur d’égalité n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'égalité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur d’égalité n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur XOR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur XOR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation XOR au niveau du bit, en utilisant op_ExclusiveOr pour les types définis par l'utilisateur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Pour static (Shared en Visual Basic), <paramref name="expression" /> doit avoir la valeur null.</param>
      <param name="field">
        <see cref="T:System.Reflection.FieldInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> a la valeur null.– ou –Le champ représenté par <paramref name="field" /> n’est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration du champ représenté par <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à un champ à partir du nom du champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur <see cref="T:System.Reflection.FieldInfo" /> représentant le champ désigné par <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient un champ nommé <paramref name="fieldName" />.Cette valeur peut être null pour les champs statiques.</param>
      <param name="fieldName">Nom d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="fieldName" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Aucun champ nommé <paramref name="fieldName" /> n’est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> créée.</returns>
      <param name="expression">Objet conteneur du champ.Cette valeur peut être null pour les champs statiques.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> contenant le champ.</param>
      <param name="fieldName">Champ auquel accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crée un objet <see cref="T:System.Type" /> représentant un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>Type d'un délégué System.Action possédant les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau d'objets <see cref="T:System.Type" /> spécifiant les arguments de type pour le type délégué System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient plus de quatre éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtient un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant un type délégué System.Func ou System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>Type délégué.</returns>
      <param name="typeArgs">Arguments de type du délégué.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>Type d'un délégué System.Func possédant les arguments de type spécifiés.</returns>
      <param name="typeArgs">Tableau d'un à cinq objets <see cref="T:System.Type" /> spécifiant les arguments de type pour le type délégué System.Func.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contient moins d’un élément ou plus de cinq éléments.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction GoTo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction GoTo.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction GoTo avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à Goto, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction GoTo avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à GoTo, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à la valeur spécifiée, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à la valeur <paramref name="type" />, et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « supérieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur « supérieur à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « supérieur à ».La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur « supérieur à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur « supérieur ou égal à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « supérieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur « supérieur ou égal à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConditionalExpression" /> représentant un bloc conditionnel avec une instruction if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> ont les valeurs spécifiées.La propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> a pour valeur l'expression par défaut, et dont le type d'<see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultante renvoyée par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ConditionalExpression" /> représentant un bloc conditionnel avec des instructions if et else.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> et <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> ont les valeurs spécifiées.Le type de l'<see cref="T:System.Linq.Expressions.ConditionalExpression" /> résultante renvoyée par cette méthode est <see cref="T:System.Void" />.</returns>
      <param name="test">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> doit être égale.</param>
      <param name="ifTrue">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> doit être égale.</param>
      <param name="ifFalse">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'incrémentation de 1 de l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'incrémentation de 1 de l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression incrémentée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à incrémenter.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.InvocationExpression" /> appliquant un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> appliquant le délégué ou l'expression lambda spécifié aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le délégué ou l'expression lambda à appliquer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels l'expression lambda ou le délégué est appliqué.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.InvocationExpression" /> appliquant un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.InvocationExpression" /> appliquant le délégué ou l'expression lambda spécifié aux arguments fournis.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le délégué ou l'expression lambda à appliquer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels l'expression lambda ou le délégué est appliqué.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne représente pas un type délégué ou un <see cref="T:System.Linq.Expressions.Expression`1" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant du délégué représenté par <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour le délégué représenté par <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur false.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Indique si l'expression prend la valeur true.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à évaluer.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et aucun nom.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et aucun nom.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelExpression" /> représentant une étiquette sans valeur par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sans valeur par défaut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> à laquelle cette <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associée.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelExpression" /> représentant une étiquette avec la valeur par défaut donnée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> avec la valeur par défaut donnée.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> à laquelle cette <see cref="T:System.Linq.Expressions.LabelExpression" /> sera associée.</param>
      <param name="defaultValue">Valeur de ce <see cref="T:System.Linq.Expressions.LabelExpression" /> quand l'étiquette est atteinte via un flux de contrôle normal.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type void et le nom donné.</returns>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type donné.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type et le nom donnés.</summary>
      <returns>Nouvelle <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette avec le type et le nom donnés.</returns>
      <param name="type">Type de valeur passée lors de l'accès à l'étiquette.</param>
      <param name="name">Nom de l'étiquette.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> est égale à <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression`1.Body" /> et <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> est égale à <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression`1.Body" /> et <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">Tableau contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">Tableau contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.– ou –Un ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n’est pas un type délégué.– ou –<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.– ou –<paramref name="parameters" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour <paramref name="TDelegate" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.– ou –Un ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> n’est pas un type délégué.– ou –<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour de <paramref name="TDelegate" />.– ou –<paramref name="parameters" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour <paramref name="TDelegate" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> a la valeur null.– ou –Un ou plusieurs éléments de <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contient plus de seize éléments.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> est égale à <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression`1.Body" /> et <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération d'informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission d'informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission d'informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.Expression`1" /> dans laquelle le type délégué est connu au moment de la compilation.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression`1" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> est égale à <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression`1.Body" /> et <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.Expression`1.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour la génération d'informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Type délégué. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée.</param>
      <param name="parameters">Tableau contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet représentant une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> représentant une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> est null.– ou –Un ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.– ou –<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.– ou –<paramref name="parameters" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LambdaExpression" /> en commençant par construire un type délégué.Peut être utilisé lorsque le type délégué n'est pas connu au moment de la compilation.</summary>
      <returns>Objet représentant une expression lambda dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="T:System.Type" /> représentant une signature de délégué pour l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="parameters">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> ou <paramref name="body" /> est null.– ou –Un ou plusieurs éléments dans <paramref name="parameters" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> ne représente pas un type délégué.– ou –<paramref name="body" />.Type représente un type qui ne peut pas être assigné au type de retour du type délégué représenté par <paramref name="delegateType" />.– ou –<paramref name="parameters" /> ne contient pas le même nombre d’éléments que la liste de paramètres pour le type délégué représenté par <paramref name="delegateType" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="parameters" /> ne peut pas être assignée à partir du type du paramètre correspondant du type délégué représenté par <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale. </param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission d'informations de débogage.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> indiquant si l'optimisation d'appel tail sera appliquée lors de la compilation de l'expression créée. </param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée un LambdaExpression en commençant par construire un type délégué.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> est égale à Lambda et dont les propriétés <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> et <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> ont les valeurs spécifiées.</returns>
      <param name="delegateType">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant la signature du délégué de l'expression lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> doit être égale.</param>
      <param name="name">Nom de l'expression lambda.Utilisé pour l'émission d'informations de débogage.</param>
      <param name="parameters">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de décalage vers la gauche n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de décalage vers la gauche n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la gauche.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur « inférieur à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « inférieur à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur « inférieur à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur « inférieur ou égal à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison numérique « inférieur ou égal à ».</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur « inférieur ou égal à » n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans laquelle le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> représentant un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> est null. – ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.– ou –Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberListBinding" /> dans laquelle le membre est un champ ou une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> représentant un champ ou une propriété auquel la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> est null. – ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.– ou –Le <see cref="P:System.Reflection.FieldInfo.FieldType" /> ou <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> du champ ou de la propriété que <paramref name="member" /> représente n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur <see cref="T:System.Reflection.MemberInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />, et dont les <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sont remplis avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> est null. – ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d’accesseur de propriété.– ou –Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.MemberListBinding" /> basé sur une méthode d'accesseur de propriété spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur <see cref="T:System.Reflection.MemberInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />, et dont les <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> sont remplis avec les éléments de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> est null. – ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d’accesseur de propriété.– ou –Le <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" /> n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d’instance nommée "Add" (non respect de la casse) n’est déclarée dans <paramref name="newExpression" />.Type ou son type de base.– ou –La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.– ou –Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.– ou –Il existe plusieurs méthodes compatibles à l’argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant des objets <see cref="T:System.Linq.Expressions.ElementInit" /> spécifiés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant une méthode nommée « Add » pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">Aucune méthode d’instance nommée "Add" (non respect de la casse) n’est déclarée dans <paramref name="newExpression" />.Type ou son type de base.– ou –La méthode add sur <paramref name="newExpression" />.Type ou son type de base ne prend pas exactement un argument.– ou –Le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> du premier élément de <paramref name="initializers" /> ne peut pas être assigné au type d’argument de la méthode add sur <paramref name="newExpression" />.Type ou son type de base.– ou –Il existe plusieurs méthodes compatibles à l’argument nommées "Add" (non respect de la casse) sur <paramref name="newExpression" />.Type et/ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'instance nommée « Add » (casse indifférente) ajoutant un élément à une collection.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.– ou –<paramref name="addMethod" /> n’est pas null et ne représente pas une méthode d’instance nommée "Add" (non respect de la casse) qui prend exactement un argument.– ou –<paramref name="addMethod" /> n’est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d’argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n’existe aucune méthode d’instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.ListInitExpression" /> utilisant une méthode spécifiée pour ajouter des éléments à une collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> a la valeur spécifiée.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> doit être égale.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'instance prenant un argument, qui ajoute un élément à une collection.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="initializers" /> est null.– ou –Un ou plusieurs éléments de <paramref name="initializers" /> sont null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type n’implémente pas <see cref="T:System.Collections.IEnumerable" />.– ou –<paramref name="addMethod" /> n’est pas null et ne représente pas une méthode d’instance nommée "Add" (non respect de la casse) qui prend exactement un argument.– ou –<paramref name="addMethod" /> n’est pas null et le type représenté par la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un ou plusieurs éléments de <paramref name="initializers" /> ne peut pas être assigné au type d’argument de la méthode que <paramref name="addMethod" /> représente.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> est null et il n’existe aucune méthode d’instance nommée "Add" prenant un argument compatible avec le type sur <paramref name="newExpression" />.Type ou son type de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LoopExpression" /> créée.</returns>
      <param name="body">Corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps et la cible d'instruction break donnés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LoopExpression" /> créée.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.LoopExpression" /> avec le corps donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LoopExpression" /> créée.</returns>
      <param name="body">Corps de la boucle.</param>
      <param name="break">Cible d'instruction Break utilisée par le corps de la boucle.</param>
      <param name="continue">Cible d'instruction Continue utilisée par le corps de la boucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> à partir des opérandes gauche et droit, en appelant une méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> spécifiant le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande droit.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d’expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" />, avec l'opérande gauche, l'opérande droit et la méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> spécifiant le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande droit.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> spécifiant la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d’expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> avec l'opérande gauche, l'opérande droit, la méthode d'implémentation et la fonction de conversion de type, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="binaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> spécifiant le type d'opération binaire.</param>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" />représentant l'opérande gauche.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande droit.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> spécifiant la méthode d'implémentation.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> représentant une fonction de conversion de type.Ce paramètre est utilisé uniquement si <paramref name="binaryType" /> est un champ <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> ou une assignation composée.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> ne correspond pas à un nœud d’expression binaire.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant une instruction catch avec les éléments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.CatchBlock" /> créé.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de l'<see cref="T:System.Exception" /> que ce <see cref="T:System.Linq.Expressions.CatchBlock" /> gèrera.</param>
      <param name="variable">
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant une référence à l'objet <see cref="T:System.Exception" /> intercepté par ce gestionnaire.</param>
      <param name="body">Corps de l'instruction catch.</param>
      <param name="filter">Corps du filtre <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant un saut du <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> spécifié.La valeur passée à l'étiquette au moment du saut peut également être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à <paramref name="kind" />, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />, et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> de <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> représentant l'accès à une propriété indexée dans un objet.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="instance">Objet auquel la propriété appartient.Doit avoir la valeur null si la propriété est static (Shared en Visual Basic).</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant la propriété à indexer.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) contenant les arguments qui seront utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à un champ ou à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet auquel appartient le membre.Cette valeur peut être null pour les membres statiques.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> décrivant la propriété ou le champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="member" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc try avec les éléments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TryExpression" /> créée.</returns>
      <param name="type">Type de résultat de l'expression try.Si null, le corps et tous les gestionnaires doivent avoir le même type.</param>
      <param name="body">Corps du bloc try.</param>
      <param name="finally">Corps du bloc finally.Passez la valeur null si aucun bloc finally n'est associé au bloc try.</param>
      <param name="fault">Corps du bloc try.Passez la valeur null si aucun bloc fault n'est associé au bloc try.</param>
      <param name="handlers">Collection de <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant les instructions catch à associer au bloc try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> avec une opérande, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> spécifiant le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> spécifiant le type dans lequel convertir (passer la valeur null le cas échéant).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d’expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> avec une opérande et une méthode d'implémentation, en appelant la méthode de fabrique appropriée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> résultant de l'appel de la méthode de fabrique appropriée.</returns>
      <param name="unaryType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> spécifiant le type d'opération unaire.</param>
      <param name="operand">
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande.</param>
      <param name="type">
        <see cref="T:System.Type" /> spécifiant le type dans lequel convertir (passer la valeur null le cas échéant).</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> ne correspond pas à un nœud d’expression unaire.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> représentant l'initialisation récursive de membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.– ou –La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément de <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> représentant l'initialisation récursive de membres d'un champ ou d'une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> et <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> ne représente pas un champ ou une propriété.– ou –La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément <paramref name="bindings" /> ne représente pas un membre du type du champ ou de la propriété représenté par <paramref name="member" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> représentant l'initialisation récursive de membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d’accesseur de propriété.– ou –La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> représentant l'initialisation récursive de membres d'un membre accessible via une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> est égale à <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> a pour valeur <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />, et dont les propriétés <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> ne représente pas une méthode d’accesseur de propriété.– ou –La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément <paramref name="bindings" /> ne représente pas un membre du type de la propriété à laquelle accède la méthode représentée par <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Représente une expression créant un objet et initialisant une propriété de l'objet.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> et <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> ont les valeurs spécifiées.</returns>
      <param name="newExpression">
        <see cref="T:System.Linq.Expressions.NewExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> doit être égale.</param>
      <param name="bindings">Tableau d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> ou <paramref name="bindings" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> d’un élément <paramref name="bindings" /> ne représente pas un membre du type représenté par <paramref name="newExpression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de reste arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur modulo n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de reste arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur modulo n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de reste.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de multiplication arithmétique ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de multiplication n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de multiplication arithmétique ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de multiplication n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de multiplication comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de multiplication arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de multiplication n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de multiplication arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de multiplication n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur moins unaire n’est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de négation arithmétique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur moins unaire n’est pas défini pour <paramref name="expression" />.Type.– ou –<paramref name="expression" />.Type (ou son type non Nullable correspondant s’il s’agit d’un type valeur Nullable) ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de négation arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur moins unaire n’est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de négation arithmétique comportant une vérification de dépassement de capacité.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur moins unaire n’est pas défini pour <paramref name="expression" />.Type.– ou –<paramref name="expression" />.Type (ou son type non Nullable correspondant s’il s’agit d’un type valeur Nullable) ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant un appel du constructeur spécifié ne prenant pas d'argument.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> a la valeur spécifiée.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le constructeur représenté par <paramref name="constructor" /> a au moins un paramètre.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.– ou –Un élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant au constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.– ou –Un élément de <paramref name="arguments" /> est null.– ou –Un élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant au constructeur représenté par <paramref name="constructor" />.– ou –Le paramètre <paramref name="members" /> n’a pas le même nombre d’éléments que le paramètre <paramref name="arguments" />.– ou –Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l’élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel du constructeur spécifié avec les arguments spécifiés.Les membres qui accèdent aux champs initialisés du constructeur sont spécifiés sous forme de tableau.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> et <see cref="P:System.Linq.Expressions.NewExpression.Members" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.– ou –Un élément de <paramref name="arguments" /> est null.– ou –Un élément de <paramref name="members" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le paramètre <paramref name="arguments" /> ne contient pas le même nombre d’éléments que le nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant au constructeur représenté par <paramref name="constructor" />.– ou –Le paramètre <paramref name="members" /> n’a pas le même nombre d’éléments que le paramètre <paramref name="arguments" />.– ou –Un élément du paramètre <paramref name="arguments" /> a une propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> qui représente un type qui ne peut pas être assigné au type du membre représenté par l’élément correspondant du paramètre <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel du constructeur spécifié avec les arguments spécifiés.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et dont les propriétés <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> et <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> ont les valeurs spécifiées.</returns>
      <param name="constructor">
        <see cref="T:System.Reflection.ConstructorInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> doit être égale.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> a la valeur null.– ou –Un élément de <paramref name="arguments" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La longueur du paramètre <paramref name="arguments" /> correspond au nombre de paramètres pour le constructeur représenté par <paramref name="constructor" />.– ou –La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="arguments" /> ne peut pas être assignée au type du paramètre correspondant au constructeur représenté par <paramref name="constructor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel du constructeur sans paramètre du type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.New" /> et la propriété <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> égale à <see cref="T:System.Reflection.ConstructorInfo" /> représentant le constructeur sans paramètre pour le type spécifié.</returns>
      <param name="type">
        <see cref="T:System.Type" /> ayant un constructeur ne prenant pas d'argument.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">Le type représenté par <paramref name="type" /> n’a pas de constructeur sans paramètres.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewArrayExpression" /> représentant la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> représentant le type d'élément du tableau.</param>
      <param name="bounds">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> est null.– ou –Un élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewArrayExpression" /> représentant la création d'un tableau ayant un rang spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> représentant le type d'élément du tableau.</param>
      <param name="bounds">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="bounds" /> est null.– ou –Un élément de <paramref name="bounds" /> est null.</exception>
      <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément de <paramref name="bounds" /> ne représente pas un type intégral.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewArrayExpression" /> représentant la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> représentant le type d'élément du tableau.</param>
      <param name="initializers">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> contenant des objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> est null.– ou –Un élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type représenté par <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.NewArrayExpression" /> représentant la création d'un tableau unidimensionnel et son initialisation à partir d'une liste d'éléments.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> et dont la propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> a la valeur spécifiée.</returns>
      <param name="type">
        <see cref="T:System.Type" /> représentant le type d'élément du tableau.</param>
      <param name="initializers">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> ou <paramref name="initializers" /> est null.– ou –Un élément de <paramref name="initializers" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> d’un élément du paramètre <paramref name="initializers" /> représente un type qui ne peut pas être assigné au type <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtient le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Une des valeurs <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de complément au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur not unaire n’est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération de complément au niveau du bit.La méthode d'implémentation peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur not unaire n’est pas défini pour <paramref name="expression" />.Type.– ou –<paramref name="expression" />.Type (ou son type non Nullable correspondant s’il s’agit d’un type valeur Nullable) ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur d’inégalité n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'inégalité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="liftToNull">La valeur est true pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur true, ou false pour attribuer à <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> la valeur false.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur d’inégalité n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Renvoie l'expression représentant le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Renvoie l'expression représentant le complément à 1.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de bits OR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de bits OR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation OR au niveau du bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de bits OR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération OR conditionnelle évaluant la deuxième opérande uniquement si la première a la valeur false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de bits OR n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="method" /> est null et <paramref name="left" />.Type et <paramref name="right" />.Type ne sont pas du même type booléen.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> pouvant être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> pouvant être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> et dont les propriétés <see cref="P:System.Linq.Expressions.Expression.Type" /> et <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> ont les valeurs spécifiées.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable, utilisé à des fins de débogage ou d'impression uniquement.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'assignation de l'expression suivie d'une décrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'assignation de l'expression suivie d'une incrémentation de 1 de l'expression d'origine.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur d’élévation à la puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'élévation d'un nombre à une puissance.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur d’élévation à la puissance n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.– ou –<paramref name="method" /> est null et <paramref name="left" />.Type et/ou <paramref name="right" />.Type ne sont pas <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant l'élévation d'une expression à une puissance et la réassignation du résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> décrémentant l'expression de 1 et réassignant le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> décrémentant l'expression de 1 et réassignant le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> incrémentant l'expression de 1 et réassignant le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> incrémentant l'expression de 1 et réassignant le résultat à l'expression.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'expression résultante.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer les opérations.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à une propriété à l'aide d'une méthode d'accesseur de propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété accessible dans <paramref name="propertyAccessor" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> représentant une méthode d'accesseur de propriété.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> a la valeur null.– ou –La méthode représentée par <paramref name="propertyAccessor" /> n’est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la méthode représentée par <paramref name="propertyAccessor" />.– ou –La méthode représentée par <paramref name="propertyAccessor" /> n’est pas une méthode d’accesseur de propriété.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> et dont les propriétés <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> et <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> doit être égale.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="property">
        <see cref="T:System.Reflection.PropertyInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> a la valeur null.– ou –La propriété représentée par <paramref name="property" /> n’est pas static (Shared en Visual Basic) et <paramref name="expression" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type ne peut pas être assigné au type de déclaration de la propriété que <paramref name="property" /> représente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> représentant l'accès à une propriété indexée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété à indexer.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> représentant l'accès à une propriété indexée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur null.</param>
      <param name="indexer">
        <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété à indexer.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur <see cref="T:System.Reflection.PropertyInfo" /> représentant la propriété désignée par <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété nommée <paramref name="propertyName" />.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="propertyName">Nom d'une propriété à laquelle accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyName" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Aucune propriété nommée <paramref name="propertyName" /> n’est définie dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.IndexExpression" /> représentant l'accès à une propriété indexée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.IndexExpression" /> créée.</returns>
      <param name="instance">Objet auquel la propriété appartient.Si la propriété est statique/partagée, doit avoir la valeur null.</param>
      <param name="propertyName">Nom de l'indexeur.</param>
      <param name="arguments">Tableau d'objets <see cref="T:System.Linq.Expressions.Expression" /> utilisés pour indexer la propriété.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> accédant à une propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> créée.</returns>
      <param name="expression">Objet contenant la propriété.Cette valeur peut être null pour les propriétés statiques.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> contenant la propriété.</param>
      <param name="propertyName">Propriété à laquelle accéder.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.MemberExpression" /> représentant l'accès à une propriété ou à un champ.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> a pour valeur <paramref name="expression" /> et dont la propriété <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> a pour valeur <see cref="T:System.Reflection.PropertyInfo" /> ou <see cref="T:System.Reflection.FieldInfo" /> représentant la propriété ou le champ désigné par <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> dont <see cref="P:System.Linq.Expressions.Expression.Type" /> contient une propriété ou un champ nommé <paramref name="propertyOrFieldName" />.Cette valeur peut être null pour les membres statiques.</param>
      <param name="propertyOrFieldName">Nom d'une propriété ou d'un champ auquel accéder.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="propertyOrFieldName" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Aucun champ ou propriété nommé <paramref name="propertyOrFieldName" /> n’est défini dans <paramref name="expression" />.Type ou ses types de base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une expression ayant une valeur de constante de type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce renvoie la valeur true, cela doit renvoyer une expression valide.Cette méthode peut renvoyer un autre nœud devant lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Réduit le nœud en une expression plus simple.Si CanReduce renvoie la valeur true, cela doit renvoyer une expression valide.Cette méthode peut renvoyer un autre nœud devant lui-même être réduit.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Réduit l'expression à un type de nœud connu (qui n'est pas un nœud Extension) ou renvoie simplement l'expression s'il s'agit d'un type déjà connu.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'égalité de référence.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une comparaison d'inégalité de référence.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une nouvelle levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une nouvelle levée d'exception.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une nouvelle levée d'exception avec un type donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une nouvelle levée d'exception.</returns>
      <param name="type">Nouveau <see cref="T:System.Type" /> de l'expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction return.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" /> et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction return avec le type spécifié.La valeur passée à l'étiquette au moment du saut peut être spécifiée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à continue, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" />, et une <paramref name="value" /> à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="value">Valeur qui sera passée à l'étiquette associée au moment du saut.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction return avec le type spécifié.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> avec la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> égale à return, la propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> égale à <paramref name="target" />, la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> égale à <paramref name="type" /> et une valeur null à passer à l'étiquette cible au moment du saut.</returns>
      <param name="target">
        <see cref="T:System.Linq.Expressions.LabelTarget" /> vers laquelle <see cref="T:System.Linq.Expressions.GotoExpression" /> sautera.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de décalage vers la droite n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de décalage vers la droite n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de bits de décalage vers la droite.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> est égale à la valeur spécifiée.</returns>
      <param name="variables">Collection d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> et la propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> est égale à la valeur spécifiée.</returns>
      <param name="variables">Tableau d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> à utiliser pour remplir la collection <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de soustraction arithmétique ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de soustraction arithmétique ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction ne comportant pas de vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération d'assignation de soustraction comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <param name="conversion">
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de soustraction arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.BinaryExpression" /> représentant une opération de soustraction arithmétique comportant une vérification de dépassement de capacité.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> et dont les propriétés <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> et <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="left">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> doit être égale.</param>
      <param name="right">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> ou <paramref name="right" /> est null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas deux arguments exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur de soustraction n’est pas défini pour <paramref name="left" />.Type et <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch avec cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat de l'instruction switch si <paramref name="switchValue" /> ne correspond à aucun cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch avec cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat de l'instruction switch si <paramref name="switchValue" /> ne correspond à aucun cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch avec cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat de l'instruction switch si <paramref name="switchValue" /> ne correspond à aucun cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch sans cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch avec cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat de l'instruction switch si <paramref name="switchValue" /> ne correspond à aucun cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchExpression" /> représentant une instruction switch avec cas par défaut.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchExpression" /> créée.</returns>
      <param name="type">Type de résultat du commutateur.</param>
      <param name="switchValue">Valeur à tester pour chaque cas.</param>
      <param name="defaultBody">Résultat de l'instruction switch si <paramref name="switchValue" /> ne correspond à aucun cas.</param>
      <param name="comparison">Méthode de comparaison d'égalité à utiliser.</param>
      <param name="cases">Ensemble de cas pour cette expression de switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée un objet <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un objet <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.SwitchCase" /> à utiliser dans un <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SwitchCase" /> créé.</returns>
      <param name="body">Corps du cas.</param>
      <param name="testValues">Valeurs de test du cas.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> a la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crée une instance de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> dont les propriétés <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> et <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> ont la valeur spécifiée.</returns>
      <param name="fileName">
        <see cref="T:System.String" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> doit être égale.</param>
      <param name="language">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> doit être égale.</param>
      <param name="languageVendor">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> doit être égale.</param>
      <param name="documentType">
        <see cref="T:System.Guid" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une levée d'exception.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">
        <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une levée d'exception avec un type donné.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant l'exception.</returns>
      <param name="value">
        <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> de l'expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Renvoie une représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc try avec un nombre quelconque d'instructions catch, mais aucune erreur ni bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TryExpression" /> créée.</returns>
      <param name="body">Corps du bloc try.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant les instructions catch à associer au bloc try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc try avec un nombre quelconque d'instructions catch et un bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TryExpression" /> créée.</returns>
      <param name="body">Corps du bloc try.</param>
      <param name="finally">Corps du bloc finally.</param>
      <param name="handlers">Tableau de zéro ou plusieurs expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> représentant les instructions catch à associer au bloc try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée un <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc try avec un bloc fault et aucune instruction catch.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TryExpression" /> créée.</returns>
      <param name="body">Corps du bloc try.</param>
      <param name="fault">Corps du bloc fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TryExpression" /> représentant un bloc try avec un bloc finally et aucune instruction catch.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TryExpression" /> créée.</returns>
      <param name="body">Corps du bloc try.</param>
      <param name="finally">Corps du bloc finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant un type délégué System.Action générique comportant des arguments de type spécifiques.</summary>
      <returns>La valeur est true si le type délégué System.Action générique a été créé pour des <paramref name="typeArgs" /> spécifiques, sinon false.</returns>
      <param name="typeArgs">Tableau d'objets Type spécifiant les arguments de type pour le type délégué System.Action.</param>
      <param name="actionType">Cette méthode renvoie le type délégué System.Action générique comportant des arguments de type spécifiques.Contient la valeur null s'il n'y a aucun délégué System.Action générique correspondant aux <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crée un objet <see cref="P:System.Linq.Expressions.Expression.Type" /> représentant un type délégué System.Func générique comportant des arguments de type spécifiques.Le dernier argument de type spécifie le type de retour du délégué créé.</summary>
      <returns>La valeur est true si le type délégué System.Func générique a été créé pour des <paramref name="typeArgs" /> spécifiques, sinon false.</returns>
      <param name="typeArgs">Tableau d'objets Type spécifiant les arguments de type pour le type délégué System.Func.</param>
      <param name="funcType">Cette méthode renvoie le type délégué System.Func générique comportant des arguments de type spécifiques.Contient la valeur null s'il n'y a aucun délégué System.Func générique correspondant aux <paramref name="typeArgs" />. Ce paramètre est passé sans être initialisé.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="T:System.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une référence explicite ou une conversion boxing où la valeur null est fournie en cas d'échec de la conversion.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.Expression.Type" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="type">
        <see cref="T:System.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.Expression.Type" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> comparant l'identité de type d'exécution.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> et dont les propriétés <see cref="T:System.Linq.Expressions.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="T:System.Linq.Expressions.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> et dont les propriétés <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> et <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> doit être égale.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> auquel la propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> ou <paramref name="type" /> est null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> a la valeur spécifiée.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.InvalidOperationException">L’opérateur plus unaire n’est pas défini pour <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant une opération plus unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> dont la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est égale à <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> et dont les propriétés <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> et <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> ont les valeurs spécifiées.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> doit être égale.</param>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> à laquelle la propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> doit être égale.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> a la valeur null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> n’est pas null et la méthode représentée retourne void, n’est pas static (Shared en Visual Basic) ou ne prend pas un argument exactement.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> est null et l’opérateur plus unaire n’est pas défini pour <paramref name="expression" />.Type.– ou –<paramref name="expression" />.Type (ou son type non Nullable correspondant s’il s’agit d’un type valeur Nullable) ne peut pas être assigné au type d’argument de la méthode représentée par <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crée une <see cref="T:System.Linq.Expressions.UnaryExpression" /> représentant un unboxing explicite.</summary>
      <returns>Instance de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> à laquelle appliquer un unboxing.</param>
      <param name="type">Nouveau <see cref="T:System.Type" /> de l'expression.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> pouvant être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crée un nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> pouvant être utilisé pour identifier un paramètre ou une variable dans une arborescence d'expression.</summary>
      <returns>Nœud <see cref="T:System.Linq.Expressions.ParameterExpression" /> avec le nom et le type spécifiés.</returns>
      <param name="type">Type du paramètre ou de la variable.</param>
      <param name="name">Nom du paramètre ou de la variable.Ce nom est utilisé à des fins de débogage ou d'impression uniquement.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Réduit le nœud puis appelle le délégué visiteur sur l'expression réduite.La méthode lève une exception si le nœud n'est pas réductible.</summary>
      <returns>Expression visitée ou expression devant la remplacer dans l'arborescence.</returns>
      <param name="visitor">Instance de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Représente une expression lambda fortement typée comme une structure de données sous forme d'une arborescence d'expression.Cette classe ne peut pas être héritée.</summary>
      <typeparam name="TDelegate">Type du délégué représenté par <see cref="T:System.Linq.Expressions.Expression`1" />.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compile l'expression lambda décrite par l'arborescence de l'expression dans le code exécutable, et produit un délégué représentant l'expression lambda.</summary>
      <returns>Délégué de type <paramref name="TDelegate" /> représentant l'expression lambda compilée décrite par <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> du résultat.</param>
      <param name="parameters">Propriété <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> du résultat. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Décrit les types de nœuds d'une arborescence d'expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Opération d'addition, telle que a + b, sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Opération d'assignation composée d'addition, telle que (a += b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Opération d'addition, telle que (a + b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Opération AND logique ou au niveau du bit, telle que (a &amp; b) en C# et (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Opération AND conditionnelle évaluant la deuxième opérande uniquement si la première opérande a la valeur true.Correspond à (a &amp;&amp; b) en C# et (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Opération d'assignation composée AND au niveau du bit ou logique, telle que (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Opération d'indexation dans un tableau unidimensionnel, telle que array[index] en C# ou array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Opération qui obtient la longueur d'un tableau unidimensionnel, telle que array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Opération d'assignation telle que (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Bloc d'expressions.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Appel de méthode, comme dans l'expression obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nœud représentant une opération de fusion nulle, telle que (a ?? b) en C# ou If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Opération conditionnelle, telle que a &gt; b ? a : b en C# ou If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Valeur de constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie est trop grande pour le type de destination, aucune exception n'est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Opération de cast ou de conversion, telle que (SampleType)obj en C# ou CType(obj, SampleType) en Visual Basic.Pour une conversion numérique, si la valeur convertie ne correspond pas au type cible, une exception est levée.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Informations de débogage.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Opération de décrémentation unaire, telle que (a - 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Valeur par défaut.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Opération de division, telle que (a / b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Opération d'assignation composée de division, telle que (a /= b), pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Opération dynamique.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nœud représentant une comparaison d'égalité, telle que (a == b) en C# ou (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Opération XOR logique ou au niveau du bit, telle que (a ^ b) en C# ou (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Opération d'assignation composée XOR au niveau du bit ou logique, telle que (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Expression d'extension.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expression GoTo, telle que goto Label en C# ou GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparaison numérique « supérieur à », telle que (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparaison « supérieur ou égal à », telle que (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Opération d'incrémentation unaire, telle que (a + 1) en C# et Visual Basic.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Opération d'index ou opération accédant à une propriété qui prend des arguments. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Opération appelant un délégué ou une expression lambda, telle que sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valeur de condition false.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valeur de condition true.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Étiquette.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Expression lambda, telle que a =&gt; a + a en C# ou Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Opération de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Assignation composée de décalage vers la gauche au niveau du bit, telle que (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparaison numérique « inférieur à », telle que (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparaison « inférieur ou égal à », telle que (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Opération créant un objet <see cref="T:System.Collections.IEnumerable" /> et initialisant celui-ci à partir d'une liste d'éléments, telle que new List&lt;SampleType&gt;(){ a, b, c } en C# ou Dim sampleList = { a, b, c } en Visual Basic..</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Boucle, comme for ou while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Opération qui lit un champ ou une propriété, telle que obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Opération créant un objet et initialisant un ou plusieurs de ses membres, telle que new Point { X = 1, Y = 2 } en C# ou New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Opération arithmétique de reste, telle que (a % b) en C# ou (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Opération arithmétique d'assignation composée du reste, telle que (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Opération de multiplication, telle que (a * b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Opération d'assignation composée de multiplication, telle que (a *= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Opération de multiplication, telle que (a * b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Opération arithmétique de négation, telle que (-a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Opération arithmétique de négation, telle que (-a), avec contrôle de dépassement.L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Opération appelant un constructeur pour créer un nouvel objet, telle que new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Opération créant un nouveau tableau dans lequel les limites de chaque dimension sont spécifiées, telle que new SampleType[dim1, dim2] en C# ou New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Opération créant un nouveau tableau unidimensionnel et initialisant celui-ci à partir d'une liste d'éléments, telle que new SampleType[]{a, b, c} en C# ou New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Complément de bits ou opération de négation logique.En C#, équivaut à (~a) pour les types intégraux et à (!a) pour les valeurs booléennes.En Visual Basic, équivaut à (Not a).L'objet a ne doit pas être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparaison d'inégalité, telle que (a != b) en C# ou (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Opération de complément, telle que (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Opération OR logique ou au niveau du bit, telle que (a | b) en C# ou (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Assignation composée OR au niveau du bit ou logique, telle que (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Opération OR conditionnelle de court-circuit, telle que (a || b) en C# ou (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Référence à un paramètre ou une variable défini(e) dans le contexte de l'expression.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Décrément suffixé unaire, tel que (a--).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Incrément suffixé unaire, tel que (a++).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Opération mathématique qui élève un nombre à une puissance, telle que (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Opération d'assignation composée qui élève un nombre à une puissance, telle que (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Décrément préfixé unaire, tel que (--a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Incrément préfixé unaire, tel que (++a).L'objet a doit être modifié sur place.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expression comportant une valeur constante de type <see cref="T:System.Linq.Expressions.Expression" />.Un nœud <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> peut contenir les références aux paramètres définis dans le contexte de l'expression qu'il représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Opération de décalage vers la droite au niveau du bit, telle que (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Opération d'assignation composée de décalage vers la droite au niveau du bit, telle que (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Liste de variables d'exécution.Pour plus d'informations, consultez <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Opération de soustraction, telle que (a - b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), sans vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Opération d'assignation composée de soustraction, telle que (a -= b), avec vérification de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Opération de soustraction arithmétique, telle que (a - b), avec contrôle de dépassement, pour les opérandes numériques.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Opération de commutateur, telle que switch en C# ou Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Opération levant une exception, telle que throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expression try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Référence explicite ou conversion boxing dans laquelle la valeur null est fournie si la conversion échoue, telle que (obj as SampleType) en C# ou TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Test de type exact.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Test de type, telle que obj is SampleType en C# ou TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Opération plus unaire, telle que (+a).Le résultat d'une opération plus unaire prédéfinie est la valeur de l'opérande, mais les implémentations définies par l'utilisateur peuvent avoir des résultats inhabituels.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Opération de type valeur unbox, telle que les instructions unbox et unbox.any en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Représente un visiteur ou un module de réécriture pour les arborescences d'expression.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Initialise une nouvelle instance de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Distribue la liste des expressions à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Liste d'expressions modifiées, si l'un des éléments a été modifié, sinon renvoie la liste d'expressions d'origine.</returns>
      <param name="nodes">Expressions à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visite tous les nœuds dans la collection à l'aide d'un visiteur d'élément spécifié.</summary>
      <returns>Liste de nœuds modifiés, si des éléments ont été modifiés, sinon renvoie la liste de nœuds d'origine.</returns>
      <param name="nodes">Nœuds à visiter.</param>
      <param name="elementVisitor">Délégué visitant un élément unique, en le remplaçant éventuellement par un nouvel élément.</param>
      <typeparam name="T">Type des nœuds.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Distribue l'expression à l'une des méthodes de visite les plus spécialisées dans cette classe.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="nodes">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visite une expression, en effectuant un cast arrière du résultat vers le type d'expression d'origine.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <param name="callerName">Nom de la méthode d'appel ; utilisé pour signaler un meilleur message d'erreur.</param>
      <typeparam name="T">Type de l'expression.</typeparam>
      <exception cref="T:System.InvalidOperationException">La méthode de visite pour ce nœud a retourné un type différent.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visite le <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visite le <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visite le <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visite les enfants de l'expression d'extension.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visite le <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
      <typeparam name="T">Type du délégué.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visite le <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visite les enfants de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expression modifiée, si celle-ci ou toute sous-expression a été modifiée, sinon renvoie l'expression d'origine.</returns>
      <param name="node">Expression à visiter.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Représente un saut inconditionnel.Cela inclut des instructions return, des instructions break et continue ainsi que d'autres sauts.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Type d'expression « go to ».Sert uniquement à des fins d'information.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> représentant le type d'expression « go to ».</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Étiquette cible à laquelle ce nœud accède.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant l'étiquette cible pour ce nœud.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> du résultat. </param>
      <param name="value">Propriété <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> du résultat. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valeur passée à la cible, ou null si la cible est de type System.Void.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant la valeur passée à la cible ou null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Spécifie le type de saut que cette <see cref="T:System.Linq.Expressions.GotoExpression" /> représente.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant un saut vers un emplacement.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> représentant une instruction return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Représente l'indexation d'une propriété ou d'un tableau.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtient les arguments qui seront utilisés pour indexer la propriété ou le tableau.</summary>
      <returns>Collection en lecture seule contenant les arguments qui seront utilisés pour indexer la propriété ou le tableau.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtient le <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon renvoie la valeur null.</summary>
      <returns>La valeur est <see cref="T:System.Reflection.PropertyInfo" /> pour la propriété si l'expression représente une propriété indexée, sinon null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objet à indexer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet à indexer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Représente une expression qui applique un délégué ou une expression lambda à une liste d'expressions d'arguments.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtient les arguments auxquels l'expression lambda ou le délégué est appliqué.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments auxquels le délégué est appliqué.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtient le délégué ou l'expression lambda à appliquer.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le délégué à appliquer.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Représente une étiquette, qui peut être placée dans tout contexte <see cref="T:System.Linq.Expressions.Expression" />.En cas de saut à cette étiquette, elle a la valeur fournie par le <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondant.Sinon, elle reçoit la valeur indiquée dans <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> est System.Void, aucune valeur ne doit être fournie.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>La valeur de <see cref="T:System.Linq.Expressions.LabelExpression" /> lorsque l'étiquette est atteinte via le flux de contrôle normal (par exemple, sans saut).</summary>
      <returns>Objet Expression représentant la valeur de <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> auquel cette étiquette est associée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="target">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> du résultat.</param>
      <param name="defaultValue">Propriété <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Utilisé pour représenter la cible d'un <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtient le nom de l'étiquette.</summary>
      <returns>Nom de l'étiquette.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Renvoie un <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Type de valeur transmise lors de l'accès à l'étiquette (ou <see cref="T:System.Void" /> si aucune valeur ne doit être transmise).</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de la valeur transmise lors de l'accès à l'étiquette ou <see cref="T:System.Void" /> si aucune valeur ne doit être transmise.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Décrit une expression lambda.Capture un bloc de code semblable au corps d'une méthode .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtient le corps de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps de l'expression lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Produit un délégué représentant l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> contenant la version compilée de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtient le nom de l'expression lambda.</summary>
      <returns>Nom de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtient les paramètres de l'expression lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ParameterExpression" /> représentant les paramètres de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtient le type de retour de l'expression lambda.</summary>
      <returns>Objet <see cref="T:System.Type" /> représentant le type de l'expression lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtient la valeur qui indique si l'expression lambda doit être compilée avec l'optimisation d'appel tail.</summary>
      <returns>La valeur est true si l'expression lambda doit être compilée avec l'optimisation d'appel tail, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Représente un appel de constructeur ayant un initialiseur de collection.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtient une valeur indiquant si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>La valeur est true si le nœud peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtient les initialiseurs de l'élément utilisés pour initialiser une collection.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> représentant les éléments utilisés pour initialiser la collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtient l'expression contenant un appel au constructeur d'un type de collection.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel au constructeur d'un type de collection.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Réduit le nœud d'expression binaire en une expression plus simple.</summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> du résultat.</param>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Représente une boucle infinie.Elle peut être quittée avec « break ».</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> correspondant au corps de la boucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> correspondant au corps de la boucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> utilisé par le corps de la boucle comme cible d'instruction continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="breakLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> du résultat.</param>
      <param name="continueLabel">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Représente l'opération d'assignation d'un champ ou d'une propriété à un objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtient l'expression à assigner au champ ou à la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant la valeur à assigner au champ ou à la propriété.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Fournit la classe de base à partir de laquelle sont dérivées les classes représentant les liaisons utilisées pour initialiser les membres d'un objet nouvellement créé.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">
        <see cref="T:System.Linq.Expressions.MemberBindingType" /> discriminant le type de liaison représenté.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> représentant un champ ou une propriété à initialiser.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtient le type de liaison représenté.</summary>
      <returns>Une des valeurs <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtient le champ ou la propriété à initialiser.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> représentant le champ ou la propriété à initialiser.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Renvoie une représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Représentation textuelle de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Décrit les types de liaisons utilisés dans les objets <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Liaison qui représente l'initialisation d'un membre avec la valeur d'une expression.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Liaison qui représente l'initialisation d'un membre de type <see cref="T:System.Collections.IList" /> ou <see cref="T:System.Collections.Generic.ICollection`1" /> dans une liste d'éléments.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Liaison qui représente l'initialisation récurrente des membres d'un membre.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Représente l'accès à un champ ou à une propriété.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtient l'objet contenant du champ ou de la propriété.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> qui représente l'objet contenant du champ ou de la propriété.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtient le champ ou la propriété auquel accéder.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> représentant la propriété ou le champ auquel accéder.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Représente l'appel d'un constructeur et l'initialisation d'un ou de plusieurs membres du nouvel objet.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtient les liaisons décrivant comment initialiser les membres de l'objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.MemberBinding" /> décrivant comment initialiser les membres.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtient une valeur indiquant si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>La valeur est true si le nœud peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtient l'expression représentant l'appel de constructeur.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> représentant l'appel de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Réduit <see cref="T:System.Linq.Expressions.MemberInitExpression" /> à une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="newExpression">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> du résultat.</param>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Représente l'initialisation des éléments d'un membre de collection d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtient les initialiseurs de l'élément pour initialiser un membre de collection d'un objet nouvellement créé.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.ElementInit" /> avec lequel initialiser un membre de collection.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="initializers">Propriété <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Représente l'initialisation des membres d'un membre d'un objet nouvellement créé.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtient les liaisons décrivant comment initialiser les membres d'un membre.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de <see cref="T:System.Linq.Expressions.MemberBinding" /> objets décrivant l'initialisation des membres du membre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="bindings">Propriété <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Représente un appel à une méthode statique ou une méthode d'instance.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtient une collection d'expressions représentant les arguments de la méthode appelée.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments de la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtient l'objet <see cref="T:System.Reflection.MethodInfo" /> pour la méthode à appeler.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode appelée.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtient l'objet <see cref="T:System.Linq.Expressions.Expression" /> représentant l'instance pour les appels de méthode d'instance ou null pour les appels de méthode statique.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'objet de réception de la méthode.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="object">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> du résultat.</param>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Représente la création d'un tableau et l'éventuelle initialisation des éléments du nouveau tableau.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtient les limites du tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, ou les valeurs pour initialiser les éléments du nouveau tableau si la valeur de la propriété <see cref="P:System.Linq.Expressions.Expression.NodeType" /> est <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les limites du tableau ou les valeurs d'initialisation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="expressions">Propriété <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Représente un appel de constructeur.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtient les arguments pour le constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.Expression" /> représentant les arguments pour le constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtient le constructeur appelé.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> représentant le constructeur appelé.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtient les membres qui peuvent récupérer les valeurs des champs initialisés avec des arguments de constructeur.</summary>
      <returns>Collection d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres qui peuvent récupérer les valeurs des champs initialisés avec des arguments de constructeur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="arguments">Propriété <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Représente une expression de paramètre nommée.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Distribue à la méthode de visite spécifique pour ce type de nœud.Par exemple, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> appelle <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Résultat de la visite de ce nœud.</returns>
      <param name="visitor">Visiteur avec lequel visiter ce nœud.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indique que ce ParameterExpression doit être traité comme un paramètre ByRef.</summary>
      <returns>La valeur est True si ce ParameterExpression est un paramètre ByRef, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtient le nom du paramètre ou de la variable.</summary>
      <returns>
        <see cref="T:System.String" /> contenant le nom du paramètre.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expression fournissant l'autorisation de lecture/écriture d'exécution pour les variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="variables">Propriété <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> du résultat.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables ou paramètres auxquels fournir l'accès d'exécution.</summary>
      <returns>Collection en lecture seule contenant des paramètres qui se verront octroyer l'accès d'exécution.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Représente le cas d'une <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtient le corps de ce cas.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc de cas.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtient les valeurs de ce cas.Ce cas est sélectionné pour être exécuté lorsque le <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> correspond à chacune de ces valeurs.</summary>
      <returns>Collection en lecture seule des valeurs de ce bloc case.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Renvoie un <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</summary>
      <returns>
        <see cref="T:System.String" /> représentant le <see cref="T:System.Object" /> actuel.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="testValues">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> du résultat.</param>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Représente une expression de contrôle gérant des sélections multiples en transmettant le contrôle à <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtient la collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" /> pour le commutateur.</summary>
      <returns>Collection d'objets <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtient la méthode de comparaison d'égalité, le cas échéant.</summary>
      <returns>Objet <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode de comparaison d'égalité.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtient le test pour le commutateur.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.Expression" /> représentant le test pour le commutateur.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="switchValue">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> du résultat.</param>
      <param name="cases">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> du résultat.</param>
      <param name="defaultBody">Propriété <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Stocke les informations nécessaires pour émettre les informations de symboles de débogage pour un fichier source, en particulier le nom de fichier et l'identificateur de langue unique.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Renvoie l'identificateur unique du type de document, le cas échéant.La valeur par défaut est le GUID pour un fichier texte.</summary>
      <returns>Identificateur unique du type de document.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nom du fichier source.</summary>
      <returns>Chaîne représentant le nom du fichier source.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Renvoie l'identificateur unique de langue, le cas échéant.</summary>
      <returns>Identificateur unique de langue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Renvoie l'identificateur unique du fournisseur de langue, le cas échéant.</summary>
      <returns>Identificateur unique du fournisseur de langue.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Représente un bloc try/catch/finally/fault.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le corps du bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le bloc fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le bloc fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtient le <see cref="T:System.Linq.Expressions.Expression" /> représentant le bloc finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant le bloc finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtient la collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</summary>
      <returns>Collection d'expressions <see cref="T:System.Linq.Expressions.CatchBlock" /> associée au bloc try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="body">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Body" /> du résultat.</param>
      <param name="handlers">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> du résultat.</param>
      <param name="finally">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> du résultat.</param>
      <param name="fault">Propriété <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Représente une opération entre une expression et un type.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtient l'opérande d'expression d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande d'expression d'une opération de test de type.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Renvoie le type de nœud de cette expression.Les nœuds d'extension doivent renvoyer <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> lors de la substitution de cette méthode.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtient l'opérande de type d'une opération de test de type.</summary>
      <returns>
        <see cref="T:System.Type" /> représentant l'opérande de type d'une opération de test de type.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="expression">Propriété <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> du résultat.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Représente une expression qui comporte un opérateur unaire.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence de l'expression peut être réduit.</summary>
      <returns>La valeur est true si un nœud peut être réduit, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur.</summary>
      <returns>La valeur est true si le nœud représente un appel levé, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtient une valeur qui indique si le nœud d'arborescence d'expression représente un appel levé vers un opérateur dont le type de retour est levé vers un type nullable.</summary>
      <returns>La valeur est true si le type de retour de l'opérateur est levé vers un type nullable, sinon false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtient la méthode d'implémentation pour l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> représentant la méthode d'implémentation.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Renvoie le type de nœud de cette <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> représentant cette expression.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtient l'opérande de l'opération unaire.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> représentant l'opérande de l'opération unaire.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Réduit le nœud d'expression en une expression plus simple. </summary>
      <returns>Expression réduite.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtient le type statique de l'expression que cette <see cref="T:System.Linq.Expressions.Expression" /> représente.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> représentant le type statique de l'expression.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crée une expression semblable à celle-ci, mais utilisant les enfants fournis.Si tous les enfants sont identiques, renvoie cette expression.</summary>
      <returns>Cette expression si aucun enfant n'est modifié, ou une expression avec les enfants mis à jour.</returns>
      <param name="operand">Propriété <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> du résultat.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Classe de base d'un site d'appel dynamique.Ce type est utilisé comme type de paramètre pour les cibles d'un site dynamique.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Classe responsable de la liaison des opérations dynamiques sur le site dynamique.</summary>
      <returns>Objet <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de la liaison des opérations dynamiques.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crée un site d'appel à l'aide du type délégué et du binder donnés.</summary>
      <returns>Nouveau site d'appel.</returns>
      <param name="delegateType">Type délégué du site d'appel.</param>
      <param name="binder">Binder du site d'appel.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Type de site dynamique.</summary>
      <typeparam name="T">Type délégué.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crée une instance du site d'appel dynamique, initialisée à l'aide du binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</summary>
      <returns>Nouvelle instance du site d'appel dynamique.</returns>
      <param name="binder">Binder responsable de la liaison au moment de l'exécution des opérations dynamiques sur ce site d'appel.</param>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>Cache de niveau 0 - Délégué spécialisé basé sur l'historique du site.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>Délégué de mise à jour.Appelée lorsque le site dynamique rencontre des échecs dans le cache.</summary>
      <returns>Délégué de mise à jour.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Classe responsable de la liaison au moment de l'exécution des opérations dynamiques sur le site d'appel dynamique.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Exécute la liaison au moment de l'exécution de l'opération dynamique sur un jeu d'arguments.</summary>
      <returns>Expression qui exécute des tests sur les arguments d'opération dynamique, et exécute l'opération dynamique si les tests sont valides.Si les tests échouent sur les occurrences suivantes de l'opération dynamique, Bind est à nouveau appelé pour produire un nouveau <see cref="T:System.Linq.Expressions.Expression" /> pour les nouveaux types d'arguments.</returns>
      <param name="args">Tableau d'arguments de l'opération dynamique.</param>
      <param name="parameters">Tableau des instances <see cref="T:System.Linq.Expressions.ParameterExpression" /> qui représentent les paramètres du site d'appel dans le processus de liaison.</param>
      <param name="returnLabel">LabelTarget utilisé pour renvoyer le résultat de la liaison dynamique.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Fournit une prise en charge de bas niveau de la liaison au moment de l'exécution.Les classes peuvent substituer ceci et fournir un délégué direct pour l'implémentation de la règle.Cela permet d'enregistrer des règles sur disque, de disposer de règles spécialisées au moment de l'exécution ou de fournir une stratégie de mise en cache différente.</summary>
      <returns>Nouveau délégué qui remplace la cible du CallSite.</returns>
      <param name="site">CallSite pour lequel la liaison est exécutée.</param>
      <param name="args">Arguments du binder.</param>
      <typeparam name="T">Type cible du CallSite.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Ajoute une cible au cache des cibles connues.Les cibles mises en cache sont analysées avant d'appeler BindDelegate pour produire la nouvelle règle.</summary>
      <param name="target">Délégué cible à ajouter au cache.</param>
      <typeparam name="T">Type de cible ajouté.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Obtient une étiquette qui peut être utilisée pour provoquer la mise à jour de la liaison.Indique que la liaison de l'expression n'est plus valide.Cela est utilisé en général lorsque la « version » d'un objet dynamique a changé.</summary>
      <returns>Objet <see cref="T:System.Linq.Expressions.LabelTarget" /> représentant une étiquette qui peut être utilisée pour déclencher la mise à jour de la liaison.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Classe contenant des méthodes d'assistance pour les CallSites DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Vérifie si <see cref="T:System.Reflection.MethodBase" /> est utilisé en interne par DLR et s'il ne doit pas être affiché dans la pile du code de langue.</summary>
      <returns>La valeur est true si le <see cref="T:System.Reflection.MethodBase" /> d'entrée est utilisé en interne par DLR et s'il ne doit pas être affiché dans la pile du code de langue.Sinon false.</returns>
      <param name="mb">Entrée. <see cref="T:System.Reflection.MethodBase" /></param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indique que l'utilisation de <see cref="T:System.Object" /> sur un membre doit être traitée en tant que type distribué dynamiquement.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Spécifie, dans un parcours de préfixe d'une construction de type, les occurrences de <see cref="T:System.Object" /> qui doivent être traitées en tant que type distribué dynamiquement.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Spécifie, dans un parcours de préfixe d'une construction de type, les occurrences de <see cref="T:System.Object" /> qui doivent être traitées en tant que type distribué dynamiquement.</summary>
      <returns>Liste des occurrences de <see cref="T:System.Object" /> qui doivent être traitées en tant que type distribué dynamiquement.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ExecutionScope">
      <summary>Représente l'état d'exécution d'une méthode générée dynamiquement.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.CreateDelegate(System.Int32,System.Object[])">
      <summary>Crée un délégué qui peut être utilisé pour exécuter une méthode générée dynamiquement.</summary>
      <returns>
        <see cref="T:System.Delegate" /> pouvant exécuter une méthode générée dynamiquement.</returns>
      <param name="indexLambda">Index de l'objet qui stocke les informations sur l'expression lambda associée de la méthode dynamique.</param>
      <param name="locals">Tableau qui contient les variables locales levées du contexte parent.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.CreateHoistedLocals">
      <summary>Crée un tableau pour stocker les variables locales levées.</summary>
      <returns>Tableau destiné à stocker les variables locales levées.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Globals">
      <summary>Représente les constantes non triviales et les expressions exécutables localement qui sont référencées par une méthode générée dynamiquement.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.IsolateExpression(System.Linq.Expressions.Expression,System.Object[])">
      <summary>Libère une arborescence d'expression spécifiée de références de paramètre externe en remplaçant le paramètre par sa valeur actuelle.</summary>
      <returns>Arborescence d'expression qui ne contient pas de références de paramètre externe.</returns>
      <param name="expression">Arborescence d'expression à libérer de références de paramètre externe.</param>
      <param name="locals">Tableau qui contient les variables locales levées.</param>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Locals">
      <summary>Représente les variables locales levées du contexte parent.</summary>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Parent">
      <summary>Représente la portée d'exécution du délégué appelant.</summary>
    </member>
    <member name="T:System.Runtime.CompilerServices.IStrongBox">
      <summary>Définit une propriété pour accéder à la valeur à laquelle un objet fait référence.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IStrongBox.Value">
      <summary>Obtient ou définit la valeur à laquelle un objet fait référence.</summary>
      <returns>Valeur à laquelle l'objet fait référence.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.StrongBox`1">
      <summary>Contient une référence à une valeur.</summary>
      <typeparam name="T">Type de la valeur à laquelle <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> fait référence.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor"></member>
    <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> à l'aide de la valeur fournie. </summary>
      <param name="value">Valeur à laquelle <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> fera référence.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.StrongBox`1.System#Runtime#CompilerServices#IStrongBox#Value">
      <summary>Obtient ou définit la valeur à laquelle <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> fait référence.</summary>
      <returns>Valeur à laquelle <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> fait référence.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.StrongBox`1.Value">
      <summary>Représente la valeur à laquelle <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> fait référence.</summary>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Fournit une implémentation managée de l'algorithme symétrique AES (Advanced Encryption Standard). </summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Security.Cryptography.AesManaged" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet déchiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet déchiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <returns>Objet déchiffreur symétrique.</returns>
      <param name="key">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="iv">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le vecteur d'initialisation<paramref name=" iv " />est une taille non valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation actuels.</summary>
      <returns>Objet chiffreur symétrique.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crée un objet chiffreur symétrique avec la clé et le vecteur d'initialisation spécifiés.</summary>
      <returns>Objet chiffreur symétrique.</returns>
      <param name="key">Clé secrète à utiliser pour l'algorithme symétrique.</param>
      <param name="iv">Vecteur d'initialisation à utiliser pour l'algorithme symétrique.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> est null.</exception>
      <exception cref="T:System.ArgumentException">Le vecteur d'initialisation<paramref name=" iv " />est une taille non valide.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Génère un vecteur d'initialisation aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Génère une clé aléatoire à utiliser pour l'algorithme symétrique.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Obtient ou définit le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</summary>
      <returns>Le vecteur d'initialisation à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Obtient ou définit la clé secrète utilisée pour l'algorithme symétrique.</summary>
      <returns>La clé à utiliser pour l'algorithme symétrique.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Obtient ou définit la taille, en bits, de la clé secrète utilisée pour l'algorithme symétrique. </summary>
      <returns>Taille, en bits, de la clé utilisée par l'algorithme symétrique.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Spécifie si un verrou peut être entré plusieurs fois par le même thread.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Si un thread essaie d'entrer un verrou de manière récursive, une exception est levée. Certaines classes peuvent autoriser certaines récurrences lorsque ce paramètre est appliqué. </summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Un thread peut entrer un verrou de manière récursive. Certaines classes peuvent restreindre cette fonction. </summary>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Représente un verrou utilisé pour gérer l'accès à une ressource, en autorisant plusieurs threads pour la lecture ou un accès exclusif en écriture.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> avec des valeurs de propriété par défaut.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, en spécifiant la stratégie de récurrence du verrou.</summary>
      <param name="recursionPolicy">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou. </param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Obtient le nombre total de threads uniques qui ont entré le verrou en mode lecture.</summary>
      <returns>Le nombre de threads uniques qui ont entré le verrou en mode lecture.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Essaie d'entrer le verrou en mode lecture.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel est déjà entré en mode lecture. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Essaie d'entrer le verrou en mode de mise à niveau.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque. – ou –Le thread actuel est entré en mode lecture, et une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Essaie d'entrer le verrou en mode écriture.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou dans un mode quelconque. – ou –Le thread actuel est entré en mode lecture, et une tentative d'entrer le verrou en mode écriture risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Réduit le nombre de récurrences pour le mode lecture, et quitte le mode lecture si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread actuel n'a pas entré le verrou en mode lecture.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Réduit le nombre de récurrences pour le mode de mise à niveau, et quitte le mode de mise à niveau si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread actuel n'a pas entré le verrou en mode de mise à niveau.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Réduit le nombre de récurrences pour le mode écriture, et quitte le mode écriture si le compte résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread actuel n'a pas entré le verrou en mode écriture.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Obtient une valeur qui indique si le thread actuel a entré le verrou en mode lecture.</summary>
      <returns>La valeur est true si le thread actuel est entré en mode lecture, sinon false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Obtient une valeur qui indique si le thread actuel a entré le verrou en mode de mise à niveau. </summary>
      <returns>La valeur est true si le thread actuel est entré en mode de mise à niveau, sinon false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Obtient une valeur qui indique si le thread actuel a entré le verrou en mode écriture.</summary>
      <returns>La valeur est true si le thread actuel est entré en mode écriture, sinon false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Obtient une valeur qui indique la stratégie de récurrence pour l'objet <see cref="T:System.Threading.ReaderWriterLockSlim" /> actuel.</summary>
      <returns>Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Obtient le nombre de fois où le thread actuel a entré le verrou en mode lecture, comme une indication de récurrence.</summary>
      <returns>0 (zéro) si le thread actuel n'est pas entré en mode lecture, 1 si le thread est entré en mode lecture mais pas de façon récursive, ou n si le thread a entré le verrou n - 1 fois.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Obtient le nombre de fois où le thread actuel a entré le verrou en mode de mise à niveau, comme une indication de récurrence.</summary>
      <returns>0 (zéro) si le thread actuel n'est pas entré en mode de mise à niveau, 1 si le thread est entré en mode de mise à niveau mais pas de façon récursive, ou n si le thread a entré le verrou n - 1 fois.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Obtient le nombre de fois où le thread actuel a entré le verrou en mode écriture, comme une indication de récurrence.</summary>
      <returns>0 (zéro) si le thread actuel n'est pas entré en mode écriture, 1 si le thread est entré en mode écriture mais pas de façon récursive, ou n si le thread a entré le verrou n - 1 fois.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Essaie d'entrer le verrou en mode lecture, avec un délai d'attente entier facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode lecture, sinon false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Essaie d'entrer le verrou en mode lecture, avec un délai d'attente facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode lecture, sinon false.</returns>
      <param name="timeout">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini. </param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.– ou –La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Essaie d'entrer le verrou en mode de mise à niveau, avec un délai d'attente facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode de mise à niveau, sinon false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Essaie d'entrer le verrou en mode de mise à niveau, avec un délai d'attente facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode de mise à niveau, sinon false.</returns>
      <param name="timeout">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode de mise à niveau risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.– ou –La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode écriture, sinon false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou -1 (<see cref="F:System.Threading.Timeout.Infinite" />) pour un délai d'attente infini.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="millisecondsTimeout" /> est négative, mais différente de <see cref="F:System.Threading.Timeout.Infinite" /> (-1), qui est la seule valeur négative autorisée. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Essaie d'entrer le verrou en mode écriture, avec un délai d'attente facultatif.</summary>
      <returns>La valeur est true si le thread appelant est entré en mode écriture, sinon false.</returns>
      <param name="timeout">Intervalle d'attente, ou -1 millisecondes pour un délai d'attente infini.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propriété <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> est <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> et le thread actuel a déjà entré le verrou. – ou –Le thread actuel a entré à l'origine le verrou en mode lecture et par conséquent, une tentative d'entrer en mode écriture risquerait de créer un interblocage. – ou –Le nombre de récurrences dépasserait la capacité du compteur. Cette limite est si élevée que les applications ne doivent jamais la rencontrer.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="timeout" /> est négative, mais différente de -1 millisecondes, qui est la seule valeur négative autorisée.– ou –La valeur de <paramref name="timeout" /> est supérieure à <see cref="F:System.Int32.MaxValue" /> millisecondes. </exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Obtient le nombre total de threads qui attendent pour entrer le verrou en mode lecture.</summary>
      <returns>Le nombre total des threads qui attendent pour entrer en mode lecture.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Obtient le nombre total de threads qui attendent pour entrer le verrou en mode de mise à niveau.</summary>
      <returns>Le nombre total des threads qui attendent pour entrer en mode de mise à niveau.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Obtient le nombre total de threads qui attendent pour entrer le verrou en mode écriture.</summary>
      <returns>Le nombre total des threads qui attendent pour entrer en mode écriture.</returns>
    </member>
    <member name="T:System.Threading.Tasks.TaskExtensions">
      <summary>Fournit un ensemble de méthodes statiques (Shared en Visual Basic) pour l'utilisation de genres spécifiques d'instances <see cref="T:System.Threading.Tasks.Task" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
      <summary>Crée un proxy <see cref="T:System.Threading.Tasks.Task" /> représentant l'opération asynchrone d'une Task&lt;Task&lt;T&gt;&gt; (C#) ou Task (Of Task(Of T)) (Visual Basic).</summary>
      <returns>
        <see cref="System.Threading.Tasks.Task`1" /> représentant l'opération asynchrone de la Task&lt;Task&lt;T&gt;&gt; (C#) ou Task (Of Task(Of T)) (Visual Basic) fournie.</returns>
      <param name="task">Task&lt;Task&lt;T&gt;&gt; (C#) ou Task (Of Task(Of T)) (Visual Basic) à désencapsuler.</param>
      <typeparam name="TResult">Type du résultat de la tâche.</typeparam>
      <exception cref="T:System.ArgumentNullException">L'exception levée si l'argument <paramref name="task" /> est null.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
      <summary>Crée un proxy <see cref="T:System.Threading.Tasks.Task" /> qui représente l'opération asynchrone d'une <see cref="T:System.Threading.Tasks.Task{System.Threading.Tasks.Task}" />.</summary>
      <returns>Tâche représentant l'opération asynchrone de la System.Threading.Tasks.Task(Of Task) fournie.</returns>
      <param name="task">Task&lt;Task&gt; (C#) ou Task (Of Task) (Visual Basic) à désencapsuler.</param>
      <exception cref="T:System.ArgumentNullException">L'exception levée si l'argument <paramref name="task" /> est null.</exception>
    </member>
  </members>
</doc>