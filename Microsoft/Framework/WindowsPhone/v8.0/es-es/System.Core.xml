<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Core</name>
  </assembly>
  <members>
    <member name="T:System.Action`10">
      <summary>Encapsula un método que tiene 10 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`11">
      <summary>Encapsula un método que tiene 11 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`12">
      <summary>Encapsula un método que tiene 12 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`13">
      <summary>Encapsula un método que tiene 13 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`14">
      <summary>Encapsula un método que tiene 14 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`15">
      <summary>Encapsula un método que tiene 15 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <param name="arg15">Decimoquinto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T15">Tipo del decimoquinto parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`16">
      <summary>Encapsula un método que tiene 16 parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <param name="arg15">Decimoquinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg16">Decimosexto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T15">Tipo del decimoquinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T16">Tipo del decimosexto parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Action`9">
      <summary>Encapsula un método que tiene nueve parámetros y no devuelve un valor.</summary>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
    </member>
    <member name="T:System.Func`10">
      <summary>Encapsula un método que tiene nueve parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`11">
      <summary>Encapsula un método que tiene 10 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`12">
      <summary>Encapsula un método que tiene 11 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`13">
      <summary>Encapsula un método que tiene 12 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`14">
      <summary>Encapsula un método que tiene 13 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`15">
      <summary>Encapsula un método que tiene 14 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`16">
      <summary>Encapsula un método que tiene 15 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <param name="arg15">Decimoquinto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T15">Tipo del decimoquinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Func`17">
      <summary>Encapsula un método que tiene 16 parámetros y devuelve un valor del tipo especificado por el parámetro <paramref name="TResult" />.</summary>
      <returns>Valor devuelto del método que este delegado encapsula.</returns>
      <param name="arg1">Primer parámetro del método que este delegado encapsula.</param>
      <param name="arg2">Segundo parámetro del método que este delegado encapsula.</param>
      <param name="arg3">Tercer parámetro del método que este delegado encapsula.</param>
      <param name="arg4">Cuarto parámetro del método que este delegado encapsula.</param>
      <param name="arg5">Quinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg6">Sexto parámetro del método encapsulado por el delegado.</param>
      <param name="arg7">Séptimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg8">Octavo parámetro del método encapsulado por el delegado.</param>
      <param name="arg9">Noveno parámetro del método encapsulado por el delegado.</param>
      <param name="arg10">Décimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg11">Undécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg12">Duodécimo parámetro del método encapsulado por el delegado.</param>
      <param name="arg13">Decimotercero parámetro del método encapsulado por el delegado.</param>
      <param name="arg14">Decimocuarto parámetro del método encapsulado por el delegado.</param>
      <param name="arg15">Decimoquinto parámetro del método encapsulado por el delegado.</param>
      <param name="arg16">Decimosexto parámetro del método encapsulado por el delegado.</param>
      <typeparam name="T1">Tipo del primer parámetro del método que este delegado encapsula.This type parameter is contravariant. That is, you can use either the type you specified or any type that is less derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="T2">Tipo del segundo parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T3">Tipo del tercer parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T4">Tipo del cuarto parámetro del método que este delegado encapsula.</typeparam>
      <typeparam name="T5">Tipo del quinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T6">Tipo del sexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T7">Tipo del séptimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T8">Tipo del octavo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T9">Tipo del noveno parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T10">Tipo del décimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T11">Tipo del undécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T12">Tipo del duodécimo parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T13">Tipo del decimotercero parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T14">Tipo del decimocuarto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T15">Tipo del decimoquinto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="T16">Tipo del decimosexto parámetro del método encapsulado por el delegado.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto del método que este delegado encapsula.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Collections.Generic.HashSet`1">
      <summary>Representa un conjunto de valores.</summary>
      <typeparam name="T">Tipo de los elementos del conjunto hash.</typeparam>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que está vacía y utiliza el comparador de igualdad predeterminado para el tipo de conjunto.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que utiliza el comparador de igualdad predeterminado para el tipo de conjunto, contiene elementos copiados de la colección especificada y tiene capacidad suficiente para alojar el número de elementos copiados.</summary>
      <param name="collection">Colección cuyos elementos se copian en el nuevo conjunto.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="collection" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que utiliza el comparador de igualdad especificado para el tipo de conjunto, contiene elementos copiados de la colección especificada y tiene capacidad suficiente para alojar el número de elementos copiados.</summary>
      <param name="collection">Colección cuyos elementos se copian en el nuevo conjunto.</param>
      <param name="comparer">La implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a utilizar para comparar valores del conjunto o null si se va a utilizar la implementación <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predeterminada para el tipo de conjunto.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="collection" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que está vacía y utiliza el comparador de igualdad especificado para el tipo de conjunto.</summary>
      <param name="comparer">La implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a utilizar para comparar valores del conjunto o null si se va a utilizar la implementación <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predeterminada para el tipo de conjunto.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
      <summary>Agrega el elemento especificado a un conjunto.</summary>
      <returns>Es true si el elemento se agrega al objeto <see cref="T:System.Collections.Generic.HashSet`1" />; es false si el elemento ya está presente.</returns>
      <param name="item">Elemento que se va a agregar al conjunto.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Clear">
      <summary>Quita todos los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Comparer">
      <summary>Obtiene el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se utiliza para determinar la igualdad de los valores del conjunto.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se utiliza para determinar la igualdad de los valores del conjunto.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene el elemento especificado.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene el elemento especificado; en caso contrario, es false.</returns>
      <param name="item">Elemento que debe buscarse en el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])">
      <summary>Copia los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz.</summary>
      <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />. La matriz debe tener una indización de base cero.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
      <summary>Copia los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="arrayIndex">Índice de base cero de <paramref name="array" /> en el que empieza la operación de copia.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> es menor que 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayIndex" /> es mayor que la longitud de la <paramref name="array" /> de destino.-O bien-<paramref name="count" /> es mayor que el tamaño de la <paramref name="array" /> de destino.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
      <summary>Copia el número de elementos especificado de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz, comenzando en el índice especificado de la matriz.</summary>
      <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />. La matriz debe tener una indización de base cero.</param>
      <param name="arrayIndex">Índice de base cero de <paramref name="array" /> en el que empieza la operación de copia.</param>
      <param name="count">Número de elementos que se van a copiar en <paramref name="array" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> es menor que 0.-O bien-<paramref name="count" /> es menor que 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="arrayIndex" /> es mayor que la longitud de la <paramref name="array" /> de destino.-O bien-<paramref name="count" /> es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Count">
      <summary>Obtiene el número de elementos contenidos en un conjunto.</summary>
      <returns>Número de elementos contenidos en el conjunto.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Quita del objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual todos los elementos de la colección especificada.</summary>
      <param name="other">Colección de elementos que se van a quitar del objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> para el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que sólo contenga elementos que están presentes en ese objeto y en la colección especificada.</summary>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto apropiado de la colección especificada.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto apropiado de <paramref name="other" />; en caso contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto apropiado de la colección especificada.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto apropiado de <paramref name="other" />; en caso contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual. </param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto de la colección especificada.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto de <paramref name="other" />; en caso contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto de la colección especificada.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto de <paramref name="other" />; en caso contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual y una colección especificada comparten elementos comunes.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> y <paramref name="other" /> comparten al menos un elemento común; de lo contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
      <summary>Quita el elemento especificado de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>Es true si el elemento se quita correctamente; de lo contrario, es false.  Este método devuelve false si no se encuentra <paramref name="item" /> en el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
      <param name="item">Elemento que se va a quitar.</param>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
      <summary>Quita todos los elementos que cumplen las condiciones definidas por el predicado especificado de una colección <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>Número de elementos que se quitaron de la colección <see cref="T:System.Collections.Generic.HashSet`1" />.</returns>
      <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a quitar.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="match" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
      <summary>Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> y la colección especificada contienen los mismos elementos.</summary>
      <returns>Es true si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es igual a <paramref name="other" />; en caso contrario, es false.</returns>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que sólo contenga elementos que están presentes en ese objeto o en la colección especificada, pero no ambos.</summary>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
      <summary>Agrega un elemento a un objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
      <param name="item">Objeto que se va a agregar al objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">
        <see cref="T:System.Collections.Generic.ICollection`1" /> es de sólo lectura.</exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtiene un valor que indica si una colección es de sólo lectura.</summary>
      <returns>true si la colección es de sólo lectura; de lo contrario, false.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.IEnumerator`1" /> que puede utilizarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede utilizarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.TrimExcess">
      <summary>Establece la capacidad de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en el número real de elementos que contiene, redondeado a un valor próximo específico de la implementación.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
      <summary>Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que contenga todos los elementos que están presentes tanto en él como en la colección especificada.</summary>
      <param name="other">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="other" /> es null.</exception>
    </member>
    <member name="T:System.Collections.Generic.HashSet`1.Enumerator">
      <summary>Enumera los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Enumerator.Current">
      <summary>Obtiene el elemento situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección <see cref="T:System.Collections.Generic.HashSet`1" /> en la posición actual del enumerador.</returns>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.Dispose">
      <summary>Libera todos los recursos utilizados por un objeto <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />.</summary>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.MoveNext">
      <summary>Desplaza el enumerador al siguiente elemento de la colección <see cref="T:System.Collections.Generic.HashSet`1" />.</summary>
      <returns>true si el enumerador avanzó con éxito hasta el siguiente elemento; false si el enumerador alcanzó el final de la colección.</returns>
      <exception cref="T:System.InvalidOperationException">La colección se modificó después de crear el enumerador. </exception>
    </member>
    <member name="P:System.Collections.Generic.HashSet`1.Enumerator.System#Collections#IEnumerator#Current">
      <summary>Obtiene el elemento situado en la posición actual del enumerador.</summary>
      <returns>Elemento de la colección situado en la posición actual del enumerador, como un objeto <see cref="T:System.Object" />.</returns>
      <exception cref="T:System.InvalidOperationException">El enumerador se sitúa antes del primer elemento de la colección o después del último. </exception>
    </member>
    <member name="M:System.Collections.Generic.HashSet`1.Enumerator.System#Collections#IEnumerator#Reset">
      <summary>Establece el enumerador en su posición inicial (antes del primer elemento de la colección).</summary>
      <exception cref="T:System.InvalidOperationException">La colección se modificó después de crear el enumerador. </exception>
    </member>
    <member name="T:System.Dynamic.BinaryOperationBinder">
      <summary>Representa la operación binaria dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo de operación binaria.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación binaria dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación binaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación binaria dinámica.</param>
      <param name="arg">Operando del lado derecho de la operación binaria dinámica.</param>
    </member>
    <member name="M:System.Dynamic.BinaryOperationBinder.FallbackBinaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación binaria dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación binaria dinámica.</param>
      <param name="arg">Operando del lado derecho de la operación binaria dinámica.</param>
      <param name="errorSuggestion">Resultado cuando el enlace produce un error, o NULL.</param>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.Operation">
      <summary>Tipo de operación binaria.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación binaria.</returns>
    </member>
    <member name="P:System.Dynamic.BinaryOperationBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.BindingRestrictions">
      <summary>Representa un conjunto de restricciones de enlace en la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> bajo la que el enlace dinámico es válido.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Combine(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
      <summary>Combina las restricciones de enlace de la lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> en un conjunto de restricciones.</summary>
      <returns>Nuevo conjunto de restricciones de enlace.</returns>
      <param name="contributingObjects">Lista de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" /> a partir de la que se combinan las restricciones.</param>
    </member>
    <member name="F:System.Dynamic.BindingRestrictions.Empty">
      <summary>Representa un conjunto vacío de restricciones de enlace.Este campo es de solo lectura.</summary>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetExpressionRestriction(System.Linq.Expressions.Expression)">
      <summary>Crea la restricción obligatoria que comprueba la expresión en busca de propiedades inmutables arbitrarias.</summary>
      <returns>Nuevas restricciones de enlace.</returns>
      <param name="expression">Expresión que representa las restricciones.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetInstanceRestriction(System.Linq.Expressions.Expression,System.Object)">
      <summary>Crea la restricción de enlace que comprueba la expresión en busca de la identidad de instancias de objeto.</summary>
      <returns>Nuevas restricciones de enlace.</returns>
      <param name="expression">Expresión que se va a comprobar.</param>
      <param name="instance">Instancia de objeto exacta que se va a comprobar.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.GetTypeRestriction(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea la restricción de enlace que comprueba la expresión en busca de la identidad de tipos en tiempo de ejecución.</summary>
      <returns>Nuevas restricciones de enlace.</returns>
      <param name="expression">Expresión que se va a comprobar.</param>
      <param name="type">Tipo exacto que se va a comprobar.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.Merge(System.Dynamic.BindingRestrictions)">
      <summary>Combina el conjunto de restricciones de enlace con las restricciones de enlace actuales.</summary>
      <returns>Nuevo conjunto de restricciones de enlace.</returns>
      <param name="restrictions">Conjunto de restricciones de enlace con el que se combinan las restricciones de enlace actuales.</param>
    </member>
    <member name="M:System.Dynamic.BindingRestrictions.ToExpression">
      <summary>Crea el objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa las restricciones de enlace.</summary>
      <returns>Árbol de expresión que representa las restricciones.</returns>
    </member>
    <member name="T:System.Dynamic.CallInfo">
      <summary>Describe argumentos del proceso de enlace dinámico.</summary>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.String})">
      <summary>Crea una nueva clase CallInfo que representa los argumentos del proceso de enlace dinámico.</summary>
      <param name="argCount">Número de argumentos.</param>
      <param name="argNames">Nombres de argumento.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.#ctor(System.Int32,System.String[])">
      <summary>Crea un nuevo objeto PositionalArgumentInfo.</summary>
      <param name="argCount">Número de argumentos.</param>
      <param name="argNames">Nombres de argumento.</param>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentCount">
      <summary>Número de argumentos.</summary>
      <returns>Número de argumentos.</returns>
    </member>
    <member name="P:System.Dynamic.CallInfo.ArgumentNames">
      <summary>Nombres de argumento.</summary>
      <returns>Colección de solo lectura de nombres de argumento.</returns>
    </member>
    <member name="M:System.Dynamic.CallInfo.Equals(System.Object)">
      <summary>Determina si la instancia de CallInfo especificada se considera igual que la actual.</summary>
      <returns>Es true si la instancia especificada es igual que la actual; de lo contrario, es false.</returns>
      <param name="obj">Instancia de <see cref="T:System.Dynamic.CallInfo" /> que se va a comparar con la instancia actual.</param>
    </member>
    <member name="M:System.Dynamic.CallInfo.GetHashCode">
      <summary>Sirve como función hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</summary>
      <returns>Código hash para el objeto <see cref="T:System.Dynamic.CallInfo" /> actual.</returns>
    </member>
    <member name="T:System.Dynamic.ConvertBinder">
      <summary>Representa la operación de conversión dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.#ctor(System.Type,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
      <param name="type">Tipo al que se va a convertir.</param>
      <param name="explicit">Es true si la conversión debe considerar las conversiones explícitas; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de conversión dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de conversión dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de conversión dinámica.</param>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Explicit">
      <summary>Obtiene el valor que indica si la conversión debe considerar las conversiones explícitas.</summary>
      <returns>Es True si hay una conversión explícita; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de conversión dinámica si no se puede enlazar el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de conversión dinámica.</param>
    </member>
    <member name="M:System.Dynamic.ConvertBinder.FallbackConvert(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de conversión dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de conversión dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="P:System.Dynamic.ConvertBinder.Type">
      <summary>Tipo al que se va a convertir.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo en el que se va a convertir.</returns>
    </member>
    <member name="T:System.Dynamic.CreateInstanceBinder">
      <summary>Representa la operación de creación dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de creación dinámica.</param>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Argumentos de la operación de creación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.CreateInstanceBinder.FallbackCreateInstance(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de creación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de creación dinámica.</param>
      <param name="args">Argumentos de la operación de creación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.CreateInstanceBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteIndexBinder">
      <summary>Representa la operación de eliminación de índice dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de eliminación de índice dinámica.</param>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de eliminación de índice dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DeleteIndexBinder.FallbackDeleteIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de eliminación de índice dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.DeleteIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DeleteMemberBinder">
      <summary>Representa la operación de eliminación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a eliminar.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de eliminación de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DeleteMemberBinder.FallbackDeleteMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de eliminación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de eliminación de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>True si la comparación de cadenas no debe distinguir entre mayúsculas y minúsculas; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a eliminar.</summary>
      <returns>Nombre del miembro que se va a eliminar.</returns>
    </member>
    <member name="P:System.Dynamic.DeleteMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObject">
      <summary>Representa el enlace dinámico y una lógica de enlace de un objeto que participa en el enlace dinámico.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.#ctor(System.Linq.Expressions.Expression,System.Dynamic.BindingRestrictions,System.Object)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
      <param name="restrictions">Conjunto de restricciones de enlace en las que el enlace es válido.</param>
      <param name="value">Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación binaria dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="arg">Una instancia de <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el lado derecho de la operación binaria.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindConvert(System.Dynamic.ConvertBinder)">
      <summary>Realiza el enlace de la operación de conversión dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.ConvertBinder" /> que representa los detalles de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindCreateInstance(System.Dynamic.CreateInstanceBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de creación de instancias dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.CreateInstanceBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para crear la operación de creación de instancias.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de eliminación de índice dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.DeleteIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de eliminación de índice.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Realiza el enlace de la operación de eliminación de miembros dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.DeleteMemberBinder" /> que representa los detalles de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.GetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de obtención de índice.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindGetMember(System.Dynamic.GetMemberBinder)">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.GetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.InvokeBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.InvokeMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="args">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: argumentos para la operación de invocación de miembros.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.SetIndexBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="indexes">Una matriz de instancias de <see cref="T:System.Dynamic.DynamicMetaObject" />: índices para la operación de obtención de índice.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de índice.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.SetMemberBinder" /> que representa los detalles de la operación dinámica.</param>
      <param name="value">
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el valor para la operación de establecimiento de miembros.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.BindUnaryOperation(System.Dynamic.UnaryOperationBinder)">
      <summary>Realiza el enlace de la operación unaria dinámica.</summary>
      <returns>Nuevo objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="binder">Una instancia de la clase <see cref="T:System.Dynamic.UnaryOperationBinder" /> que representa los detalles de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.Create(System.Object,System.Linq.Expressions.Expression)">
      <summary>Crea un metaobjeto para el objeto especificado.</summary>
      <returns>Si el objeto especificado implementa <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> y no es un objeto remoto de fuera del AppDomain actual, devuelve el metaobjeto específico del objeto devuelto por el método <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />.De lo contrario, se crea y se devuelve un nuevo metaobjeto sin formato y sin restricciones.</returns>
      <param name="value">Objeto para el que se va a obtener un metaobjeto.</param>
      <param name="expression">Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</param>
    </member>
    <member name="F:System.Dynamic.DynamicMetaObject.EmptyMetaObjects">
      <summary>Representa una matriz vacía de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.Este campo es de solo lectura.</summary>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Expression">
      <summary>Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</summary>
      <returns>Expresión que representa este objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> durante el proceso de enlace dinámico.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObject.GetDynamicMemberNames">
      <summary>Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
      <returns>Lista de nombres de miembro dinámicos.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.HasValue">
      <summary>Obtiene un valor que indica si <see cref="T:System.Dynamic.DynamicMetaObject" /> tiene el valor en tiempo de ejecución.</summary>
      <returns>True si <see cref="T:System.Dynamic.DynamicMetaObject" /> contiene el valor en tiempo de ejecución; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.LimitType">
      <summary>Obtiene el tipo de límite del objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>
        <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> si el valor en tiempo de ejecución está disponible; de lo contrario, un tipo de la propiedad <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Restrictions">
      <summary>Conjunto de restricciones de enlace en las que el enlace es válido.</summary>
      <returns>Conjunto de restricciones de enlace.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.RuntimeType">
      <summary>Obtiene el objeto <see cref="T:System.Type" /> del valor en tiempo de ejecución, o NULL si <see cref="T:System.Dynamic.DynamicMetaObject" /> no tiene ningún valor asociado.</summary>
      <returns>
        <see cref="T:System.Type" /> del valor en tiempo de ejecución o NULL.</returns>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObject.Value">
      <summary>Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
      <returns>Valor en tiempo de ejecución representado por el objeto <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicMetaObjectBinder">
      <summary>Enlazador de sitio de llamada dinámico que participa en el protocolo de enlace <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.DynamicMetaObjectBinder" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <returns>Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas.Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.Defer(System.Dynamic.DynamicMetaObject[])">
      <summary>Aplaza el enlace de la operación hasta más tarde, cuando se hayan calculado los valores en tiempo de ejecución de todos los argumentos de la operación dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.DynamicMetaObjectBinder.GetUpdateExpression(System.Type)">
      <summary>Obtiene una expresión que provocará la actualización del enlace.Indica que el enlace de la expresión ya no es válido.Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <returns>Expresión de actualización.</returns>
      <param name="type">Propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de la expresión resultante; se permite cualquier tipo.</param>
    </member>
    <member name="P:System.Dynamic.DynamicMetaObjectBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.DynamicObject">
      <summary>Proporciona una clase base para especificar el comportamiento dinámico en tiempo de ejecución.Esta clase debe heredarse; no pueden crearse instancias de la misma directamente.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.#ctor">
      <summary>Permite a los tipos derivados inicializar una nueva instancia del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
      <summary>Devuelve la enumeración de todos los nombres de miembros dinámicos. </summary>
      <returns>Secuencia que contiene nombres de miembros dinámicos.</returns>
    </member>
    <member name="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Proporciona un objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que envía a los métodos virtuales dinámicos.El objeto se puede encapsular dentro de otro objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> para proporcionar un comportamiento personalizado para acciones individuales.Este método admite la infraestructura de Dynamic Language Runtime para los implementadores de lenguaje y no está pensado para que se use directamente en el código.</summary>
      <returns>Objeto de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
      <param name="parameter">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enviar a los métodos virtuales dinámicos.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
      <summary>Proporciona la implementación de operaciones binarias.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como la suma o la multiplicación.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación binaria.La propiedad binder.Operation devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />.Por ejemplo, para la instrucción sum = first + second, donde first y second se derivan de la clase DynamicObject, binder.Operation devuelve ExpressionType.Add.</param>
      <param name="arg">Operando derecho de la operación binaria.Por ejemplo, para la instrucción sum = first + second, donde first y second se derivan de la clase DynamicObject, <paramref name="arg" /> es igual a second.</param>
      <param name="result">Resultado de la operación binaria.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
      <summary>Proporciona la implementación de las operaciones de conversión de tipos.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que convierten un objeto de un tipo a otro.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación de conversión.La propiedad binder.Type proporciona el tipo al que se debe convertir el objeto.Por ejemplo, para la instrucción (String)sampleObject de C# (CType(sampleObject, Type) en Visual Basic), donde sampleObject es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, binder.Type devuelve el tipo <see cref="T:System.String" />.La propiedad binder.Explicit proporciona información sobre el tipo de conversión que se produce.Devuelve true para la conversión explícita y false para la conversión implícita.</param>
      <param name="result">Resultado de la operación de conversión de tipos.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que inicializan una nueva instancia de un objeto dinámico.Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación de inicialización.</param>
      <param name="args">Argumentos que se pasan al objeto durante la inicialización.Por ejemplo, para la operación new SampleType(100), donde SampleType es el tipo derivado de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> es igual a 100.</param>
      <param name="result">Resultado de la inicialización.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
      <summary>Proporciona la implementación de las operaciones que eliminan un objeto por índice.Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la eliminación.</param>
      <param name="indexes">Índices que se van a eliminar.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
      <summary>Proporciona la implementación de las operaciones que eliminan un miembro de objeto.Este método no está pensado para su uso en C# o Visual Basic.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la eliminación.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que obtienen un valor por índice.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para las operaciones de indización.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación. </param>
      <param name="indexes">Índices que se usan en la operación.Por ejemplo, para la operación sampleObject[3] de C# (sampleObject(3) en Visual Basic), donde sampleObject se deriva de la clase DynamicObject, <paramref name="indexes[0]" /> es igual a 3.</param>
      <param name="result">Resultado de la operación de índice.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
      <summary>Proporciona la implementación de las operaciones que obtienen valores de miembro.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como obtener el valor de una propiedad.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica.La propiedad binder.Name proporciona el nombre del miembro con el que se realiza la operación dinámica.Por ejemplo, para la instrucción Console.WriteLine(sampleObject.SampleProperty), donde sampleObject es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, binder.Name devuelve "SampleProperty".La propiedad binder.IgnoreCase especifica si en el nombre de miembro se distingue mayúsculas de minúsculas.</param>
      <param name="result">Resultado de la operación Get.Por ejemplo, si se llama al método para una propiedad, se puede asignar el valor de propiedad a <paramref name="result" />.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación para las operaciones que invocan un objeto.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como invocar un objeto o un delegado.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación de invocación.</param>
      <param name="args">Argumentos que se pasan al objeto durante la operación de invocación.Por ejemplo, para la operación sampleObject(100), donde sampleObject se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> es igual a 100.</param>
      <param name="result">Resultado de la invocación de objeto.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
      <summary>Proporciona la implementación de las operaciones que invocan un miembro.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como llamar a un método.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación dinámica.La propiedad binder.Name proporciona el nombre del miembro con el que se realiza la operación dinámica.Por ejemplo, para la instrucción sampleObject.SampleMethod(100), donde sampleObject es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, binder.Name devuelve "SampleMethod".La propiedad binder.IgnoreCase especifica si en el nombre de miembro se distingue mayúsculas de minúsculas.</param>
      <param name="args">Argumentos que se pasan al miembro de objeto durante la operación de invocación.Por ejemplo, para la instrucción sampleObject.SampleMethod(100), donde sampleObject se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="args[0]" /> es igual a 100.</param>
      <param name="result">Resultado de la invocación del miembro.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
      <summary>Proporciona la implementación de las operaciones que establecen un valor por índice.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que tienen acceso a los objetos por un índice especificado.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación. </param>
      <param name="indexes">Índices que se usan en la operación.Por ejemplo, para la operación sampleObject[3] = 10 de C# (sampleObject(3) = 10 en Visual Basic), donde sampleObject se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="indexes[0]" /> es igual a 3.</param>
      <param name="value">Valor que se establece en el objeto que tiene el índice especificado.Por ejemplo, para la operación sampleObject[3] = 10 de C# (sampleObject(3) = 10 en Visual Basic), donde sampleObject se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es igual a 10.</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
      <summary>Proporciona la implementación de las operaciones que establecen valores de miembro.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como establecer el valor de una propiedad.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica.La propiedad binder.Name proporciona el nombre del miembro al que se asigna el valor.Por ejemplo, para la instrucción sampleObject.SampleProperty = "Test", donde sampleObject es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, binder.Name devuelve "SampleProperty".La propiedad binder.IgnoreCase especifica si en el nombre de miembro se distingue mayúsculas de minúsculas.</param>
      <param name="value">Valor que se va a establecer para el miembro.Por ejemplo, para sampleObject.SampleProperty = "Test", donde sampleObject es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es "Test".</param>
    </member>
    <member name="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
      <summary>Proporciona la implementación de operaciones unarias.Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de operaciones como negación, incremento o decremento.</summary>
      <returns>true si la operación es correcta; de lo contrario, false.Si este método devuelve false, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
      <param name="binder">Proporciona información sobre la operación unaria.La propiedad binder.Operation devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />.Por ejemplo, para la instrucción negativeNumber = -number, donde number se deriva de la clase DynamicObject, binder.Operation devuelve "Negate".</param>
      <param name="result">Resultado de la operación unaria.</param>
    </member>
    <member name="T:System.Dynamic.ExpandoObject">
      <summary>Representa un objeto cuyos miembros se pueden agregar y quitar de forma dinámica en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.#ctor">
      <summary>Inicializa un nuevo ExpandoObject que no tiene miembros.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Agrega el valor especificado al objeto <see cref="T:System.Collections.Generic.ICollection`1" /> que tiene la clave especificada.</summary>
      <param name="item">Estructura <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que representa la clave y el valor que se van a agregar a la colección.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Clear">
      <summary>Quita todos los elementos de la colección.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Determina si <see cref="T:System.Collections.Generic.ICollection`1" /> contiene una clave y un valor específicos.</summary>
      <returns>Es true si la colección contiene una clave y un valor específicos; de lo contrario, es false.</returns>
      <param name="item">Estructura <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que se va a buscar en <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
      <summary>Copia los elementos de <see cref="T:System.Collections.Generic.ICollection`1" /> en una matriz de tipo <see cref="T:System.Collections.Generic.KeyValuePair`2" />, comenzando en el índice especificado de la matriz.</summary>
      <param name="array">Matriz unidimensional de tipo <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que constituye el destino de los elementos <see cref="T:System.Collections.Generic.KeyValuePair`2" /> copiados desde <see cref="T:System.Collections.Generic.ICollection`1" />.La matriz debe tener una indización de base cero.</param>
      <param name="arrayIndex">Índice de base cero en <paramref name="array" /> donde se inicia la operación de copia.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Count">
      <summary>Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
      <returns>Número de elementos incluidos en <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#IsReadOnly">
      <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
      <returns>true si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, false.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#ICollection{T}#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
      <summary>Quita una clave y valor de la colección.</summary>
      <returns>Es true si la clave y el valor se encuentran y eliminan correctamente; de lo contrario, es false.Este método devuelve false si no se encuentran la clave y el valor en <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
      <param name="item">Estructura <see cref="T:System.Collections.Generic.KeyValuePair`2" /> que representa la clave y valor que se van a quitar de la colección.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Add(System.String,System.Object)">
      <summary>Agrega la clave y el valor especificados al diccionario.</summary>
      <param name="key">Objeto que se va a utilizar como clave.</param>
      <param name="value">Objeto que se va a utilizar como valor.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#ContainsKey(System.String)">
      <summary>Determina si el diccionario contiene la clave especificada.</summary>
      <returns>Es true si el diccionario contiene un elemento que tiene la clave especificada; de lo contrario, false.</returns>
      <param name="key">Clave que se va a buscar en el diccionario.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Item(System.String)">
      <summary>Obtiene o establece el elemento que tiene la clave especificada.</summary>
      <returns>El elemento que tiene la clave especificada.</returns>
      <param name="key">La clave del elemento que se va a obtener o establecer.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Keys">
      <summary>Obtiene un objeto <see cref="T:System.Collections.Generic.ICollection`1" /> que contiene las claves de <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" /> que contiene las claves del objeto que implementa <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(System.String)">
      <summary>Quita de <see cref="T:System.Collections.IDictionary" /> el elemento que tiene la clave especificada.</summary>
      <returns>Es true si el elemento se quita correctamente; de lo contrario, es false.Este método también devuelve false si no se encuentra el parámetro <paramref name="key" /> en la colección <see cref="T:System.Collections.Generic.IDictionary`2" /> original.</returns>
      <param name="key">Clave del elemento que se va a quitar.</param>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#TryGetValue(System.String,System.Object@)">
      <summary>Obtiene el valor asociado a la clave especificada.</summary>
      <returns>Es true si el objeto que implementa <see cref="T:System.Collections.Generic.IDictionary`2" /> contiene un elemento con la clave especificada; en caso contrario, es false.</returns>
      <param name="key">Clave del valor que se va a obtener.</param>
      <param name="value">Si se encuentra la clave, cuando este método devuelve un resultado, contiene el valor asociado a la clave especificada; en caso contrario, contiene el valor predeterminado para el tipo del parámetro <paramref name="value" />.Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="P:System.Dynamic.ExpandoObject.System#Collections#Generic#IDictionary{TKey@TValue}#Values">
      <summary>Obtiene un objeto <see cref="T:System.Collections.Generic.ICollection`1" /> que contiene los valores incluidos en <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" /> que contiene los valores del objeto que implementa <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración la colección.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.IEnumerator`1" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración la colección.</summary>
      <returns>
        <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
    </member>
    <member name="E:System.Dynamic.ExpandoObject.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
      <summary>Se produce cuando cambia el valor de una propiedad.</summary>
    </member>
    <member name="M:System.Dynamic.ExpandoObject.System#Dynamic#IDynamicMetaObjectProvider#GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>El MetaObject proporcionado se enviará a los métodos virtuales dinámicos.El objeto se puede encapsular dentro de otro MetaObject para proporcionar el comportamiento personalizado para acciones individuales.</summary>
      <returns>Objeto del tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
      <param name="parameter">Expresión que representa el MetaObject que se va a enviar a los métodos virtuales dinámicos.</param>
    </member>
    <member name="T:System.Dynamic.GetIndexBinder">
      <summary>Representa la operación de obtención de índice dinámica en el sitio de llamada y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de obtención de índice dinámica.</param>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de índice dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de obtención de índice dinámica.</param>
    </member>
    <member name="M:System.Dynamic.GetIndexBinder.FallbackGetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de obtención de índice dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.GetIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.GetMemberBinder">
      <summary>Representa la operación de obtención de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de obtención de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de obtención de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.GetMemberBinder.FallbackGetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de obtención de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de obtención de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>True si no se distingue entre mayúsculas y minúsculas; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns>Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.GetMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.IDynamicMetaObjectProvider">
      <summary>Representa un objeto dinámico cuyas operaciones pueden enlazarse en tiempo de ejecución.</summary>
    </member>
    <member name="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>Devuelve la clase <see cref="T:System.Dynamic.DynamicMetaObject" /> responsable de las operaciones de enlace realizadas en este objeto.</summary>
      <returns>Clase <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enlazar al objeto.</returns>
      <param name="parameter">Representación de árbol de expresión del valor en tiempo de ejecución.</param>
    </member>
    <member name="T:System.Dynamic.IInvokeOnGetBinder">
      <summary>Representa información sobre una operación de obtención de miembros dinámica que indica si la obtención de miembros debe invocar propiedades cuando se realiza la operación Get.</summary>
    </member>
    <member name="P:System.Dynamic.IInvokeOnGetBinder.InvokeOnGet">
      <summary>Obtiene el valor que indica si esta operación de obtención de miembros debe invocar propiedades cuando se realiza la operación Get.El valor predeterminado cuando esta interfaz no está presente es true.</summary>
      <returns>Es true si esta operación de obtención de miembros debe invocar propiedades cuando se realiza la operación Get; de lo contrario, es false.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeBinder">
      <summary>Representa la operación de invocación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de invocación dinámica.</param>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.InvokeBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de invocación dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.InvokeBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.InvokeMemberBinder">
      <summary>Representa la operación de invocación de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.#ctor(System.String,System.Boolean,System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a invocar.</param>
      <param name="ignoreCase">true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, false.</param>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de invocación de miembros dinámica.</param>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvoke(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación dinámica.</param>
      <param name="args">Argumentos de la operación de invocación dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de invocación de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Argumentos de la operación de invocación de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.InvokeMemberBinder.FallbackInvokeMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de invocación de miembros dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de invocación de miembros dinámica.</param>
      <param name="args">Argumentos de la operación de invocación de miembros dinámica.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>True si no se distingue entre mayúsculas y minúsculas; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a invocar.</summary>
      <returns>Nombre del miembro que se va a invocar.</returns>
    </member>
    <member name="P:System.Dynamic.InvokeMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetIndexBinder">
      <summary>Representa la operación de establecimiento de índice dinámica en el sitio de llamada, proporcionando la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.#ctor(System.Dynamic.CallInfo)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
      <param name="callInfo">Firma de los argumentos en el sitio de llamada.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="args">Matriz de argumentos de la operación de establecimiento de índice dinámica.</param>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.CallInfo">
      <summary>Obtiene la firma de los argumentos en el sitio de llamada.</summary>
      <returns>Firma de los argumentos en el sitio de llamada.</returns>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value">Valor que se va a establecer para la colección.</param>
    </member>
    <member name="M:System.Dynamic.SetIndexBinder.FallbackSetIndex(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Cuando se reemplaza en la clase derivada, realiza el enlace de la operación de establecimiento de índice dinámica si el objeto dinámico de destino no se puede enlazar.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de índice dinámica.</param>
      <param name="indexes">Argumentos de la operación de establecimiento de índice dinámica.</param>
      <param name="value">Valor que se va a establecer para la colección.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.SetIndexBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.SetMemberBinder">
      <summary>Representa la operación de establecimiento de miembros dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.#ctor(System.String,System.Boolean)">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
      <param name="name">Nombre del miembro que se va a obtener.</param>
      <param name="ignoreCase">Es true si no se debe distinguir entre mayúsculas y minúsculas en la comparación; de lo contrario, es false.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="args">Una matriz de argumentos de la operación de establecimiento de miembros dinámica.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value">Valor que se va a establecer para el miembro.</param>
    </member>
    <member name="M:System.Dynamic.SetMemberBinder.FallbackSetMember(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación de establecimiento de miembros dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación de establecimiento de miembros dinámica.</param>
      <param name="value">Valor que se va a establecer para el miembro.</param>
      <param name="errorSuggestion">Resultado de enlace que se va a usar cuando el enlace genere un error o NULL.</param>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.IgnoreCase">
      <summary>Obtiene el valor que indica si la comparación de cadena no debe distinguir entre mayúsculas y minúsculas en el nombre del miembro.</summary>
      <returns>True si no se distingue entre mayúsculas y minúsculas; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.Name">
      <summary>Obtiene el nombre del miembro que se va a obtener.</summary>
      <returns>Nombre del miembro que se va a obtener.</returns>
    </member>
    <member name="P:System.Dynamic.SetMemberBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Dynamic.UnaryOperationBinder">
      <summary>Representa la operación unaria dinámica en el sitio de llamada, y proporciona la semántica del enlace y los detalles sobre la operación.</summary>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.#ctor(System.Linq.Expressions.ExpressionType)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Dynamic.BinaryOperationBinder" />.</summary>
      <param name="operation">Tipo de operación unaria.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.Bind(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
      <summary>Realiza el enlace de la operación unaria dinámica.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación dinámica.</param>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación unaria dinámica.</param>
    </member>
    <member name="M:System.Dynamic.UnaryOperationBinder.FallbackUnaryOperation(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
      <summary>Realiza el enlace de la operación unaria dinámica si no puede enlazarse el objeto dinámico de destino.</summary>
      <returns>
        <see cref="T:System.Dynamic.DynamicMetaObject" /> que representa el resultado del enlace.</returns>
      <param name="target">Destino de la operación unaria dinámica.</param>
      <param name="errorSuggestion">Resultado en caso de que el enlace produzca un error, o NULL.</param>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.Operation">
      <summary>Tipo de operación unaria.</summary>
      <returns>Objeto de la clase <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa el tipo de operación unaria.</returns>
    </member>
    <member name="P:System.Dynamic.UnaryOperationBinder.ReturnType">
      <summary>Tipo de resultado de la operación.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de resultado de la operación.</returns>
    </member>
    <member name="T:System.Linq.Enumerable">
      <summary>Proporciona un conjunto de métodos static (Shared en Visual Basic) para consultar objetos que implementan <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
      <summary>Aplica una función de acumulador a una secuencia.</summary>
      <returns>Valor final del acumulador.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> en el que se van a agregar elementos.</param>
      <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>Aplica una función de acumulador a una secuencia.El valor de inicialización especificado se utiliza como valor de inicio del acumulador.</summary>
      <returns>Valor final del acumulador.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> en el que se van a agregar elementos.</param>
      <param name="seed">Valor de inicio del acumulador.</param>
      <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
      <summary>Aplica una función de acumulador a una secuencia.El valor de inicialización especificado se utiliza como valor inicial del acumulador y la función especificada se utiliza para seleccionar el valor resultante.</summary>
      <returns>El valor final del acumulador transformado.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> en el que se van a agregar elementos.</param>
      <param name="seed">Valor de inicio del acumulador.</param>
      <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
      <param name="resultSelector">Función que va a transformar el valor final del acumulador en el valor del resultado.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
      <typeparam name="TResult">Tipo del valor resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Determina si todos los elementos de una secuencia satisfacen una condición.</summary>
      <returns>true si todos los elementos de la secuencia de origen pasan la prueba del predicado especificado o si la secuencia está vacía; de lo contrario, false.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos a los que se va a aplicar el predicado.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Determina si una secuencia contiene elementos.</summary>
      <returns>true si la secuencia de salida contiene elementos; de lo contrario, false.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a comprobar si está vacía.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Determina si algún elemento de una secuencia satisface una condición.</summary>
      <returns>true si algún elemento de la secuencia de salida pasa la prueba en el predicado especificado; de lo contrario, false.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> a cuyos elementos se va a aplicar el predicado.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve la entrada tipificada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>Secuencia de entrada tipificada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <param name="source">Secuencia que se va a tipificar como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de origen.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que acepta valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que acepta valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que acepta valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que acepta valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que acepta valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)">
      <summary>Convierte los elementos de <see cref="T:System.Collections.IEnumerable" /> en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene cada elemento de la secuencia de origen que se ha convertido al tipo especificado.</returns>
      <param name="source">
        <see cref="T:System.Collections.IEnumerable" /> que contiene los elementos que se van a convertir.</param>
      <typeparam name="TResult">Tipo al que se convierten los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidCastException">Un elemento de la secuencia no se puede convertir al tipo <paramref name="TResult" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Concatena dos secuencias.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos concatenados de las dos secuencias de entrada.</returns>
      <param name="first">Primera secuencia que se va a concatenar.</param>
      <param name="second">Secuencia que se va a concatenar con la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>Determina si una secuencia contiene un elemento especificado utilizando el comparador de igualdad predeterminado.</summary>
      <returns>true si la secuencia de origen contiene un elemento que tiene el valor especificado; de lo contrario, false.</returns>
      <param name="source">Secuencia en la que se va a buscar un valor.</param>
      <param name="value">Valor que se va a buscar en la secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Determina si una secuencia contiene un elemento especificado utilizando un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> determinado.</summary>
      <returns>true si la secuencia de origen contiene un elemento que tiene el valor especificado; de lo contrario, false.</returns>
      <param name="source">Secuencia en la que se va a buscar un valor.</param>
      <param name="value">Valor que se va a buscar en la secuencia.</param>
      <param name="comparer">Comparador de igualdad que va a comparar los valores.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el número de elementos de una secuencia.</summary>
      <returns>El número de elementos de la secuencia de entrada.</returns>
      <param name="source">Secuencia que contiene los elementos que se van a contar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos de <paramref name="source" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve un número que representa cuántos elementos de la secuencia especificada satisfacen una condición.</summary>
      <returns>Un número que representa cuántos elementos de la secuencia especificada satisfacen la condición de la función de predicado.</returns>
      <param name="source">Secuencia que contiene los elementos que se van a probar y contar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos de <paramref name="source" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve los elementos de la secuencia especificada o el valor predeterminado del parámetro de tipo en una colección singleton si la secuencia está vacía.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene el valor predeterminado para el tipo <paramref name="TSource" /> si <paramref name="source" /> está vacío; de lo contrario, es <paramref name="source" />.</returns>
      <param name="source">Secuencia para la que se va a devolver un valor predeterminado si está vacía.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>Devuelve los elementos de la secuencia especificada o el valor especificado en una colección singleton si la secuencia está vacía.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene <paramref name="defaultValue" /> si <paramref name="source" /> está vacío; de lo contrario, <paramref name="source" />.</returns>
      <param name="source">Secuencia para la que se va a devolver el valor especificado si está vacía.</param>
      <param name="defaultValue">Valor que se va a devolver si la secuencia está vacía.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve diversos elementos de una secuencia utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos distintos de la secuencia de origen.</returns>
      <param name="source">Secuencia de la que se van a quitar los elementos duplicados.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Devuelve diversos elementos de una secuencia utilizando un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos distintos de la secuencia de origen.</returns>
      <param name="source">Secuencia de la que se van a quitar los elementos duplicados.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Devuelve el elemento situado en un índice especificado de una secuencia.</summary>
      <returns>El elemento situado en la posición especificada de la secuencia de origen.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> es menor que 0 o mayor o igual que el número de elementos de <paramref name="source" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Devuelve el elemento situado en un índice especificado de una secuencia o un valor predeterminado si el índice está fuera del intervalo.</summary>
      <returns>default(<paramref name="TSource" />) si el índice está fuera de los límites de la secuencia de origen; de lo contrario, el elemento situado en la posición especificada de la secuencia de origen.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Empty``1">
      <summary>Devuelve un <see cref="T:System.Collections.Generic.IEnumerable`1" /> vacío que tiene el argumento de tipo especificado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> vacío cuyo argumento de tipo es <paramref name="TResult" />.</returns>
      <typeparam name="TResult">Tipo que se va a asignar al parámetro de tipo del <see cref="T:System.Collections.Generic.IEnumerable`1" /> genérico devuelto.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la diferencia de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>Una secuencia que contiene la diferencia de conjuntos de los elementos de dos secuencias.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que no se encuentren en <paramref name="second" /> se van a devolver.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que también aparecen en la primera secuencia harán que se quiten esos elementos de la secuencia devuelta.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la diferencia de conjuntos de dos secuencias utilizando el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>Una secuencia que contiene la diferencia de conjuntos de los elementos de dos secuencias.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que no se encuentren en <paramref name="second" /> se van a devolver.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que también aparecen en la primera secuencia harán que se quiten esos elementos de la secuencia devuelta.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el primer elemento de una secuencia.</summary>
      <returns>El primer elemento de la secuencia especificada.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se va a devolver el primer elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el primer elemento de una secuencia que satisface una condición especificada.</summary>
      <returns>El primer elemento de la secuencia que pasa la prueba de la función de predicado especificada.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el primer elemento de una secuencia o un valor predeterminado si la secuencia no contiene elementos.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío; de lo contrario, el primer elemento de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se va a devolver el primer elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el primer elemento de la secuencia que satisface una condición o un valor predeterminado si no se encuentra dicho elemento.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío o si ningún elemento pasa la prueba especificada en <paramref name="predicate" />; de lo contrario, el primer elemento de <paramref name="source" /> que pasa la prueba especificada en <paramref name="predicate" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# o IEnumerable(Of IGrouping(Of TKey, TSource)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una secuencia de objetos y una clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y compara las claves usando un comparador indicado.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# o IEnumerable(Of IGrouping(Of TKey, TSource)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una colección de objetos y una clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y proyecta los elementos de cada grupo utilizando una función determinada.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# o IEnumerable(Of IGrouping(Of TKey, TElement)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una colección de objetos de tipo <paramref name="TElement" /> y una clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia conforme a una función del selector de claves.Las claves se comparan utilizando un comparador y los elementos de cada grupo se proyectan utilizando una función especificada.</summary>
      <returns>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# o IEnumerable(Of IGrouping(Of TKey, TElement)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una colección de objetos de tipo <paramref name="TElement" /> y una clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Los elementos de cada grupo se proyectan utilizando una función determinada.</summary>
      <returns>Colección de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Los valores de las claves se comparan utilizando un comparador especificado y los elementos de cada grupo se proyectan utilizando una función especificada.</summary>
      <returns>Colección de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.</summary>
      <returns>Colección de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Las claves se comparan utilizando un comparador especificado.</summary>
      <returns>Colección de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
      <summary>Establece una correlación entre los elementos de dos secuencias en función de la igualdad de sus claves y agrupa los resultados.El comparador de igualdad predeterminado se usa para comparar claves.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear el elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda secuencia.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Establece una correlación entre los elementos de dos secuencias basándose en la igualdad de clave y agrupa los resultados.Se usa un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear el elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a aplicar un algoritmo hash y a comparar las claves.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la intersección de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>Una secuencia que contiene los elementos que forman la intersección de conjuntos de dos secuencias.</returns>
      <param name="first">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se van a devolver los distintos elementos que también aparecen en <paramref name="second" />.</param>
      <param name="second">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se van a devolver los distintos elementos que también aparecen en la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la intersección de conjuntos de dos secuencias utilizando el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>Una secuencia que contiene los elementos que forman la intersección de conjuntos de dos secuencias.</returns>
      <param name="first">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se van a devolver los distintos elementos que también aparecen en <paramref name="second" />.</param>
      <param name="second">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se van a devolver los distintos elementos que también aparecen en la primera secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
      <summary>Establece una correlación entre los elementos de dos secuencias en función de la coincidencia de sus claves.El comparador de igualdad predeterminado se usa para comparar claves.</summary>
      <returns>Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> que tiene elementos de tipo <paramref name="TResult" /> que se obtienen al realizar una combinación interna de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Establece una correlación entre los elementos de dos secuencias en función de la coincidencia de sus claves.Se usa un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
      <returns>Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> que tiene elementos de tipo <paramref name="TResult" /> que se obtienen al realizar una combinación interna de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a aplicar un algoritmo hash y a comparar las claves.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el último elemento de una secuencia.</summary>
      <returns>El valor de la última posición de la secuencia de origen.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver el último elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el último elemento de una secuencia que satisface una condición especificada.</summary>
      <returns>El último elemento de la secuencia que pasa la prueba de la función de predicado especificada.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el último elemento de una secuencia o un valor predeterminado si la secuencia no contiene elementos.</summary>
      <returns>default (<paramref name="TSource" />) si la secuencia de origen está vacía; de lo contrario, el último elemento de <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver el último elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el último elemento de una secuencia que satisface una condición o un valor predeterminado si no se encuentra dicho elemento.</summary>
      <returns>default (<paramref name="TSource" />) si la secuencia está vacía o si ningún elemento pasa la prueba de la función de predicado; en caso contrario, devuelve el último elemento que pasa la prueba de la función de predicado.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve un valor <see cref="T:System.Int64" /> que representa el número total de elementos de una secuencia.</summary>
      <returns>El número de elementos de la secuencia de origen.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos que se van a contar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos excede <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve un valor <see cref="T:System.Int64" /> que representa el número de elementos de una secuencia que satisfacen una condición.</summary>
      <returns>Un número que representa cuántos elementos de la secuencia especificada satisfacen la condición de la función de predicado.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos que se van a contar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos coincidentes excede <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Decimal" />.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Double" />.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Int32" />.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Int64" />.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Decimal&gt; en C# o Nullable(Of Decimal) en Visual Basic que se corresponde con el valor máximo de la secuencia. </returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Double&gt; en C# o Nullable(Of Double) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int32&gt; en C# o Nullable(Of Int32) en Visual Basic que se corresponde con el valor máximo de la secuencia. </returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int64&gt; en C# o Nullable(Of Int64) en Visual Basic que se corresponde con el valor máximo de la secuencia. </returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Single&gt; en C# o Nullable(Of Single) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Devuelve el valor máximo de una secuencia de valores <see cref="T:System.Single" />.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuyo valor máximo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el valor máximo de una secuencia genérica.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Decimal" /> máximo.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Double" /> máximo.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int32" /> máximo.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int64" /> máximo.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Decimal" /> máximo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Decimal&gt; en C# o Nullable(Of Decimal) en Visual Basic que se corresponde con el valor máximo de la secuencia. </returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Double" /> máximo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Double&gt; en C# o Nullable(Of Double) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int32" /> máximo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int32&gt; en C# o Nullable(Of Int32) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int64" /> máximo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int64&gt; en C# o Nullable(Of Int64) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Single" /> máximo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Single&gt; en C# o Nullable(Of Single) en Visual Basic que se corresponde con el valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Single" /> máximo.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia genérica y devuelve el valor máximo resultante.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Devuelve el valor mínimo de una secuencia de valores<see cref="T:System.Decimal" />.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Devuelve el valor mínimo de una secuencia de valores<see cref="T:System.Double" />.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Devuelve el valor mínimo de una secuencia de valores<see cref="T:System.Int32" />.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Devuelve el valor mínimo de una secuencia de valores<see cref="T:System.Int64" />.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Devuelve el valor mínimo de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Decimal&gt; en C# o Nullable(Of Decimal) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Devuelve el valor mínimo de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Double&gt; en C# o Nullable(Of Double) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Devuelve el valor mínimo de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int32&gt; en C# o Nullable(Of Int32) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Devuelve el valor mínimo de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int64&gt; en C# o Nullable(Of Int64) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Devuelve el valor mínimo de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Single&gt; en C# o Nullable(Of Single) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Devuelve el valor mínimo de una secuencia de valores<see cref="T:System.Single" />.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuyo valor mínimo se va a determinar.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el valor mínimo de una secuencia genérica.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Decimal" /> mínimo.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Double" /> mínimo.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int32" /> mínimo.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int64" /> mínimo.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Decimal" /> mínimo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Decimal&gt; en C# o Nullable(Of Decimal) en Visual Basic que se corresponde con el valor mínimo de la secuencia. </returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Double" /> mínimo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Double&gt; en C# o Nullable(Of Double) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int32" /> mínimo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int32&gt; en C# o Nullable(Of Int32) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Int64" /> mínimo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Int64&gt; en C# o Nullable(Of Int64) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Single" /> mínimo que puede ser NULL.</summary>
      <returns>Valor de tipo Nullable&lt;Single&gt; en C# o Nullable(Of Single) en Visual Basic que se corresponde con el valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia y devuelve el valor <see cref="T:System.Single" /> mínimo.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Invoca una función de transformación en cada elemento de una secuencia genérica y devuelve el valor mínimo resultante.</summary>
      <returns>El valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)">
      <summary>Filtra los elementos de <see cref="T:System.Collections.IEnumerable" /> en función de un tipo especificado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada de tipo <paramref name="TResult" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.IEnumerable" /> cuyos elementos se van a filtrar.</param>
      <typeparam name="TResult">El tipo según el cual se van a filtrar los elementos de la secuencia.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Ordena de manera ascendente los elementos de una secuencia en función de una clave.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Ordena de manera ascendente los elementos de una secuencia utilizando un comparador especificado.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Ordena de manera descendente los elementos de una secuencia en función de una clave.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Ordena de manera descendente los elementos de una secuencia utilizando un comparador especificado.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)">
      <summary>Genera una secuencia de números enteros en un intervalo especificado.</summary>
      <returns>IEnumerable&lt;Int32&gt; en C# o IEnumerable(Of Int32) en Visual Basic que contiene un intervalo de números enteros secuenciales.</returns>
      <param name="start">Valor del primer entero de la secuencia.</param>
      <param name="count">Número de enteros secuenciales que se van a generar.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> es menor que 0.-O bien-<paramref name="start" /> + <paramref name="count" /> -1 en mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)">
      <summary>Genera una secuencia que contiene un valor repetido.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene un valor repetido.</returns>
      <param name="element">El valor que se va a repetir.</param>
      <param name="count">El número de veces que se va a repetir el valor en la secuencia generada.</param>
      <typeparam name="TResult">El tipo de valor que se va a repetir en la secuencia de resultado.</typeparam>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> es menor que 0.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Invierte el orden de los elementos de una secuencia.</summary>
      <returns>Una secuencia cuyos elementos se corresponden en orden inverso con los de la secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a invertir.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Proyecta cada elemento de una secuencia en un nuevo formulario.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar una función de transformación en cada elemento de <paramref name="source" />.</returns>
      <param name="source">Secuencia de valores sobre la que se va a invocar una función de transformación.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
      <summary>Proyecta cada elemento de una secuencia en un nuevo formulario incorporando el índice del elemento.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar una función de transformación en cada elemento de <paramref name="source" />.</returns>
      <param name="source">Secuencia de valores sobre la que se va a invocar una función de transformación.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento de origen; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>Proyecta cada elemento de una secuencia en <see cref="T:System.Collections.Generic.IEnumerable`1" />, reduce las secuencias resultantes en una única secuencia e invoca una función del selector de resultados en cada elemento.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar la función de transformación uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> y de asignar a continuación cada uno de los elementos de la secuencia y sus elementos de origen correspondientes a un elemento de resultado.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="collectionSelector">Función de transformación que se va a aplicar a cada elemento de la secuencia de entrada.</param>
      <param name="resultSelector">Función de transformación que se va a aplicar a cada elemento de la secuencia intermedia.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Tipo de los elementos intermedios recopilados por <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="collectionSelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
      <summary>Proyecta cada elemento de una secuencia en una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> y reduce las secuencias resultantes en una secuencia.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar la función de transformación uno a varios en cada elemento de la secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia devueltos por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
      <summary>Proyecta cada elemento de una secuencia en <see cref="T:System.Collections.Generic.IEnumerable`1" />, reduce las secuencias resultantes en una única secuencia e invoca una función del selector de resultados en cada elemento.El índice de cada elemento de origen se utiliza en el formulario proyectado intermedio de ese elemento.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar la función de transformación uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> y de asignar a continuación cada uno de los elementos de la secuencia y sus elementos de origen correspondientes a un elemento de resultado.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="collectionSelector">Función de transformación que se va a aplicar a cada elemento de origen; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <param name="resultSelector">Función de transformación que se va a aplicar a cada elemento de la secuencia intermedia.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">Tipo de los elementos intermedios recopilados por <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="collectionSelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
      <summary>Proyecta cada elemento de una secuencia en una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> y reduce las secuencias resultantes en una secuencia.El índice de cada elemento de origen se utiliza en el formulario proyectado de ese elemento.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos son el resultado de invocar la función de transformación uno a varios en cada elemento de una secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento de origen; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia devueltos por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Determina si dos secuencias son iguales; para ello, se comparan sus elementos mediante el comparador de igualdad predeterminado para su tipo.</summary>
      <returns>Es true si las dos secuencias de origen tienen la misma longitud y sus elementos correspondientes son iguales según el comparador de igualdad predeterminado para su tipo; de lo contrario, es false.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a comparar con <paramref name="second" />.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a comparar con la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Determina si dos secuencias son iguales; para ello, compara sus elementos usando una interfaz <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificada.</summary>
      <returns>Es true si las dos secuencias de origen tienen la misma longitud y sus elementos correspondientes son iguales según <paramref name="comparer" />; de lo contrario, es false.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a comparar con <paramref name="second" />.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a comparar con la primera secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar para comparar elementos.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> tiene más de un elemento.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el único elemento de una secuencia y produce una excepción si no hay exactamente un elemento en la secuencia.</summary>
      <returns>El único elemento de la secuencia de entrada.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver el único elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de entrada contiene varios elementos.-O bien-La secuencia de entrada está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el único elemento de una secuencia que cumpla la condición especificada y produce una excepción si más de un elemento la cumple.</summary>
      <returns>El único elemento de la secuencia de entrada que satisface una condición.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se va a devolver un único elemento.</param>
      <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-Varios elementos satisfacen la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Devuelve el único elemento de una secuencia o un valor predeterminado si la secuencia está vacía; este método produce una excepción si hay más de un elemento en la secuencia.</summary>
      <returns>El único elemento de la secuencia de entrada o default(<paramref name="TSource" />) si la secuencia no contiene ningún elemento.</returns>
      <param name="source">Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se va a devolver el único elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de entrada contiene varios elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve el único elemento de una secuencia que cumpla la condición especificada, o bien, un valor predeterminado si ese elemento no existe; este método produce una excepción si varios elementos cumplen la condición.</summary>
      <returns>El único elemento de la secuencia de entrada que satisface la condición o default(<paramref name="TSource" />) si no se encuentra dicho elemento.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se va a devolver un único elemento.</param>
      <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Omite un número especificado de elementos en una secuencia y, a continuación, devuelve los elementos restantes.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos que hay después del índice especificado en la secuencia de entrada.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se van a devolver los elementos.</param>
      <param name="count">Número de elementos que se van a omitir antes de devolver los elementos restantes.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Omite los elementos de una secuencia siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada comenzando por el primer elemento de la serie lineal que no pasa la prueba especificada en <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se van a devolver los elementos.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Omite los elementos de una secuencia siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.El índice del elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada comenzando por el primer elemento de la serie lineal que no pasa la prueba especificada en <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> del que se van a devolver los elementos.</param>
      <param name="predicate">Función que va a probar cada elemento de origen para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" /> que se obtiene al invocar una función de transformación en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores que se usan para calcular una suma.</param>
      <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>Devuelve un número especificado de elementos contiguos desde el principio de una secuencia.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene el número especificado de elementos desde el principio de la secuencia de entrada.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="count">Número de elementos que se van a devolver.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Devuelve los elementos de una secuencia en tanto que el valor de una condición especificada sea true.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada que se encuentran antes del elemento que no supera la prueba.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Devuelve los elementos de una secuencia en tanto que el valor de una condición especificada sea true.El índice del elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada que se encuentran antes del elemento que no supera la prueba.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="predicate">Función que va a probar cada elemento de origen para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden ascendentes con arreglo a una clave.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden ascendente utilizando un comparador especificado.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden descendente con arreglo a una clave.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden descendente utilizando un comparador especificado.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Crea una matriz a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>Una matriz que contiene los elementos de la secuencia de entrada.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear una matriz.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Crea una clase <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves especificada.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene claves y valores.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.-O bien-<paramref name="keySelector" /> genera una clave cuyo valor es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> genera claves duplicadas para dos elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crea un objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves y el comparador de claves especificados.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene claves y valores.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.-O bien-<paramref name="keySelector" /> genera una clave cuyo valor es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> genera claves duplicadas para dos elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Crea un objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según el selector de claves especificado y las funciones del selector de elementos.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo del valor devuelto por <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.-O bien-<paramref name="keySelector" /> genera una clave cuyo valor es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> genera claves duplicadas para dos elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crea un objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves especificada, un comparador y una función del selector de elementos.</summary>
      <returns>Objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo del valor devuelto por <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.-O bien-<paramref name="keySelector" /> genera una clave cuyo valor es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="keySelector" /> genera claves duplicadas para dos elementos.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Crea un objeto <see cref="T:System.Collections.Generic.List`1" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.List`1" /> que contiene elementos de la secuencia de entrada.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Collections.Generic.List`1" />.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>Crea una clase <see cref="T:System.Linq.Lookup`2" /> a partir de una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves especificada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Lookup`2" /> que contiene claves y valores.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crea un objeto <see cref="T:System.Linq.Lookup`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves y el comparador de claves especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Lookup`2" /> que contiene claves y valores.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>Crea un objeto <see cref="T:System.Linq.Lookup`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según el selector de claves especificado y las funciones del selector de elementos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Lookup`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo del valor devuelto por <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Crea un objeto <see cref="T:System.Linq.Lookup`2" /> a partir de un objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> según una función del selector de claves especificada, un comparador y una función del selector de elementos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Lookup`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
      <param name="source">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> a partir del cual se va a crear <see cref="T:System.Linq.Lookup`2" />.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo del valor devuelto por <paramref name="elementSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la unión de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos distintos forman el primer conjunto de la unión.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos distintos forman el segundo conjunto de la unión.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la unión de conjuntos de dos secuencias a través de un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
      <param name="first">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos distintos forman el primer conjunto de la unión.</param>
      <param name="second">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos distintos forman el segundo conjunto de la unión.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a comparar los valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>Filtra una secuencia de valores en función de un predicado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada que satisfacen la condición.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a filtrar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
      <summary>Filtra una secuencia de valores en función de un predicado.El índice de cada elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los elementos de la secuencia de entrada que satisfacen la condición.</returns>
      <param name="source">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a filtrar.</param>
      <param name="predicate">Función que va a probar cada elemento de origen para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
      <summary>Combina dos secuencias utilizando la función de predicado especificada.</summary>
      <returns>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene elementos combinados de las dos secuencias de entrada.</returns>
      <param name="first">Primera secuencia que se va a combinar.</param>
      <param name="second">Segunda secuencia que se va a combinar.</param>
      <param name="resultSelector">Función que especifica cómo combinar los elementos de las dos secuencias.</param>
      <typeparam name="TFirst">Tipo de los elementos de la primera secuencia de entrada.</typeparam>
      <typeparam name="TSecond">Tipo de los elementos de la segunda secuencia de entrada.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia de resultados.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> o <paramref name="second" /> es null.</exception>
    </member>
    <member name="T:System.Linq.EnumerableExecutor">
      <summary>Representa un árbol de expresión y proporciona la funcionalidad para ejecutar este árbol después de rescribirlo.</summary>
    </member>
    <member name="M:System.Linq.EnumerableExecutor.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.EnumerableExecutor" />.</summary>
    </member>
    <member name="T:System.Linq.EnumerableExecutor`1">
      <summary>Representa un árbol de expresión y proporciona la funcionalidad para ejecutar este árbol después de rescribirlo.</summary>
      <typeparam name="T">Tipo de datos del valor que es el resultado de ejecutar el árbol de expresión.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableExecutor`1.#ctor(System.Linq.Expressions.Expression)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.EnumerableExecutor`1" />.</summary>
      <param name="expression">Árbol de expresión que se va a asociar a la nueva instancia.</param>
    </member>
    <member name="T:System.Linq.EnumerableQuery">
      <summary>Representa una interfaz <see cref="T:System.Collections.IEnumerable" /> como un origen de datos de <see cref="T:System.Linq.EnumerableQuery" />. </summary>
    </member>
    <member name="M:System.Linq.EnumerableQuery.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.EnumerableQuery" />.</summary>
    </member>
    <member name="T:System.Linq.EnumerableQuery`1">
      <summary>Representa una colección <see cref="T:System.Collections.Generic.IEnumerable`1" /> como origen de los datos <see cref="T:System.Linq.IQueryable`1" />.</summary>
      <typeparam name="T">Tipo de los datos de la colección.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.EnumerableQuery`1" /> y la asocia a una colección <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <param name="enumerable">Colección que se va a asociar a la nueva instancia.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.#ctor(System.Linq.Expressions.Expression)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.EnumerableQuery`1" /> y la asocia a un árbol de expresión.</summary>
      <param name="expression">Árbol de expresión que se va a asociar a la nueva instancia.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
      <summary>Devuelve un enumerador que puede recorrer en iteración la colección <see cref="T:System.Collections.Generic.IEnumerable`1" /> asociada o, si es NULL, la colección que es el resultado de modificar el árbol de expresión asociado como una consulta en un origen de datos <see cref="T:System.Collections.Generic.IEnumerable`1" /> y de ejecutarlo.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración el origen de datos asociado.</returns>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que puede recorrer en iteración la colección <see cref="T:System.Collections.Generic.IEnumerable`1" /> asociada o, si es NULL, la colección que es el resultado de modificar el árbol de expresión asociado como una consulta en un origen de datos <see cref="T:System.Collections.Generic.IEnumerable`1" /> y de ejecutarlo.</summary>
      <returns>Enumerador que se puede utilizar para recorrer en iteración el origen de datos asociado.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#ElementType">
      <summary>Obtiene el tipo de datos de la colección que esta instancia representa.</summary>
      <returns>Tipo de datos de la colección que esta instancia representa.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#Expression">
      <summary>Obtiene el árbol de expresión que está asociado o que representa a esta instancia.</summary>
      <returns>Árbol de expresión que está asociado o que representa a esta instancia.</returns>
    </member>
    <member name="P:System.Linq.EnumerableQuery`1.System#Linq#IQueryable#Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a esta instancia.</summary>
      <returns>Proveedor de consultas que está asociado a esta instancia.</returns>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Crea un nuevo objeto <see cref="T:System.Linq.EnumerableQuery`1" /> y lo asocia a un árbol de expresión especificado que representa una colección <see cref="T:System.Linq.IQueryable`1" /> de datos.</summary>
      <returns>Objeto EnumerableQuery asociado a <paramref name="expression" />.</returns>
      <param name="expression">Árbol de expresión que se va a ejecutar.</param>
      <typeparam name="S">Tipo de datos de la colección que <paramref name="expression" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Crea un nuevo objeto <see cref="T:System.Linq.EnumerableQuery`1" /> y lo asocia a un árbol de expresión especificado que representa una colección <see cref="T:System.Linq.IQueryable" /> de datos.</summary>
      <returns>Objeto <see cref="T:System.Linq.EnumerableQuery`1" /> asociado a <paramref name="expression" />.</returns>
      <param name="expression">Árbol de expresión que representa una colección <see cref="T:System.Linq.IQueryable" /> de datos.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta una expresión después de modificarla para llamar a métodos <see cref="T:System.Linq.Enumerable" /> en lugar de a métodos <see cref="T:System.Linq.Queryable" /> en cualquier origen de datos enumerable que no se pueda consultar mediante métodos <see cref="T:System.Linq.Queryable" />.</summary>
      <returns>Valor que es el resultado de ejecutar <paramref name="expression" />.</returns>
      <param name="expression">Árbol de expresión que se va a ejecutar.</param>
      <typeparam name="S">Tipo de datos de la colección que <paramref name="expression" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.System#Linq#IQueryProvider#Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta una expresión después de modificarla para llamar a métodos <see cref="T:System.Linq.Enumerable" /> en lugar de a métodos <see cref="T:System.Linq.Queryable" /> en cualquier origen de datos enumerable que no se pueda consultar mediante métodos <see cref="T:System.Linq.Queryable" />.</summary>
      <returns>Valor que es el resultado de ejecutar <paramref name="expression" />.</returns>
      <param name="expression">Árbol de expresión que se va a ejecutar.</param>
    </member>
    <member name="M:System.Linq.EnumerableQuery`1.ToString">
      <summary>Devuelve una representación textual de la colección enumerable o, si es null, del árbol de expresión asociado a esta instancia.</summary>
      <returns>Representación textual de la colección enumerable o, si es null, del árbol de expresión asociado a esta instancia.</returns>
    </member>
    <member name="T:System.Linq.IGrouping`2">
      <summary>Representa una colección de objetos que tienen una clave común.</summary>
      <typeparam name="TKey">Tipo de la clave de <see cref="T:System.Linq.IGrouping`2" />.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
      <typeparam name="TElement">Tipo de los valores de <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
    </member>
    <member name="P:System.Linq.IGrouping`2.Key">
      <summary>Obtiene la clave de <see cref="T:System.Linq.IGrouping`2" />.</summary>
      <returns>Clave de <see cref="T:System.Linq.IGrouping`2" />.</returns>
    </member>
    <member name="T:System.Linq.ILookup`2">
      <summary>Define un indizador, propiedad de tamaño y método de búsqueda booleano para las estructuras de datos que asignan las claves a las secuencias de valores <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      <typeparam name="TKey">El tipo de las claves de <see cref="T:System.Linq.ILookup`2" />.</typeparam>
      <typeparam name="TElement">El tipo de los elementos de las secuencias <see cref="T:System.Collections.Generic.IEnumerable`1" /> que conforman los valores de <see cref="T:System.Linq.ILookup`2" />.</typeparam>
    </member>
    <member name="M:System.Linq.ILookup`2.Contains(`0)">
      <summary>Determina si una clave especificada existe en <see cref="T:System.Linq.ILookup`2" />.</summary>
      <returns>true si <paramref name="key" /> se encuentra en el <see cref="T:System.Linq.ILookup`2" />; de lo contrario, es false.</returns>
      <param name="key">Clave que se va a buscar en <see cref="T:System.Linq.ILookup`2" />.</param>
    </member>
    <member name="P:System.Linq.ILookup`2.Count">
      <summary>Obtiene el número de pares de colecciones de claves y valores en el objeto <see cref="T:System.Linq.ILookup`2" />.</summary>
      <returns>Número de pares de colecciones de claves y valores en el objeto <see cref="T:System.Linq.ILookup`2" />.</returns>
    </member>
    <member name="P:System.Linq.ILookup`2.Item(`0)">
      <summary>Obtiene la secuencia de valores <see cref="T:System.Collections.Generic.IEnumerable`1" /> indizada por una clave concreta.</summary>
      <returns>Secuencia de valores <see cref="T:System.Collections.Generic.IEnumerable`1" /> indizada por la clave especificada.</returns>
      <param name="key">Clave de la secuencia deseada de valores.</param>
    </member>
    <member name="T:System.Linq.IOrderedEnumerable`1">
      <summary>Representa una secuencia ordenada.</summary>
      <typeparam name="TElement">Tipo de los elementos de la secuencia.</typeparam>
    </member>
    <member name="M:System.Linq.IOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
      <summary>Realiza una ordenación subsiguiente de los elementos de un objeto <see cref="T:System.Linq.IOrderedEnumerable`1" /> según una clave.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedEnumerable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="keySelector">
        <see cref="T:System.Func`2" /> que se usa para extraer la clave de cada elemento.</param>
      <param name="comparer">Comparador <see cref="T:System.Collections.Generic.IComparer`1" /> utilizado para comparar las claves de cara a su colocación en la secuencia devuelta.</param>
      <param name="descending">Es true para ordenar los elementos en orden descendente; es false para ordenar los elementos en orden ascendente.</param>
      <typeparam name="TKey">Tipo de la clave generada por <paramref name="keySelector" />.</typeparam>
    </member>
    <member name="T:System.Linq.IOrderedQueryable">
      <summary>Representa el resultado de una operación de ordenación.</summary>
    </member>
    <member name="T:System.Linq.IOrderedQueryable`1">
      <summary>Representa el resultado de una operación de ordenación.</summary>
      <typeparam name="T">Tipo del contenido del origen de datos.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Linq.IQueryable">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se especifica el tipo de los datos.</summary>
    </member>
    <member name="P:System.Linq.IQueryable.ElementType">
      <summary>Obtiene el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo de los elementos que se devuelven cuando se ejecuta el árbol de expresión asociado a este objeto.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Expression">
      <summary>Obtiene el árbol de expresión que está asociado a la instancia de <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que está asociado a esta instancia de <see cref="T:System.Linq.IQueryable" />.</returns>
    </member>
    <member name="P:System.Linq.IQueryable.Provider">
      <summary>Obtiene el proveedor de consultas que está asociado a este origen de datos.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryProvider" /> que está asociado a este origen de datos.</returns>
    </member>
    <member name="T:System.Linq.IQueryable`1">
      <summary>Proporciona funcionalidad para evaluar consultas con respecto a un origen de datos concreto en el que se conoce el tipo de los datos.</summary>
      <typeparam name="T">El tipo de los datos del origen de datos.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see [2678dc63-c7f9-4590-9ddc-0a4df684d42e].</typeparam>
    </member>
    <member name="T:System.Linq.IQueryProvider">
      <summary>Define los métodos para crear y ejecutar las consultas descritas por un objeto <see cref="T:System.Linq.IQueryable" />.</summary>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery``1(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TElement">Tipo de los elementos del objeto <see cref="T:System.Linq.IQueryable`1" /> que se devuelve.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.CreateQuery(System.Linq.Expressions.Expression)">
      <summary>Construye un objeto <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que puede evaluar la consulta representada por el árbol de expresión especificado.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute``1(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta fuertemente tipada representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
      <typeparam name="TResult">Tipo del valor que es el resultado de ejecutar la consulta.</typeparam>
    </member>
    <member name="M:System.Linq.IQueryProvider.Execute(System.Linq.Expressions.Expression)">
      <summary>Ejecuta la consulta representada por el árbol de expresión especificado.</summary>
      <returns>Valor que es el resultado de ejecutar la consulta especificada.</returns>
      <param name="expression">Árbol de expresión que representa una consulta de LINQ.</param>
    </member>
    <member name="T:System.Linq.Lookup`2">
      <summary>Representa una colección de claves asignadas a uno o varios valores.</summary>
      <typeparam name="TKey">El tipo de las claves de <see cref="T:System.Linq.Lookup`2" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada valor <see cref="T:System.Collections.Generic.IEnumerable`1" /> en <see cref="T:System.Linq.Lookup`2" />.</typeparam>
    </member>
    <member name="M:System.Linq.Lookup`2.ApplyResultSelector``1(System.Func{`0,System.Collections.Generic.IEnumerable{`1},``0})">
      <summary>Aplica una función de transformación a cada clave y sus valores asociados, y devuelve los resultados.</summary>
      <returns>Colección que contiene un valor para cada par de colecciones de claves y valores en <see cref="T:System.Linq.Lookup`2" />.</returns>
      <param name="resultSelector">Función para proyectar un valor de resultado de cada clave y sus valores asociados.</param>
      <typeparam name="TResult">Tipo de los valores de resultado generados por <paramref name="resultSelector" />.</typeparam>
    </member>
    <member name="M:System.Linq.Lookup`2.Contains(`0)">
      <summary>Determina si una clave especificada existe en <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>true si <paramref name="key" /> se encuentra en el <see cref="T:System.Linq.Lookup`2" />; de lo contrario, es false.</returns>
      <param name="key">Clave que se va a buscar en <see cref="T:System.Linq.Lookup`2" />.</param>
    </member>
    <member name="P:System.Linq.Lookup`2.Count">
      <summary>Obtiene el número de pares de colecciones de claves y valores en el objeto <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>Número de pares de colecciones de claves y valores en el objeto <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="M:System.Linq.Lookup`2.GetEnumerator">
      <summary>Devuelve un enumerador genérico que recorre en iteración <see cref="T:System.Linq.Lookup`2" />.</summary>
      <returns>Enumerador para <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="P:System.Linq.Lookup`2.Item(`0)">
      <summary>Obtiene la colección de valores indizados por la clave especificada.</summary>
      <returns>Colección de valores indizados por la clave especificada.</returns>
      <param name="key">Clave de la colección de valores deseada.</param>
    </member>
    <member name="M:System.Linq.Lookup`2.System#Collections#IEnumerable#GetEnumerator">
      <summary>Devuelve un enumerador que recorre en iteración <see cref="T:System.Linq.Lookup`2" />.Esta clase no se puede heredar.</summary>
      <returns>Enumerador para <see cref="T:System.Linq.Lookup`2" />.</returns>
    </member>
    <member name="T:System.Linq.Queryable">
      <summary>Proporciona un conjunto de métodos static (Shared en Visual Basic) para consultar estructuras de datos que implementan <see cref="T:System.Linq.IQueryable`1" />.</summary>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})">
      <summary>Aplica una función de acumulador a una secuencia.</summary>
      <returns>Valor final del acumulador.</returns>
      <param name="source">Secuencia a la que se va a agregar.</param>
      <param name="func">Función de acumulador que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})">
      <summary>Aplica una función de acumulador a una secuencia.El valor de inicialización especificado se utiliza como valor de inicio del acumulador.</summary>
      <returns>Valor final del acumulador.</returns>
      <param name="source">Secuencia a la que se va a agregar.</param>
      <param name="seed">Valor de inicio del acumulador.</param>
      <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
      <summary>Aplica una función de acumulador a una secuencia.El valor de inicialización especificado se utiliza como valor inicial del acumulador y la función especificada se utiliza para seleccionar el valor resultante.</summary>
      <returns>El valor final del acumulador transformado.</returns>
      <param name="source">Secuencia a la que se va a agregar.</param>
      <param name="seed">Valor de inicio del acumulador.</param>
      <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
      <param name="selector">Función que va a transformar el valor final del acumulador en el valor del resultado.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
      <typeparam name="TResult">Tipo del valor resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="func" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Determina si todos los elementos de una secuencia satisfacen una condición.</summary>
      <returns>true si todos los elementos de la secuencia de origen pasan la prueba del predicado especificado o si la secuencia está vacía; de lo contrario, false.</returns>
      <param name="source">Secuencia en cuyos elementos se va a comprobar una condición.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})">
      <summary>Determina si una secuencia contiene elementos.</summary>
      <returns>true si la secuencia de salida contiene elementos; de lo contrario, false.</returns>
      <param name="source">Secuencia que se va a comprobar si está vacía.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Determina si algún elemento de una secuencia satisface una condición.</summary>
      <returns>true si algún elemento de la secuencia de salida pasa la prueba en el predicado especificado; de lo contrario, false.</returns>
      <param name="source">Secuencia en cuyos elementos se va a comprobar una condición.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>Convierte una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> genérica en una interfaz <see cref="T:System.Linq.IQueryable`1" /> genérica.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que representa la secuencia de entrada.</returns>
      <param name="source">Secuencia que se va a convertir.</param>
      <typeparam name="TElement">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)">
      <summary>Convierte una interfaz <see cref="T:System.Collections.IEnumerable" /> en <see cref="T:System.Linq.IQueryable" />.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable" /> que representa la secuencia de entrada.</returns>
      <param name="source">Secuencia que se va a convertir.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="source" /> no implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> para algunos parámetros <paramref name="T" />.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia de origen está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" />.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuyo promedio se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia <paramref name="source" /> está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia <paramref name="source" /> está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia <paramref name="source" /> está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia <paramref name="source" /> está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>Promedio de la secuencia de valores o null si la secuencia <paramref name="source" /> está vacía o contiene solo valores null.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Calcula el promedio de una secuencia de valores <see cref="T:System.Single" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>El promedio de la secuencia de valores.</returns>
      <param name="source">Secuencia de valores cuyo promedio se va a calcular.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> no contiene elementos.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)">
      <summary>Convierte los elementos de <see cref="T:System.Linq.IQueryable" /> en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene cada elemento de la secuencia de origen que se ha convertido al tipo especificado.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable" /> que contiene los elementos que se van a convertir.</param>
      <typeparam name="TResult">Tipo al que se convierten los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidCastException">Un elemento de la secuencia no se puede convertir al tipo <paramref name="TResult" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Concatena dos secuencias.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos concatenados de las dos secuencias de entrada.</returns>
      <param name="source1">Primera secuencia que se va a concatenar.</param>
      <param name="source2">Secuencia que se va a concatenar con la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)">
      <summary>Determina si una secuencia contiene un elemento especificado utilizando el comparador de igualdad predeterminado.</summary>
      <returns>true si la secuencia de origen contiene un elemento que tiene el valor especificado; de lo contrario, false.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> en el que se va a buscar <paramref name="item" />.</param>
      <param name="item">Objeto que se va a buscar en la secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Determina si una secuencia contiene un elemento especificado utilizando un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> determinado.</summary>
      <returns>true si la secuencia de origen contiene un elemento que tiene el valor especificado; de lo contrario, false.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> en el que se va a buscar <paramref name="item" />.</param>
      <param name="item">Objeto que se va a buscar en la secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el número de elementos de una secuencia.</summary>
      <returns>El número de elementos de la secuencia de entrada.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos que se van a contar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos de <paramref name="source" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el número de elementos de la secuencia especificada que satisfacen una condición.</summary>
      <returns>El número de elementos de la secuencia que satisfacen la condición de la función de predicado.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos que se van a contar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos de <paramref name="source" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve los elementos de la secuencia especificada o el valor predeterminado del parámetro de tipo en una colección singleton si la secuencia está vacía.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene default(<paramref name="TSource" />) si <paramref name="source" /> está vacío; de lo contrario, <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> para el que se va a devolver un valor predeterminado si está vacío.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)">
      <summary>Devuelve los elementos de la secuencia especificada o el valor especificado en una colección singleton si la secuencia está vacía.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene <paramref name="defaultValue" /> si <paramref name="source" /> está vacío; de lo contrario, <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> para el que se va a devolver el valor especificado si está vacío.</param>
      <param name="defaultValue">Valor que se va a devolver si la secuencia está vacía.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve diversos elementos de una secuencia utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IQueryable`1" /> que contiene diversos elementos de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se van a quitar los elementos duplicados.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Devuelve diversos elementos de una secuencia utilizando un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IQueryable`1" /> que contiene diversos elementos de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se van a quitar los elementos duplicados.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Devuelve el elemento situado en un índice especificado de una secuencia.</summary>
      <returns>El elemento situado en la posición especificada de <paramref name="source" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> es menor que cero.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Devuelve el elemento situado en un índice especificado de una secuencia o un valor predeterminado si el índice está fuera del intervalo.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="index" /> está fuera de los límites de <paramref name="source" />; de lo contrario, el elemento situado en la posición especificada de <paramref name="source" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la diferencia de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene la diferencia de conjuntos de las dos secuencias.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos que no se encuentren en <paramref name="source2" /> se van a devolver.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que se encuentren también en la primera secuencia no aparecerán en la secuencia devuelta.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la diferencia de conjuntos de dos secuencias utilizando el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene la diferencia de conjuntos de las dos secuencias.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos que no se encuentren también en <paramref name="source2" /> se van a devolver.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos que se encuentren también en la primera secuencia no aparecerán en la secuencia devuelta.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el primer elemento de una secuencia.</summary>
      <returns>El primer elemento de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se va a devolver el primer elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el primer elemento de una secuencia que satisface una condición especificada.</summary>
      <returns>El primer elemento de <paramref name="source" /> que pasa la prueba de <paramref name="predicate" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el primer elemento de una secuencia o un valor predeterminado si la secuencia no contiene elementos.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío; de lo contrario, el primer elemento de <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se va a devolver el primer elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el primer elemento de una secuencia que satisface una condición especificada o un valor predeterminado si no se encuentra ningún elemento.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío o si ningún elemento pasa la prueba especificada en <paramref name="predicate" />; de lo contrario, el primer elemento de <paramref name="source" /> que pasa la prueba especificada en <paramref name="predicate" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# o IQueryable(Of IGrouping(Of TKey, TSource)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una secuencia de objetos y una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y compara las claves utilizando un comparador especificado.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; en C# o IQueryable(Of IGrouping(Of TKey, TSource)) en Visual Basic donde cada <see cref="T:System.Linq.IGrouping`2" /> contiene una secuencia de objetos y una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y proyecta los elementos de cada grupo utilizando una función determinada.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# o IQueryable(Of IGrouping(Of TKey, TElement)) en Visual Basic donde cada objeto <see cref="T:System.Linq.IGrouping`2" /> contiene una secuencia de objetos de tipo <paramref name="TElement" /> y una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia y proyecta los elementos de cada grupo utilizando una función especificada.Los valores de clave se comparan utilizando un comparador especificado.</summary>
      <returns>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; en C# o IQueryable(Of IGrouping(Of TKey, TElement)) en Visual Basic donde cada <see cref="T:System.Linq.IGrouping`2" /> contiene una secuencia de objetos de tipo <paramref name="TElement" /> y una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Los elementos de cada grupo se proyectan utilizando una función determinada.</summary>
      <returns>T:System.Linq.IQueryable`1 que tiene un argumento de tipo <paramref name="TResult" /> y donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Las claves se comparan utilizando un comparador especificado y los elementos de cada grupo se proyectan utilizando una función determinada.</summary>
      <returns>T:System.Linq.IQueryable`1 que tiene un argumento de tipo <paramref name="TResult" /> y donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="elementSelector">Función para asignar cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TElement">Tipo de los elementos de cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> o <paramref name="resultSelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.</summary>
      <returns>T:System.Linq.IQueryable`1 que tiene un argumento de tipo de <paramref name="TResult" /> y donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})">
      <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave.Las claves se comparan utilizando un comparador determinado.</summary>
      <returns>T:System.Linq.IQueryable`1 que tiene un argumento de tipo <paramref name="TResult" /> y donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a agrupar.</param>
      <param name="keySelector">Función para extraer la clave de cada elemento.</param>
      <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="resultSelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})">
      <summary>Establece una correlación entre los elementos de dos secuencias basándose en la igualdad de clave y agrupa los resultados.El comparador de igualdad predeterminado se usa para comparar claves.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear el elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda secuencia.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Establece una correlación entre los elementos de dos secuencias basándose en la igualdad de clave y agrupa los resultados.Se usa un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear el elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda secuencia.</param>
      <param name="comparer">Comparador que va a aplicar un algoritmo hash y a comparar las claves.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la intersección de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado para comparar los valores.</summary>
      <returns>Una secuencia que contiene la intersección de conjuntos de las dos secuencias.</returns>
      <param name="source1">Secuencia de la que se devuelven los distintos elementos que también aparecen en <paramref name="source2" />.</param>
      <param name="source2">Secuencia de la que se devuelven los elementos que también aparecen en la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la intersección de conjuntos de dos secuencias utilizando el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene la intersección de conjuntos de las dos secuencias.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> de la que se devuelven los distintos elementos que también aparecen en <paramref name="source2" />.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de la que se devuelven los distintos elementos que también aparecen en la primera secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
      <summary>Establece una correlación entre los elementos de dos secuencias en función de la coincidencia de sus claves.El comparador de igualdad predeterminado se usa para comparar claves.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IQueryable`1" /> que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación interna de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>Establece una correlación entre los elementos de dos secuencias en función de la coincidencia de sus claves.Se usa un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IQueryable`1" /> que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación interna de dos secuencias.</returns>
      <param name="outer">Primera secuencia que se va a combinar.</param>
      <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
      <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
      <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
      <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a aplicar un algoritmo hash y a comparar las claves.</param>
      <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
      <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
      <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
      <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="outer" /> o <paramref name="inner" /> o <paramref name="outerKeySelector" /> o <paramref name="innerKeySelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el último elemento de una secuencia.</summary>
      <returns>Valor de la última posición de <paramref name="source" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver el último elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el último elemento de una secuencia que satisface una condición especificada.</summary>
      <returns>Último elemento de <paramref name="source" /> que pasa la prueba especificada por <paramref name="predicate" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el último elemento de una secuencia o un valor predeterminado si la secuencia no contiene elementos.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío; de lo contrario, el último elemento de <paramref name="source" />.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver el último elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el último elemento de una secuencia que satisface una condición o un valor predeterminado si no se encuentra dicho elemento.</summary>
      <returns>default(<paramref name="TSource" />) si <paramref name="source" /> está vacío o si ningún elemento pasa la prueba de la función de predicado; de lo contrario, el último elemento de <paramref name="source" /> que pasa la prueba de la función de predicado.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver un elemento.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve un valor <see cref="T:System.Int64" /> que representa el número total de elementos de una secuencia.</summary>
      <returns>Número de elementos incluidos en <paramref name="source" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos que se van a contar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">Número de elementos incluidos excede <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve un valor <see cref="T:System.Int64" /> que representa el número de elementos de una secuencia que satisfacen una condición.</summary>
      <returns>El número de elementos de <paramref name="source" /> que satisfacen la condición de la función de predicado.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos que se van a contar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.OverflowException">El número de elementos coincidentes excede <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el valor máximo de un <see cref="T:System.Linq.IQueryable`1" /> genérico.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Invoca una función de proyección en cada elemento de un <see cref="T:System.Linq.IQueryable`1" /> genérico y devuelve el valor máximo resultante.</summary>
      <returns>El valor máximo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el valor mínimo de un <see cref="T:System.Linq.IQueryable`1" /> genérico.</summary>
      <returns>Valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Invoca una función de proyección en cada elemento de un <see cref="T:System.Linq.IQueryable`1" /> genérico y devuelve el valor mínimo resultante.</summary>
      <returns>Valor mínimo de la secuencia.</returns>
      <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)">
      <summary>Filtra los elementos de <see cref="T:System.Linq.IQueryable" /> en función de un tipo especificado.</summary>
      <returns>Colección que contiene los elementos de <paramref name="source" /> que son de tipo <paramref name="TResult" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable" /> cuyos elementos se van a filtrar.</param>
      <typeparam name="TResult">El tipo según el cual se van a filtrar los elementos de la secuencia.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Ordena de manera ascendente los elementos de una secuencia en función de una clave.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelto por la función representada por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Ordena de manera ascendente los elementos de una secuencia utilizando un comparador especificado.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelto por la función representada por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Ordena de manera descendente los elementos de una secuencia en función de una clave.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelto por la función representada por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Ordena de manera descendente los elementos de una secuencia utilizando un comparador especificado.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">Secuencia de valores que se va a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelto por la función representada por <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})">
      <summary>Invierte el orden de los elementos de una secuencia.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se corresponden en orden inverso con los de la secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a invertir.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Proyecta cada elemento de una secuencia en un nuevo formulario.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar una función de proyección en cada elemento de <paramref name="source" />.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})">
      <summary>Proyecta cada elemento de una secuencia en un nuevo formulario incorporando el índice del elemento.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar una función de proyección en cada elemento de <paramref name="source" />.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo del valor devuelto por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Proyecta cada elemento de una secuencia en <see cref="T:System.Collections.Generic.IEnumerable`1" /> e invoca una función del selector de resultados en cada elemento.Los valores resultantes de cada secuencia intermedia se combinan en una única secuencia unidimensional y se devuelven.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar la función de proyección uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> y de asignar a continuación cada uno de los elementos de la secuencia y sus elementos de <paramref name="source" /> correspondientes a un elemento de resultado.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="collectionSelector">Función de proyección que se va a aplicar a cada elemento de la secuencia de entrada.</param>
      <param name="resultSelector">Función de proyección que se va a aplicar a cada elemento de todas las secuencias intermedias.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">El tipo de los elementos intermedios recopilados por la función representada por <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="collectionSelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>Proyecta cada elemento de una secuencia en una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> y combina las secuencias resultantes en una secuencia.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar una función de proyección uno a varios en cada elemento de la secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia devuelta por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Proyecta cada elemento de una secuencia en una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> que incorpora el índice del elemento de origen que lo generó.Una función del selector de resultados se invoca en cada elemento de todas las secuencias intermedias y, a continuación, los valores resultantes se combinan en una única secuencia unidimensional y se devuelven.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar la función de proyección uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> y de asignar a continuación cada uno de los elementos de la secuencia y sus elementos de <paramref name="source" /> correspondientes a un elemento de resultado.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="collectionSelector">Función de proyección que se va a aplicar a cada elemento de la secuencia de entrada; el segundo parámetro de esta función representa el índice del elemento de origen.</param>
      <param name="resultSelector">Función de proyección que se va a aplicar a cada elemento de todas las secuencias intermedias.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TCollection">El tipo de los elementos intermedios recopilados por la función representada por <paramref name="collectionSelector" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia resultante.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="collectionSelector" /> o <paramref name="resultSelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})">
      <summary>Proyecta cada elemento de una secuencia en una interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> y combina las secuencias resultantes en una secuencia.El índice de cada elemento de origen se utiliza en el formulario proyectado de ese elemento.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos son el resultado de invocar una función de proyección uno a varios en cada elemento de la secuencia de entrada.</returns>
      <param name="source">Secuencia de valores que se va a proyectar.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento; el segundo parámetro de esta función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia devuelta por la función representada por <paramref name="selector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Determina si dos secuencias son iguales utilizando el comparador de igualdad predeterminado para comparar los elementos.</summary>
      <returns>true si las dos secuencias de origen tienen la misma longitud y sus elementos correspondientes son iguales; de lo contrario, false.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a comparar con los de <paramref name="source2" />.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a comparar con los de la primera secuencia.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Determina si dos secuencias son iguales utilizando una interfaz <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificada para comparar los elementos.</summary>
      <returns>true si las dos secuencias de origen tienen la misma longitud y sus elementos correspondientes son iguales; de lo contrario, false.</returns>
      <param name="source1">
        <see cref="T:System.Linq.IQueryable`1" /> cuyos elementos se van a comparar con los de <paramref name="source2" />.</param>
      <param name="source2">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> cuyos elementos se van a comparar con los de la primera secuencia.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar para comparar elementos.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el único elemento de una secuencia y produce una excepción si no hay exactamente un elemento en la secuencia.</summary>
      <returns>El único elemento de la secuencia de entrada.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver el único elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="source" /> tiene más de un elemento.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el único elemento de una secuencia que cumpla la condición especificada y produce una excepción si más de un elemento la cumple.</summary>
      <returns>Único elemento de la secuencia de entrada que satisface la condición de <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se va a devolver un único elemento.</param>
      <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />.-O bien-Varios elementos satisfacen la condición de <paramref name="predicate" />.-O bien-La secuencia de origen está vacía.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})">
      <summary>Devuelve el único elemento de una secuencia o un valor predeterminado si la secuencia está vacía; este método produce una excepción si hay más de un elemento en la secuencia.</summary>
      <returns>El único elemento de la secuencia de entrada o default(<paramref name="TSource" />) si la secuencia no contiene ningún elemento.</returns>
      <param name="source">Interfaz <see cref="T:System.Linq.IQueryable`1" /> de la que se va a devolver el único elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve el único elemento de una secuencia que cumpla la condición especificada, o bien, un valor predeterminado si ese elemento no existe; este método produce una excepción si varios elementos cumplen la condición.</summary>
      <returns>Único elemento de la secuencia de entrada que satisface la condición de <paramref name="predicate" /> o default(<paramref name="TSource" />) si no se encuentra dicho elemento.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se va a devolver un único elemento.</param>
      <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Omite un número especificado de elementos en una secuencia y, a continuación, devuelve los elementos restantes.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos que hay después del índice especificado en la secuencia de entrada.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se van a devolver los elementos.</param>
      <param name="count">Número de elementos que se van a omitir antes de devolver los elementos restantes.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Omite los elementos de una secuencia siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de <paramref name="source" /> comenzando por el primer elemento de la serie lineal que no pasa la prueba especificada por <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se van a devolver los elementos.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Omite los elementos de una secuencia siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.El índice del elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de <paramref name="source" /> comenzando por el primer elemento de la serie lineal que no pasa la prueba especificada en <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> del que se van a devolver los elementos.</param>
      <param name="predicate">Función que va a probar cada elemento para determinar si satisface una condición; el segundo parámetro de esta función representa el índice del elemento de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})">
      <summary>Calcula la suma de una secuencia de valores <see cref="T:System.Single" />.</summary>
      <returns>La suma de los valores de la secuencia.</returns>
      <param name="source">Secuencia de valores <see cref="T:System.Single" /> cuya suma se va a calcular.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Decimal" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Double" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Int32" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Int64" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Decimal" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Double" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Int32" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Int64" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
      <exception cref="T:System.OverflowException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Single" /> que aceptan valores NULL que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
      <summary>Calcula la suma de la secuencia de valores <see cref="T:System.Single" /> que se obtiene al invocar una función de proyección en cada elemento de la secuencia de entrada.</summary>
      <returns>La suma de los valores proyectados.</returns>
      <param name="source">Secuencia de valores de tipo <paramref name="TSource" />.</param>
      <param name="selector">Función de proyección que se va a aplicar a cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="selector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)">
      <summary>Devuelve un número especificado de elementos contiguos desde el principio de una secuencia.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene el número especificado de elementos desde el comienzo de <paramref name="source" />.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="count">Número de elementos que se van a devolver.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Devuelve los elementos de una secuencia en tanto que el valor de una condición especificada sea true.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de la secuencia de entrada que se encuentran antes del elemento en el que la prueba especificada por <paramref name="predicate" /> no se realiza correctamente.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Devuelve los elementos de una secuencia en tanto que el valor de una condición especificada sea true.El índice del elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de la secuencia de entrada que se encuentran antes del elemento en el que la prueba especificada en <paramref name="predicate" /> no se realiza correctamente.</returns>
      <param name="source">Secuencia cuyos elementos se van a devolver.</param>
      <param name="predicate">Función que va a probar cada elemento para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de la secuencia de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden ascendentes con arreglo a una clave.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden ascendente utilizando un comparador especificado.</summary>
      <returns>Una interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan con arreglo a una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden descendente con arreglo a una clave.</summary>
      <returns>Interfaz <see cref="T:System.Linq.IOrderedQueryable`1" /> cuyos elementos se ordenan de manera descendente con arreglo una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función representada en <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
      <summary>Realiza una clasificación posterior de los elementos de una secuencia en orden descendente utilizando un comparador especificado.</summary>
      <returns>Colección cuyos elementos están ordenados de manera descendente de acuerdo con una clave.</returns>
      <param name="source">
        <see cref="T:System.Linq.IOrderedQueryable`1" /> que contiene los elementos que se van a ordenar.</param>
      <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <typeparam name="TKey">Tipo de la clave devuelta por la función <paramref name="keySelector" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="comparer" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>Proporciona la unión de conjuntos de dos secuencias utilizando el comparador de igualdad predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
      <param name="source1">Secuencia cuyos elementos forman el primer conjunto de la operación de unión.</param>
      <param name="source2">Secuencia cuyos elementos forman el segundo conjunto de la operación de unión.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>Proporciona la unión de conjuntos de dos secuencias a través de un objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
      <param name="source1">Secuencia cuyos elementos forman el primer conjunto de la operación de unión.</param>
      <param name="source2">Secuencia cuyos elementos forman el segundo conjunto de la operación de unión.</param>
      <param name="comparer">
        <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
      <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>Filtra una secuencia de valores en función de un predicado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de la secuencia de entrada que satisfacen la condición especificada en <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que se va a filtrar.</param>
      <param name="predicate">Función para probar cada elemento de una condición.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})">
      <summary>Filtra una secuencia de valores en función de un predicado.El índice de cada elemento se usa en la lógica de la función de predicado.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene los elementos de la secuencia de entrada que satisfacen la condición especificada por <paramref name="predicate" />.</returns>
      <param name="source">
        <see cref="T:System.Linq.IQueryable`1" /> que se va a filtrar.</param>
      <param name="predicate">Función que va a probar cada elemento para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de la secuencia de origen.</param>
      <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> o <paramref name="predicate" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
      <summary>Combina dos secuencias utilizando la función de predicado especificada.</summary>
      <returns>
        <see cref="T:System.Linq.IQueryable`1" /> que contiene elementos combinados de las dos secuencias de entrada.</returns>
      <param name="source1">Primera secuencia que se va a combinar.</param>
      <param name="source2">Segunda secuencia que se va a combinar.</param>
      <param name="resultSelector">Función que especifica cómo combinar los elementos de las dos secuencias.</param>
      <typeparam name="TFirst">Tipo de los elementos de la primera secuencia de entrada.</typeparam>
      <typeparam name="TSecond">Tipo de los elementos de la segunda secuencia de entrada.</typeparam>
      <typeparam name="TResult">Tipo de los elementos de la secuencia de resultados.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source1" /> o <paramref name="source2 " /> es null.</exception>
    </member>
    <member name="T:System.Linq.Expressions.BinaryExpression">
      <summary>Representa una expresión que tiene un operador binario.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo del árbol de expresión; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Conversion">
      <summary>Obtiene la función de conversión de tipos utilizada por una operación de uso combinado o una operación de asignación compuesta.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>true si el nodo representa una llamada elevada; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo de árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores NULL.</summary>
      <returns>true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores NULL; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Left">
      <summary>Obtiene el operando izquierdo de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo de la operación binaria.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación binaria.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BinaryExpression.Right">
      <summary>Obtiene el operando derecho de la operación binaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho de la operación binaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BinaryExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="left">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> del resultado. </param>
      <param name="conversion">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> del resultado.</param>
      <param name="right">Propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.BlockExpression">
      <summary>Representa un bloque que contiene una secuencia de expresiones donde se pueden definir variables.</summary>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Expressions">
      <summary>Obtiene las expresiones de este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las expresiones de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Result">
      <summary>Obtiene la última expresión de este bloque.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la última expresión de este bloque.</returns>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.BlockExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> del resultado. </param>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.BlockExpression.Variables">
      <summary>Obtiene las variables definidas en este bloque.</summary>
      <returns>Colección de solo lectura que contiene todas las variables definidas en este bloque.</returns>
    </member>
    <member name="T:System.Linq.Expressions.CatchBlock">
      <summary>Representa una instrucción catch en un bloque try.</summary>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Body">
      <summary>Obtiene el cuerpo del bloque catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de catch.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Filter">
      <summary>Obtiene el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del filtro <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Test">
      <summary>Obtiene el tipo de <see cref="T:System.Exception" /> que este controlador captura.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de <see cref="T:System.Exception" /> que este controlador captura.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.ToString">
      <summary>Devuelve una instancia de <see cref="T:System.String" /> que representa el objeto <see cref="T:System.Object" /> actual.</summary>
      <returns>
        <see cref="T:System.String" /> que representa el elemento <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.CatchBlock.Update(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variable">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> del resultado.</param>
      <param name="filter">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.CatchBlock.Variable">
      <summary>Obtiene una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> capturado por este controlador.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ConditionalExpression">
      <summary>Representa una expresión que tiene un operador condicional.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfFalse">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.IfTrue">
      <summary>Obtiene la expresión que se va a ejecutar si la prueba se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la expresión que se va a ejecutar si la prueba se evalúa como true.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Test">
      <summary>Obtiene la prueba de la operación condicional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba de la operación condicional.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConditionalExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ConditionalExpression.Update(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión, si no se ha cambiado ningún elemento secundario, o una expresión con los elementos secundarios actualizados.</returns>
      <param name="test">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> del resultado.</param>
      <param name="ifTrue">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> del resultado.</param>
      <param name="ifFalse">Propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ConstantExpression">
      <summary>Representa una expresión que tiene un valor constante.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ConstantExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ConstantExpression.Value">
      <summary>Obtiene el valor de la expresión constante.</summary>
      <returns>
        <see cref="T:System.Object" /> igual al valor de la expresión representada.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DebugInfoExpression">
      <summary>Emite o borra un punto de secuencia para obtener información de depuración.Esto permite al depurador resaltar el código fuente correcto al depurar.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DebugInfoExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Document">
      <summary>Obtiene <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndColumn">
      <summary>Obtiene la columna final de este <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.EndLine">
      <summary>Obtiene la línea final de este <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea final del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.IsClear">
      <summary>Obtiene el valor para indicar si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se utiliza para borrar un punto de secuencia.</summary>
      <returns>Es true si <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> se va a utilizar para borrar un punto de secuencia; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartColumn">
      <summary>Obtiene la columna inicial de este <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la columna inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.StartLine">
      <summary>Obtiene la línea inicial de este <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Número de la línea inicial del código que se utilizó para generar la expresión ajustada.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DebugInfoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DefaultExpression">
      <summary>Representa el valor predeterminado de un tipo o una expresión vacía.</summary>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DefaultExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpression">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Arguments">
      <summary>Obtiene los argumentos para la operación dinámica.</summary>
      <returns>Colecciones de solo lectura que contienen los argumentos para la operación dinámica.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Binder">
      <summary>Obtiene la clase <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</summary>
      <returns>
        <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, que determina el comportamiento en tiempo de ejecución del sitio dinámico.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.DelegateType">
      <summary>Obtiene el tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Dynamic(System.Runtime.CompilerServices.CallSiteBinder,System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="returnType">Tipo de resultado de la expresión dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y cuyas propiedades <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y un argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado y cuatro argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arg0">Primer argumento de la operación dinámica.</param>
      <param name="arg1">Segundo argumento de la operación dinámica.</param>
      <param name="arg2">Tercer argumento de la operación dinámica.</param>
      <param name="arg3">Cuarto argumento de la operación dinámica.</param>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.MakeDynamic(System.Type,System.Runtime.CompilerServices.CallSiteBinder,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DynamicExpression" /> que representa una operación dinámica enlazada por el objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> proporcionado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DynamicExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, y que tiene <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> y <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> establecidos en los valores especificados.</returns>
      <param name="delegateType">Tipo del delegado usado por <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
      <param name="binder">Enlazador en tiempo de ejecución de la operación dinámica.</param>
      <param name="arguments">Argumentos de la operación dinámica.</param>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.DynamicExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Compara el valor enviado al parámetro, arguments, con la propiedad Arguments de la instancia actual de DynamicExpression.Si los valores del parámetro y la propiedad son iguales, se devuelve la instancia actual.Si no son iguales, se devuelve una nueva instancia DynamicExpression idéntica a la instancia actual a excepción de que la propiedad Arguments está establecida en el valor del parámetro arguments.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.DynamicExpressionVisitor">
      <summary>Representa un visitante o un sistema de reescritura de árboles de expresión dinámica.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.DynamicExpressionVisitor.VisitDynamic(System.Linq.Expressions.DynamicExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
      <returns>Devuelve <see cref="T:System.Linq.Expressions.Expression" />, la expresión modificada, si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.ElementInit">
      <summary>Representa un inicializador para un elemento único de una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.AddMethod">
      <summary>Obtiene el método de instancia que se usa para agregar un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que agrega un elemento a una colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ElementInit.Arguments">
      <summary>Obtiene la colección de argumentos que se pasan a un método que agrega un elemento a una colección <see cref="T:System.Collections.IEnumerable" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para un método que agrega un elemento a una colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.ToString">
      <summary>Devuelve una representación textual de un objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Representación textual del objeto <see cref="T:System.Linq.Expressions.ElementInit" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ElementInit.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression">
      <summary>Proporciona la clase base de la que se derivan las clases que representan los nodos de árbol de expresión.También contiene métodos de generador static (Shared en Visual Basic) para crear los diversos tipos de nodo.Esta es una clase abstract.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor">
      <summary>Crea una nueva instancia de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.Expression.#ctor(System.Linq.Expressions.ExpressionType,System.Type)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <param name="nodeType">
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que se va a establecer como tipo de nodo.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> de este <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de suma para <paramref name="left" />. Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Add(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética sin comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de suma con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de suma para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AddChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de suma aritmética con comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de suma definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador bit a bit AND no se ha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.And(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.And" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador bit a bit AND definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador bit a bit AND no se ha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAlso(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador bit a bit AND definido para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="method" /> es null y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.AndAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación AND bit a bit.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz multidimensional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz multidimensional.</param>
      <param name="indexes">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene expresiones usadas para indizar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayAccess(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> para obtener acceso a una matriz.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="array">Expresión que representa la matriz para indizar.</param>
      <param name="indexes">Matriz que contiene expresiones usadas para indizar la matriz.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango superior a uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />.</param>
      <param name="indexes">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.-O bien-El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz de rango uno.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="index">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="index" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.-O bien-<paramref name="array" />.Type representa un tipo de matriz cuyo rango no es 1.-O bien-<paramref name="index" />.Type no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayIndex(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa la aplicación de un operador de índice de matriz a una matriz multidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="array">Matriz de instancias de <see cref="T:System.Linq.Expressions.Expression" />: índices para la operación de índice de matriz.</param>
      <param name="indexes">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> o <paramref name="indexes" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.-O bien-El rango de <paramref name="array" />.Type no coincide con el número de elementos en <paramref name="indexes" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="indexes" /> no representa el tipo <see cref="T:System.Int32" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ArrayLength(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión para obtener la longitud de una matriz unidimensional.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> es igual a <paramref name="array" />.</returns>
      <param name="array">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />.Type no representa un tipo de matriz.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Assign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MemberInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuyo <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> y las propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> están establecidas en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.-O bien-La propiedad representada por <paramref name="member" /> no tiene un descriptor de acceso set.-O bien-<paramref name="expression" />.Type no se puede asignar al tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Bind(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberAssignment" /> que representa la inicialización de un miembro mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberAssignment" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> se establece en <paramref name="expression" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.-O bien-La propiedad a la que accede <paramref name="propertyAccessor" /> no tiene ningún descriptor de acceso set.-O bien-<paramref name="expression" />.Type no se puede asignar al tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones especificadas y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones especificadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones especificadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene dos expresiones y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene tres expresiones y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cuatro expresiones y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene cinco expresiones y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="arg0">Primera expresión del bloque.</param>
      <param name="arg1">Segunda expresión del bloque.</param>
      <param name="arg2">Tercera expresión del bloque.</param>
      <param name="arg3">Cuarta expresión del bloque.</param>
      <param name="arg4">Quinta expresión del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones especificadas y no tiene ninguna variable.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones especificadas, no tiene ninguna variable y tiene un tipo de resultado concreto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones especificadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las variables y expresiones especificadas.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="variables">Variables del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Block(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> que contiene las expresiones especificadas, no tiene ninguna variable y tiene un tipo de resultado concreto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BlockExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del bloque.</param>
      <param name="expressions">Expresiones del bloque.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Break(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Break con el tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Break, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" />.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método de instancia que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de método de instancia (pasa null para un método static [Shared en Visual Basic]).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.-O bien-<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> para establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> igual a (pasa null para un método static [Shared in Visual Basic]).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.-O bien-<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.-O bien-El número de elementos de <paramref name="arguments" /> no es igual que el número de parámetros del método representado por <paramref name="method" />.-O bien-Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada a una instancia.(Pasa null para un método estático (compartido en Visual Basic)).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que no toma argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada a una instancia.(Pasa null para un método estático (compartido en Visual Basic)).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método que toma argumentos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="instance">
        <see cref="T:System.Linq.Expressions.Expression" /> que especifica la instancia de una llamada de método de instancia (pasa null para un método static [Shared en Visual Basic]).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.-O bien-<paramref name="instance" /> es null y <paramref name="method" /> representa un método de instancia.-O bien-<paramref name="arguments" /> no es null y uno o varios de sus elementos son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="instance" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="method" />.-O bien-El número de elementos de <paramref name="arguments" /> no es igual que el número de parámetros del método representado por <paramref name="method" />.-O bien-Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Linq.Expressions.Expression,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método de instancia llamando al método de generador adecuado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> es igual a <paramref name="instance" />, cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> se establece en el objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de instancia especificado, y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> se establece en los argumentos especificados.</returns>
      <param name="instance">Objeto <see cref="T:System.Linq.Expressions.Expression" /> de cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se buscará el valor para un método concreto.</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="instance" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se encuentra en <paramref name="instance" />.Type o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.-O bien-En <paramref name="instance" />.Type o sus tipos base se encuentra más de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático (Shared en Visual Basic).</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de destino.</param>
      <param name="arguments">Colección de <see cref="T:System.Linq.Expressions.Expression" /> que representa los argumentos de la llamada.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) que toma un argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma dos argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma tres argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cuatro argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método estático que toma cinco argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />.</param>
      <param name="arg0">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el primer argumento.</param>
      <param name="arg1">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el segundo argumento.</param>
      <param name="arg2">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el tercer argumento.</param>
      <param name="arg3">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuarto argumento.</param>
      <param name="arg4">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el quinto argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) con argumentos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> y <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="method">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método static (Shared en Visual Basic) en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> igual a.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="method" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="arguments" /> no es igual que el número de parámetros del método representado por <paramref name="method" />.-O bien-Uno o varios elementos de <paramref name="arguments" /> no se pueden asignar al parámetro correspondiente del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Call(System.Type,System.String,System.Type[],System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> que representa una llamada a un método static (Shared en Visual Basic) llamando al método de generador adecuado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MethodCallExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, cuy propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> está establecida en el <see cref="T:System.Reflection.MethodInfo" /> que representa el método especificado static (Shared en Visual Basic), y cuya propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> está establecida en los argumentos especificados.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que especifica el tipo que contiene el método static especificado (Shared en Visual Basic).</param>
      <param name="methodName">Nombre del método.</param>
      <param name="typeArguments">Matriz de objetos <see cref="T:System.Type" /> que especifican los parámetros de tipo del método genérico.Este argumento debería ser null cuando methodName especifica un método no genérico.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="methodName" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se encuentra en <paramref name="type" />.Type o sus tipos base ningún método cuyo nombre sea <paramref name="methodName" />, cuyos parámetros de tipo coincidan con <paramref name="typeArguments" /> y cuyos tipos de parámetro se correspondan con <paramref name="arguments" />.-O bien-En <paramref name="type" />.Type o sus tipos base se encuentra más de un método cuyo nombre es <paramref name="methodName" />, cuyos parámetros de tipo coinciden con <paramref name="typeArguments" /> y cuyos tipos de parámetro se corresponden con <paramref name="arguments" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.CanReduce">
      <summary>Indica que el nodo se puede reducir a uno más simple.Si devuelve true, se puede llamar a Reduce() para generar el formulario reducido.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con una referencia al objeto <see cref="T:System.Exception" /> detectado que se va a usar en el cuerpo del controlador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> y una referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> del objeto <see cref="T:System.Exception" /> que controlará este objeto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Catch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con un filtro <see cref="T:System.Exception" /> pero ninguna referencia al objeto <see cref="T:System.Exception" /> detectado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> del objeto <see cref="T:System.Exception" /> que controlará este objeto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ClearDebugInfo(System.Linq.Expressions.SymbolDocumentInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de la secuencia.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> para borrar un punto de la secuencia.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores NULL.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de uso combinado, dada una función de conversión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="left" />.Type y <paramref name="right" />.Type no se pueden convertir entre sí.-O bien-<paramref name="conversion" /> no es null y <paramref name="conversion" />.Type es un tipo de delegado que no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> no representa un tipo de referencia ni un tipo de valor que acepta valores NULL.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="left" /> representa un tipo que no se puede asignar al tipo de parámetro del tipo de delegado <paramref name="conversion" />.Type.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de <paramref name="right" /> no es igual que el tipo de valor devuelto del tipo de delegado <paramref name="conversion" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> están establecidas en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="test" /> o <paramref name="ifTrue" /> o <paramref name="ifFalse" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="test" />.Type no es <see cref="T:System.Boolean" />.-O bien-<paramref name="ifTrue" />.Type no es igual que <paramref name="ifFalse" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Condition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa una instrucción condicional.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> están establecidas en los valores especificados.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
      <param name="type">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> se establece en el valor especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> está establecida en el valor especificado.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Constant(System.Object,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> se establecen en los valores especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConstantExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> están establecidas en los valores especificados.</returns>
      <param name="value">Objeto <see cref="T:System.Object" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="value" /> no es null y <paramref name="type" /> no se puede asignar a partir del tipo dinámico de <paramref name="value" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Continue(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Continue con el tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión de tipos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la operación de conversión para la que se especifica el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.-O bien-<paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.-O bien-El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.-O bien-<paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor correspondiente que no acepta valores NULL no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ConvertChecked(System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de conversión que produce una excepción si está desbordado el tipo de destino y para la que se especifica el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de conversión definido entre <paramref name="expression" />.Type y <paramref name="type" />.-O bien-<paramref name="expression" />.Type no se puede asignar al tipo de argumento del método representado por <paramref name="method" />.-O bien-El tipo de valor devuelto del método representado por <paramref name="method" /> no se puede asignar a <paramref name="type" />.-O bien-<paramref name="expression" />.Type o <paramref name="type" /> es un tipo de valor que acepta valores NULL y el tipo de valor correspondiente que no acepta valores NULL no es igual que el tipo de argumento o el tipo de valor devuelto, respectivamente, del método representado por <paramref name="method" />.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">Se ha encontrado más de un método que coincide con la descripción de <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DebugInfo(System.Linq.Expressions.SymbolDocumentInfo,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> con el intervalo especificado.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
      <param name="document">
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> que representa el archivo de origen.</param>
      <param name="startLine">Línea de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="startColumn">Columna de inicio de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor que 0.</param>
      <param name="endLine">Línea final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Debe ser mayor o igual que la línea de inicio.</param>
      <param name="endColumn">Columna final de este objeto <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.Si la línea de fin es igual que la de inicio, debe ser mayor o igual que la columna de inicio.En cualquier caso, debe ser mayor que 0.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Decrement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la disminución de la expresión en 1.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión disminuida.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a disminuir.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Default(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> se establece en el tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en el tipo especificado.</returns>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de división para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Divide(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de división aritmética.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de división definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.DivideAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de división sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, con <see cref="T:System.Collections.Generic.IEnumerable`1" /> como segundo argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> cuyas propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="addMethod">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> como igual a.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método representado por <paramref name="addMethod" /> no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).-O bien-El método representado por <paramref name="addMethod" /> no es un método de instancia.-O bien-<paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del método que <paramref name="addMethod" /> representa.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método representado por <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ElementInit(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ElementInit" />, dada una matriz de valores como segundo argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ElementInit" /> cuyas propiedades <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> y <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> se establecen en los valores especificados.</returns>
      <param name="addMethod">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> en los que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> como igual a.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="addMethod" /> o <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El método que addMethod representa no se denomina "Add" (sin distinción entre mayúsculas y minúsculas).-O bien-El método que addMethod representa no es un método de instancia.-O bien-El parámetro arguments no contiene el mismo número de elementos que el número de parámetros del método que addMethod representa.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del método representado por <paramref name="addMethod" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Empty">
      <summary>Crea una expresión vacía de tipo <see cref="T:System.Void" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.DefaultExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> y cuya propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> está establecida en <see cref="T:System.Void" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de igualdad para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Equal(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de igualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador XOR para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOr(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador XOR definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ExclusiveOrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación XOR bit a bit, usando op_ExclusiveOr para los tipos definidos por el usuario.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Reflection.FieldInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Para static (Shared en Visual Basic), <paramref name="expression" /> debe ser null.</param>
      <param name="field">Objeto <see cref="T:System.Reflection.FieldInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="field" /> es null.-O bien-El campo representado por <paramref name="field" /> no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del campo representado por <paramref name="field" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo, dado el nombre del campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.FieldInfo" /> que representa el campo denotado por <paramref name="fieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene un campo denominado <paramref name="fieldName" />.Este puede ser null para los campos estáticos.</param>
      <param name="fieldName">Nombre de un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="fieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ningún campo denominado <paramref name="fieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Field(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor del campo.Este puede ser null para los campos estáticos.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene el campo.</param>
      <param name="fieldName">Campo al que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetActionType(System.Type[])">
      <summary>Crea un objeto <see cref="T:System.Type" /> que representa un tipo de delegado System.Action genérico con argumentos de tipo concretos.</summary>
      <returns>Tipo de un delegado System.Action que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene más de cuatro elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetDelegateType(System.Type[])">
      <summary>Obtiene un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado genérico System.Func o System.Action con argumentos de tipo concretos.</summary>
      <returns>Tipo de delegado.</returns>
      <param name="typeArgs">Argumentos de tipo del delegado.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GetFuncType(System.Type[])">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico con argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>Tipo de un delegado System.Func que tiene los argumentos de tipo especificados.</returns>
      <param name="typeArgs">Matriz de entre uno y cinco objetos <see cref="T:System.Type" /> que especifican los argumentos de tipo para el tipo de delegado System.Action.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="typeArgs" /> contiene menos de un elemento o más de cinco elementos.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeArgs" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a GoTo, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Goto, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Goto(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción GoTo con el tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en el valor especificado, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor que".Se puede especificar el método de implementación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador "mayor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "mayor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.GreaterThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "mayor o igual que".</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador "mayor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThen(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con una instrucción if.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> están establecidas en los valores especificados.La propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> está establecida en la expresión predeterminada y el tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IfThenElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> que representa un bloque condicional con instrucciones if y else.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> y <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> están establecidas en los valores especificados.El tipo del objeto <see cref="T:System.Linq.Expressions.ConditionalExpression" /> resultante devuelto por este método es <see cref="T:System.Void" />.</returns>
      <param name="test">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />.</param>
      <param name="ifTrue">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />.</param>
      <param name="ifFalse">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el incremento de la expresión en 1.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Increment(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa el incremento de la expresión en 1.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión incrementada.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a incrementar.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado especificado o la expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o la expresión lambda al que se va a aplicar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado o la expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.InvocationExpression" /> que aplica el delegado especificado o la expresión lambda especificados a los argumentos proporcionados.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado o la expresión lambda que se va a aplicar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado o la expresión lambda.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no representa un tipo de delegado o <see cref="T:System.Linq.Expressions.Expression`1" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del delegado representado por <paramref name="expression" />.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="arguments" /> no contiene el mismo número de elementos que la lista de parámetros para el delegado representado por <paramref name="expression" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsFalse(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en false.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.IsTrue(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve si la expresión se evalúa en true.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que se va a evaluar.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y sin nombre.</summary>
      <returns>Nuevo <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y sin nombre.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta sin un valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> sin un valor predeterminado.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> que representa una etiqueta con el valor predeterminado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelExpression" /> con el valor predeterminado especificado.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> con el que se asociará este objeto <see cref="T:System.Linq.Expressions.LabelExpression" />.</param>
      <param name="defaultValue">Valor de este objeto <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se alcanza la etiqueta por medio del flujo de control normal.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y el nombre dado.</summary>
      <returns>Nuevo <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con tipo void y el nombre dado.</returns>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo especificado.</summary>
      <returns>Nuevo <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo especificado.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Label(System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre especificados.</summary>
      <returns>Nuevo <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta con el tipo y el nombre especificados.</returns>
      <param name="type">Tipo de valor que se pasa cuando se produce el salto a la etiqueta.</param>
      <param name="name">Nombre de la etiqueta.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> es igual a <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression`1.Body" /> y <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> es igual a <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression`1.Body" /> y <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es null.-O bien-Uno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.-O bien-<paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.-O bien-<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado.</typeparam>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es null.-O bien-Uno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="TDelegate" /> no es un tipo de delegado.-O bien-<paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto de <paramref name="TDelegate" />.-O bien-<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para <paramref name="TDelegate" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro de <paramref name="TDelegate" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="body" /> es null.-O bien-Uno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="parameters" /> contiene más de dieciséis elementos.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> es igual a <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression`1.Body" /> y <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda``1(System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuando se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression`1" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression`1.NodeType" /> es igual a <see cref="P:System.Linq.Expressions.Expression`1.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression`1.Body" /> y <see cref="P:System.Linq.Expressions.Expression`1.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression`1.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.Expression`1.Parameters" />.</param>
      <typeparam name="TDelegate">Tipo de delegado. </typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Boolean,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada.</param>
      <param name="parameters">Matriz que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> es null.-O bien-Uno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.-O bien-<paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.-O bien-<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> construyendo primero un tipo de delegado.Se puede usar cuando no se conoce el tipo de delegado en tiempo de compilación.</summary>
      <returns>Objeto que representa una expresión lambda cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> se establecen en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="T:System.Type" /> que representa una signatura de delegado para la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="parameters">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="delegateType" /> o <paramref name="body" /> es null.-O bien-Uno o varios elementos de <paramref name="parameters" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="delegateType" /> no representa un tipo de delegado.-O bien-<paramref name="body" />.Type representa un tipo que no se puede asignar al tipo de valor devuelto del tipo de delegado representado por <paramref name="delegateType" />.-O bien-<paramref name="parameters" /> no contiene el mismo número de elementos que la lista de parámetros para el tipo de delegado representado por <paramref name="delegateType" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="parameters" /> no se puede asignar desde el tipo del correspondiente tipo de parámetro del tipo de delegado representado por <paramref name="delegateType" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</param>
      <param name="body">
        <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> igual a. </param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="tailCall">
        <see cref="T:System.Boolean" /> que indica si se va a aplicar la optimización de llamadas de cola durante la compilación de la expresión creada. </param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />. </param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.String,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea un objeto LambdaExpression construyendo primero un tipo de delegado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> es igual a Lambda y cuyas propiedades <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> y <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> están establecidas en los valores especificados.</returns>
      <param name="delegateType">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa la signatura de delegado de la expresión lambda.</param>
      <param name="body">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />.</param>
      <param name="name">Nombre de la expresión lambda.Se usa para emitir información de depuración.</param>
      <param name="parameters">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la izquierda.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de desplazamiento a la izquierda definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación bit a bit de desplazamiento a la izquierda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación bit a bit de desplazamiento a la izquierda.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LeftShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación bit a bit de desplazamiento a la izquierda.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "menor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThan(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor que".</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador "menor que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.LessThanOrEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación numérica "menor o igual que".</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador "menor o igual que" definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> están establecidas en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. -O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.-O bien-El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MemberInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> donde el miembro es un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> están establecidas en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o una propiedad en la que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="member" /> es null. -O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.-O bien-El objeto <see cref="P:System.Reflection.FieldInfo.FieldType" /> o <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> del campo o de la propiedad que <paramref name="member" /> representa no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. -O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.-O bien-El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListBind(System.Reflection.MethodInfo,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> basándose en el método de descriptor de acceso de propiedad especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberListBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.MemberInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuya propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> se rellena con los elementos de <paramref name="initializers" />.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="propertyAccessor" /> es null. -O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.-O bien-El objeto <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" /> no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> están establecidas en los valores especificados.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza el método denominado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> está establecida en el valor especificado.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha declarado ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.-O bien-El método Add en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.-O bien-El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método Add en <paramref name="newExpression" />.Type o su tipo base.-O bien-Hay más de un método compatible con los argumentos denominado "Add" (sin distinción entre mayúsculas y minúsculas) en <paramref name="newExpression" />.Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.ElementInit[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza los objetos <see cref="T:System.Linq.Expressions.ElementInit" /> especificados para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> están establecidas en los valores especificados.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza el método denominado "Add" para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> está establecida en el valor especificado.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha declarado ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) en <paramref name="newExpression" />.Type o su tipo base.-O bien-El método Add en <paramref name="newExpression" />.Type o su tipo base no toma exactamente un argumento.-O bien-El tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> del primer elemento de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método Add en <paramref name="newExpression" />.Type o su tipo base.-O bien-Hay más de un método compatible con los argumentos denominado "Add" (sin distinción entre mayúsculas y minúsculas) en <paramref name="newExpression" />.Type y/o su tipo base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza el método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> está establecida en el valor especificado.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas), que agrega un elemento a una colección.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.-O bien-<paramref name="addMethod" /> no es null y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.-O bien-<paramref name="addMethod" /> no es null y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ListInit(System.Linq.Expressions.NewExpression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.ListInitExpression" /> que utiliza el método especificado para agregar elementos a una colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ListInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> está establecida en el valor especificado.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />.</param>
      <param name="addMethod">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de instancia que toma un argumento, que agrega un elemento a una colección.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="initializers" /> es null.-O bien-Uno o varios elementos de <paramref name="initializers" /> son null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="newExpression" />.Type no implementa <see cref="T:System.Collections.IEnumerable" />.-O bien-<paramref name="addMethod" /> no es null y no representa ningún método de instancia denominado "Add" (sin distinción entre mayúsculas y minúsculas) que tome exactamente un argumento.-O bien-<paramref name="addMethod" /> no es null y el tipo representado por la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de uno o varios elementos de <paramref name="initializers" /> no se puede asignar al tipo de argumento del método que <paramref name="addMethod" /> representa.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="addMethod" /> es null y, en <paramref name="newExpression" />.Type o su tipo base, no hay ningún método de instancia denominado "Add" que tome un argumento compatible con el tipo.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado y el destino de Break.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Loop(System.Linq.Expressions.Expression,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> con el cuerpo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LoopExpression" /> creado.</returns>
      <param name="body">Cuerpo del bucle.</param>
      <param name="break">Destino Break empleado por el cuerpo del bucle.</param>
      <param name="continue">Destino Continue empleado por el cuerpo del bucle.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados los operandos izquierdo y derecho, llamando al método de generador adecuado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho y el método de implementación, llamando al método de generador adecuado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeBinary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" />, dados el operando izquierdo, el operando derecho, el método de implementación y la función de conversión de tipos, llamando al método de generador adecuado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="binaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación binaria.</param>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando izquierdo.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando derecho.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que especifica el método de implementación.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> que representa un tipo de función de conversión.Este parámetro solo se usa si <paramref name="binaryType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> o asignación compuesta.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="binaryType" /> no corresponde a ningún nodo de expresión binaria.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeCatchBlock(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa una instrucción Catch con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.CatchBlock" /> creado.</returns>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> del objeto <see cref="T:System.Exception" /> que controlará este objeto <see cref="T:System.Linq.Expressions.CatchBlock" />.</param>
      <param name="variable">Objeto <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representa una referencia al objeto <see cref="T:System.Exception" /> detectado por este controlador.</param>
      <param name="body">Cuerpo de la instrucción Catch.</param>
      <param name="filter">Cuerpo del filtro <see cref="T:System.Exception" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeGoto(System.Linq.Expressions.GotoExpressionKind,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto del objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> especificado.Además se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a <paramref name="kind" />, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="kind">
        <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> del objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeIndex(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada en un objeto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es static (shared en Visual Basic), debe ser null.</param>
      <param name="indexer">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa la propiedad que se va a indizar.</param>
      <param name="arguments">IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) en Visual Basic) que contiene los argumentos que se van a emplear para indizar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeMemberAccess(System.Linq.Expressions.Expression,System.Reflection.MemberInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a un campo o una propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto al que pertenece el miembro.Puede ser null para los miembros estáticos.</param>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> que describe el campo o la propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="member" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeTry(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con los elementos especificados.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="type">Tipo de resultado de la expresión try.Si es null, el cuerpo y todos los controladores deben tener un tipo idéntico.</param>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.Pasa null si el bloque try no tiene ningún bloque finally asociado.</param>
      <param name="fault">Cuerpo del bloque try.Pasa null si el bloque try no tiene ningún bloque fault asociado.</param>
      <param name="handlers">Colección de objetos <see cref="T:System.Linq.Expressions.CatchBlock" /> que representan las instrucciones Catch que se van a asociar al bloque try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dado un operando, llamando al método de generador adecuado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="unaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> que especifica el tipo al que se va a realizar la conversión (pase null si no se aplica).</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MakeUnary(System.Linq.Expressions.ExpressionType,System.Linq.Expressions.Expression,System.Type,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" />, dados un operando y un método de implementación, llamando al método de generador adecuado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que resulta de llamar al método de generador adecuado.</returns>
      <param name="unaryType">Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> que especifica el tipo de la operación unaria.</param>
      <param name="operand">Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> que especifica el tipo al que se va a realizar la conversión (pase null si no se aplica).</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="operand" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="unaryType" /> no corresponde a un nodo de expresión unaria.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> están establecidas en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.-O bien-La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MemberInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un campo o una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> y <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> están establecidas en los valores especificados.</returns>
      <param name="member">Objeto <see cref="T:System.Reflection.MemberInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="member" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="member" /> no representa ningún campo ni ninguna propiedad.-O bien-La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo del campo o de la propiedad que <paramref name="member" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuyas propiedades<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.-O bien-La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberBind(System.Reflection.MethodInfo,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> que representa la inicialización recursiva de los miembros de un miembro al que se obtiene acceso mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> es igual a <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> se establece en el objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />, y cuyas propiedades<see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> se establecen en los valores especificados.</returns>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="propertyAccessor" /> no representa ningún método de descriptor de acceso de propiedad.-O bien-La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo de la propiedad a la que obtiene acceso el método representado por <paramref name="propertyAccessor" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Representa una expresión que crea un nuevo objeto e inicializa una propiedad del objeto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> están establecidas en los valores especificados.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MemberInit(System.Linq.Expressions.NewExpression,System.Linq.Expressions.MemberBinding[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberInitExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> y <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> están establecidas en los valores especificados.</returns>
      <param name="newExpression">Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />.</param>
      <param name="bindings">Matriz de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="newExpression" /> o <paramref name="bindings" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> de un elemento de <paramref name="bindings" /> no representa ningún miembro del tipo que <paramref name="newExpression" />.Type representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de módulo para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Modulo(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto aritmética.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de módulo definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ModuloAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de multiplicación para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Multiply(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de multiplicación con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de multiplicación para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.MultiplyChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de multiplicación aritmética con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de multiplicación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> está establecida en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Negate(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.-O bien-<paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores NULL si se trata de un tipo de valor que acepta valores NULL) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> está establecida en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario menos definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NegateChecked(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de negación aritmética con comprobación de desbordamiento.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador unario menos definido para <paramref name="expression" />.Type.-O bien-<paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores NULL si se trata de un tipo de valor que acepta valores NULL) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor especificado que no toma ningún argumento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> está establecida en el valor especificado.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El constructor que <paramref name="constructor" /> representa tiene por lo menos un parámetro.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es null.-O bien-Un elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor especificado con los argumentos especificados.Se especifican los miembros que obtienen acceso a los campos inicializados por el constructor.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> están establecidas en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Reflection.MemberInfo" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es null.-O bien-Un elemento de <paramref name="arguments" /> es null.-O bien-Un elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.-O bien-El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.-O bien-Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Reflection.MemberInfo[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor especificado con los argumentos especificados.Los miembros que obtienen acceso a los campos inicializados por el constructor se especifican como una matriz.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> y <see cref="P:System.Linq.Expressions.NewExpression.Members" /> están establecidas en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <param name="members">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Members" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es null.-O bien-Un elemento de <paramref name="arguments" /> es null.-O bien-Un elemento de <paramref name="members" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El parámetro <paramref name="arguments" /> no contiene el mismo número de elementos que el número de parámetros del constructor representado por <paramref name="constructor" />.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.-O bien-El parámetro <paramref name="members" /> no contiene el mismo número de elementos que <paramref name="arguments" />.-O bien-Un elemento de <paramref name="arguments" /> tiene una propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo que no se puede asignar al tipo del miembro representado por el elemento correspondiente de <paramref name="members" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor especificado con los argumentos especificados.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> y <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> están establecidas en los valores especificados.</returns>
      <param name="constructor">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="constructor" /> es null.-O bien-Un elemento de <paramref name="arguments" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La longitud de <paramref name="arguments" /> coincide con el número de parámetros para el constructor que <paramref name="constructor" /> representa.-O bien-La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="arguments" /> no se puede asignar al tipo del parámetro correspondiente del constructor que <paramref name="constructor" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.New(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewExpression" /> que representa una llamada al constructor sin parámetros del tipo especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.New" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> está establecida en <see cref="T:System.Reflection.ConstructorInfo" />, que representa el constructor sin parámetros para el tipo especificado.</returns>
      <param name="type">
        <see cref="T:System.Type" /> que tiene un constructor que no toma ningún argumento.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tipo que <paramref name="type" /> representa no tiene un constructor sin parámetros.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz con el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> está establecida en el valor especificado.</returns>
      <param name="type">Objeto <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> es null.-O bien-Un elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayBounds(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz con el rango especificado.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> está establecida en el valor especificado.</returns>
      <param name="type">Objeto <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="bounds">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="bounds" /> es null.-O bien-Un elemento de <paramref name="bounds" /> es null.</exception>
      <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="bounds" /> no representa un tipo entero.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> está establecida en el valor especificado.</returns>
      <param name="type">Objeto <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene los objetos <see cref="T:System.Linq.Expressions.Expression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> es null.-O bien-Un elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo representado por <paramref name="type" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NewArrayInit(System.Type,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.NewArrayExpression" /> que representa la creación de una matriz unidimensional y su inicialización a partir de una lista de elementos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewArrayExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> y cuya propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> está establecida en el valor especificado.</returns>
      <param name="type">Objeto <see cref="T:System.Type" /> que representa el tipo de elemento de la matriz.</param>
      <param name="initializers">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> o <paramref name="initializers" /> es null.-O bien-Un elemento de <paramref name="initializers" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> de un elemento de <paramref name="initializers" /> representa un tipo que no puede asignarse al tipo representado por <paramref name="type" />.</exception>
    </member>
    <member name="P:System.Linq.Expressions.Expression.NodeType">
      <summary>Obtiene el tipo de nodo de este <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.ExpressionType" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> está establecida en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario Not definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Not(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación de complemento bit a bit.Se puede especificar el método de implementación.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador unario Not definido para <paramref name="expression" />.Type.-O bien-<paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores NULL si se trata de un tipo de valor que acepta valores NULL) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de no igualdad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de desigualdad para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.NotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Boolean,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de no igualdad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="liftToNull">true para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en true; false para establecer <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> en false.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de desigualdad definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Un objeto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OnesComplement(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Devuelve la expresión que representa el complemento a unos.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">Un objeto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador bit a bit OR no se ha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR bit a bit.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador bit a bit OR definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación OR bit a bit.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando solo si el primer operando se evalúa como false.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">El operador bit a bit OR no se ha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.OrElse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación OR condicional que evalúa el segundo operando solo si el primer operando se evalúa como false.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador bit a bit OR definido para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="method" /> es null y <paramref name="left" />.Type y <paramref name="right" />.Type no son del mismo tipo booleano.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se puede usar para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Parameter(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se puede usar para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ParameterExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.Expression.Type" /> y <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> están establecidas en los valores especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o variable; se emplea solo para depurar o imprimir.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de una disminución subsiguiente de 1 de la expresión original.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PostIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la asignación de la expresión seguida de un incremento subsiguiente de 1 de la expresión original.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de exponenciación para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="left" />.Type y/o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Power(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de un número a una potencia.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de exponenciación definido para <paramref name="left" />.Type y <paramref name="right" />.Type.-O bien-<paramref name="method" /> es null y <paramref name="left" />.Type y/o <paramref name="right" />.Type no son <see cref="T:System.Double" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PowerAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa la elevación de una expresión a una potencia y la asignación del resultado a dicha expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreDecrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que disminuye la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PreIncrementAssign(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que incrementa la expresión en 1 y asigna el resultado a la expresión.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la expresión resultante.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> al que se van a aplicar las operaciones.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad mediante un método de descriptor de acceso de propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" />, que representa la propiedad a la que se obtiene acceso en <paramref name="propertyAccessor" />.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyAccessor">
        <see cref="T:System.Reflection.MethodInfo" /> que representa un método de descriptor de acceso de propiedad.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="propertyAccessor" /> es null.-O bien-El método que <paramref name="propertyAccessor" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo del método representado por <paramref name="propertyAccessor" />.-O bien-El método que <paramref name="propertyAccessor" /> representa no es un método de descriptor de acceso de propiedad.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> y <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.Puede ser null para las propiedades estáticas.</param>
      <param name="property">Objeto <see cref="T:System.Reflection.PropertyInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="property" /> es null.-O bien-La propiedad que <paramref name="property" /> representa no es static (Shared en Visual Basic) y <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="expression" />.Type no se puede asignar al tipo declarativo de la propiedad que <paramref name="property" /> representa.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser NULL.</param>
      <param name="indexer">Objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indizar.</param>
      <param name="arguments">
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Reflection.PropertyInfo,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser NULL.</param>
      <param name="indexer">Objeto <see cref="T:System.Reflection.PropertyInfo" /> que representa la propiedad que se va a indizar.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" />, que representa la propiedad denotada por <paramref name="propertyName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad denominada <paramref name="propertyName" />.Puede ser null para las propiedades estáticas.</param>
      <param name="propertyName">Nombre de una propiedad a la que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ninguna propiedad denominada <paramref name="propertyName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> que representa el acceso a una propiedad indizada.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.IndexExpression" /> creado.</returns>
      <param name="instance">Objeto al que pertenece la propiedad.Si la propiedad es estática o compartida, deberá ser NULL.</param>
      <param name="propertyName">Nombre del indizador.</param>
      <param name="arguments">Matriz de objetos <see cref="T:System.Linq.Expressions.Expression" /> que se emplean para indizar la propiedad.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Property(System.Linq.Expressions.Expression,System.Type,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que va a obtener acceso a una propiedad.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> creado.</returns>
      <param name="expression">Objeto contenedor de la propiedad.Puede ser null para las propiedades estáticas.</param>
      <param name="type">
        <see cref="P:System.Linq.Expressions.Expression.Type" /> que contiene la propiedad.</param>
      <param name="propertyName">Propiedad a la que se va a obtener acceso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.PropertyOrField(System.Linq.Expressions.Expression,System.String)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.MemberExpression" /> que representa el acceso a una propiedad o campo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.MemberExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> se establece en <paramref name="expression" /> y cuya propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> se establece en <see cref="T:System.Reflection.PropertyInfo" /> o <see cref="T:System.Reflection.FieldInfo" />, que representa la propiedad o el campo denotada por <paramref name="propertyOrFieldName" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> cuyo <see cref="P:System.Linq.Expressions.Expression.Type" /> contiene una propiedad o un campo denominado <paramref name="propertyOrFieldName" />.Puede ser null para los miembros estáticos.</param>
      <param name="propertyOrFieldName">Nombre de una propiedad o un campo al que se va a obtener acceso.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="propertyOrFieldName" /> es null.</exception>
      <exception cref="T:System.ArgumentException">No se ha definido ninguna propiedad o campo denominado <paramref name="propertyOrFieldName" /> en <paramref name="expression" />.Type o sus tipos base.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> está establecida en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Reduce">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceAndCheck">
      <summary>Reduce este nodo a una expresión más simple.Si CanReduce devuelve true, debería devolver una expresión válida.Este método puede devolver otro nodo que se debe reducir a su vez.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReduceExtensions">
      <summary>Reduce la expresión a un tipo de nodo conocido (no es un nodo de extensión) o, si ya es un tipo conocido, solo devuelve la expresión.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de igualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ReferenceNotEqual(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una comparación de desigualdad de referencia.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Rethrow(System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción con un tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un reinicio de una excepción.</returns>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.Se puede especificar el valor que se pasa a la etiqueta cuando se produce el salto.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Continue, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y <paramref name="value" /> que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="value">Valor que se va a pasar a la etiqueta asociada cuando se produzca el salto.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Return(System.Linq.Expressions.LabelTarget,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción Return con el tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpression" /> con <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> igual a Return, la propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> establecida en <paramref name="target" />, la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" /> establecida en <paramref name="type" /> y un valor null que se va a pasar a la etiqueta de destino cuando se produzca el salto.</returns>
      <param name="target">Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> al que saltará el objeto <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la derecha.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de desplazamiento a la derecha para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShift(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de desplazamiento a la derecha.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de desplazamiento a la derecha definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de asignación de desplazamiento a la derecha.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de asignación de desplazamiento a la derecha.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RightShiftAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación bit a bit de asignación de desplazamiento a la derecha.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
      <param name="variables">Colección de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se van a usar para rellenar la colección <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.RuntimeVariables(System.Linq.Expressions.ParameterExpression[])">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Instancia de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> y cuya propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> está establecida en el valor especificado.</returns>
      <param name="variables">Matriz de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se va a usar para rellenar la colección de <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resta aritmética sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de resta para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Subtract(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resta aritmética sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta sin comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssign(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta sin comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractAssignChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.LambdaExpression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de asignación de resta con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> se establecen en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <param name="conversion">Objeto <see cref="T:System.Linq.Expressions.LambdaExpression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resta aritmética con comprobación de desbordamiento.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No se ha definido el operador de resta para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SubtractChecked(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> que representa una operación de resta aritmética con comprobación de desbordamiento.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.BinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> y <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="left">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />.</param>
      <param name="right">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="left" /> o <paramref name="right" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente dos argumentos.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador de resta definido para <paramref name="left" />.Type y <paramref name="right" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Linq.Expressions.Expression,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch sin un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase})">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Switch(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.SwitchCase[])">
      <summary>Crea una clase <see cref="T:System.Linq.Expressions.SwitchExpression" /> que representa una instrucción switch que tiene un caso predeterminado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchExpression" /> creado.</returns>
      <param name="type">Tipo de resultado del modificador.</param>
      <param name="switchValue">Valor que se va a probar con respecto a cada caso.</param>
      <param name="defaultBody">Resultado del modificador si <paramref name="switchValue" /> no coincide con ninguno de los casos.</param>
      <param name="comparison">Método de comparación de igualdad que se va a usar.</param>
      <param name="cases">Conjunto de casos para esta expresión switch.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a utilizar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SwitchCase(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> que se va a usar en un objeto <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.SwitchCase" /> creado.</returns>
      <param name="body">Cuerpo del caso.</param>
      <param name="testValues">Valores de prueba del caso.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuya propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> se establece en el valor especificado.</returns>
      <param name="fileName">Objeto <see cref="T:System.String" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> se establecen en el valor especificado.</returns>
      <param name="fileName">Objeto <see cref="T:System.String" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> se establecen en el valor especificado.</returns>
      <param name="fileName">Objeto <see cref="T:System.String" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.SymbolDocument(System.String,System.Guid,System.Guid,System.Guid)">
      <summary>Crea una instancia de <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> cuyas propiedades <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />, <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> y <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> se establecen en el valor especificado.</returns>
      <param name="fileName">Objeto <see cref="T:System.String" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />.</param>
      <param name="language">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />.</param>
      <param name="languageVendor">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />.</param>
      <param name="documentType">Objeto <see cref="T:System.Guid" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Un objeto <see cref="T:System.Linq.Expressions.Expression" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Throw(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa un inicio de una excepción con un tipo especificado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa la excepción.</returns>
      <param name="value">Un objeto <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.Expression" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatch(System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y ningún bloque fault ni finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryCatchFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.CatchBlock[])">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con cualquier número de instrucciones Catch y un bloque finally.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
      <param name="handlers">Matriz de cero o más expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> que representa las instrucciones Catch que se van a asociar al bloque Try.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFault(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque fault y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="fault">Cuerpo del bloque fault.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryFinally(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TryExpression" /> que representa un bloque try con un bloque finally y ninguna instrucción Catch.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TryExpression" /> creado.</returns>
      <param name="body">Cuerpo del bloque try.</param>
      <param name="finally">Cuerpo del bloque finally.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetActionType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Action genérico con argumentos de tipo específicos.</summary>
      <returns>true si el tipo de delegado genérico System.Action se creó para <paramref name="typeArgs" /> concretos; de lo contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Action.</param>
      <param name="actionType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Action con argumentos de tipo concretos.Contiene null si no hay ningún delegado genérico System.Action que coincida con <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TryGetFuncType(System.Type[],System.Type@)">
      <summary>Crea un objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> que representa un tipo de delegado System.Func genérico con argumentos de tipo específicos.El último argumento de tipo especifica el tipo de valor devuelto del delegado creado.</summary>
      <returns>true si el tipo de delegado genérico System.Func se creó para <paramref name="typeArgs" /> concretos; de lo contrario, false.</returns>
      <param name="typeArgs">Matriz de objetos Type que especifica los argumentos de tipo para el tipo de delegado System.Func.</param>
      <param name="funcType">Cuando este método devuelve el resultado, contiene el tipo de delegado genérico System.Func con argumentos de tipo concretos.Contiene null si no hay ningún delegado genérico System.Func que coincida con <paramref name="typeArgs" />. Este parámetro se pasa sin inicializar.</param>
    </member>
    <member name="P:System.Linq.Expressions.Expression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeAs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una referencia explícita o conversión boxing donde se proporciona el valor null si se produce un error en la conversión.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.Expression.Type" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="type">Objeto <see cref="T:System.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.Expression.Type" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> que compara la identidad de tipo en tiempo de ejecución.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />, y cuyas propiedades <see cref="T:System.Linq.Expressions.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="T:System.Linq.Expressions.Expression" />.</param>
      <param name="type">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.TypeIs(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" />, y cuyas propiedades <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> y <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> se establecen en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />.</param>
      <param name="type">Objeto <see cref="P:System.Linq.Expressions.Expression.Type" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> o <paramref name="type" /> es null.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuya propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> está establecida en el valor especificado.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.InvalidOperationException">No hay ningún operador unario más definido para <paramref name="expression" />.Type.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.UnaryPlus(System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una operación unaria más.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.UnaryExpression" /> cuya propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es igual a <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> y cuyas propiedades <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> y <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> están establecidas en los valores especificados.</returns>
      <param name="expression">Objeto <see cref="T:System.Linq.Expressions.Expression" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />.</param>
      <param name="method">Objeto <see cref="T:System.Reflection.MethodInfo" /> en el que se va a establecer la propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="expression" /> es null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="method" /> no es null y el método que representa devuelve void, no es static (Shared en Visual Basic) o no toma exactamente un argumento.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="method" /> es null y no hay ningún operador unario más definido para <paramref name="expression" />.Type.-O bien-<paramref name="expression" />.Type (o su correspondiente tipo que no acepta valores NULL si se trata de un tipo de valor que acepta valores NULL) no puede asignarse al tipo de argumento del método representado por <paramref name="method" />.</exception>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Unbox(System.Linq.Expressions.Expression,System.Type)">
      <summary>Crea un objeto <see cref="T:System.Linq.Expressions.UnaryExpression" /> que representa una conversión unboxing explícita.</summary>
      <returns>Una instancia de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
      <param name="expression">
        <see cref="T:System.Linq.Expressions.Expression" /> al que se va a aplicar la conversión unboxing.</param>
      <param name="type">Nuevo objeto <see cref="T:System.Type" /> de la expresión.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se puede usar para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.Variable(System.Type,System.String)">
      <summary>Crea un nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> que se puede usar para identificar un parámetro o una variable en un árbol de expresión.</summary>
      <returns>Nodo <see cref="T:System.Linq.Expressions.ParameterExpression" /> con el nombre y tipo especificados.</returns>
      <param name="type">Tipo del parámetro o variable.</param>
      <param name="name">Nombre del parámetro o la variable.Este nombre se emplea únicamente para depurar o imprimir.</param>
    </member>
    <member name="M:System.Linq.Expressions.Expression.VisitChildren(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Reduce el nodo y, a continuación, llama al delegado del visitante en la expresión reducida.El método inicia una excepción si el nodo no es reducible.</summary>
      <returns>Expresión que se está visitando o una expresión que debería sustituirla en el árbol.</returns>
      <param name="visitor">Una instancia de <see cref="T:System.Func`2" />.</param>
    </member>
    <member name="T:System.Linq.Expressions.Expression`1">
      <summary>Representa una expresión lambda fuertemente tipada como una estructura de datos en el formato de árbol de expresión.Esta clase no se puede heredar.</summary>
      <typeparam name="TDelegate">Tipo de delegado que <see cref="T:System.Linq.Expressions.Expression`1" /> representa.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Compile">
      <summary>Compila la expresión lambda descrita por el árbol de la expresión en el código ejecutable y genera un delegado que representa la expresión lambda.</summary>
      <returns>Delegado de tipo <paramref name="TDelegate" /> que representa la expresión lambda compilada descrita por <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
    </member>
    <member name="M:System.Linq.Expressions.Expression`1.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> del resultado.</param>
      <param name="parameters">Propiedad <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> del resultado. </param>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionType">
      <summary>Describe los tipos de nodo para los nodos de un árbol de expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Add">
      <summary>Operación de suma, como a + b, sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssign">
      <summary>Operación de asignación compuesta de suma, como (a += b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddAssignChecked">
      <summary>Operación de asignación compuesta de suma, como (a += b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AddChecked">
      <summary>Operación de suma, como (a + b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.And">
      <summary>Operación AND bit a bit o lógica, como (a &amp; b) en C# y (a And b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAlso">
      <summary>Operación AND condicional que evalúa el segundo operando solo si el primer operando se evalúa como true.Corresponde a (a &amp;&amp; b) en C# y a (a AndAlso b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.AndAssign">
      <summary>Operación de asignación compuesta AND bit a bit o lógica, como (a &amp;= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayIndex">
      <summary>Operación de indización en una matriz unidimensional, como array[index] en C# o array(index) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ArrayLength">
      <summary>Operación que obtiene la longitud de una matriz unidimensional, como array.Length.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Assign">
      <summary>Operación de asignación, como (a = b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Block">
      <summary>Representa un bloque de expresiones.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Call">
      <summary>Llamada de método, como en la expresión obj.sampleMethod().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Coalesce">
      <summary>Nodo que representa una operación de uso combinado de Null, como (a ?? b) en C# o If(a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Conditional">
      <summary>Operación condicional, como a &gt; b ? a : b en C# o If(a &gt; b, a, b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Constant">
      <summary>Representa un valor constante.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Convert">
      <summary>Operación de conversión, como (SampleType)obj en C# o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, si el valor convertido es demasiado grande para el tipo de destino, no se produce ninguna excepción.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ConvertChecked">
      <summary>Operación de conversión, como (SampleType)obj en C# o CType(obj, SampleType) en Visual Basic.Para una conversión numérica, se produce una excepción si el valor convertido no se ajusta al tipo de destino.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DebugInfo">
      <summary>Representa información de depuración.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Decrement">
      <summary>Operación de decremento unario, como (a - 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Default">
      <summary>Representa un valor predeterminado.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Divide">
      <summary>Operación de división, como (a / b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.DivideAssign">
      <summary>Operación de asignación compuesta de división, como (a /= b), para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Dynamic">
      <summary>Representa una operación dinámica.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Equal">
      <summary>Nodo que representa una comparación de igualdad, como (a == b) en C# o (a = b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOr">
      <summary>Operación XOR bit a bit o lógica, como (a ^ b) en C# o (a Xor b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign">
      <summary>Operación de asignación compuesta XOR bit a bit o lógica, como (a ^= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Extension">
      <summary>Representa una expresión de extensión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Goto">
      <summary>Expresión "ir a", como goto Label en C# o GoTo Label en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThan">
      <summary>Comparación "mayor que", como (a &gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual">
      <summary>Comparación "mayor o igual que", como (a &gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Increment">
      <summary>Operación de incremento unario, como (a + 1) en C# y Visual Basic.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Index">
      <summary>Operación de índice u operación que tiene acceso a una propiedad que admite argumentos. </summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Invoke">
      <summary>Operación que invoca un delegado o una expresión lambda, como sampleDelegate.Invoke().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsFalse">
      <summary>Valor de condición que no se cumple (false).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.IsTrue">
      <summary>Valor de condición que se cumple (true).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Label">
      <summary>Representa una etiqueta.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Lambda">
      <summary>Operación lambda, como a =&gt; a + a en C# o Function(a) a + a en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShift">
      <summary>Operación de desplazamiento a la izquierda bit a bit, como (a &lt;&lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign">
      <summary>Asignación compuesta y desplazamiento a la izquierda bit a bit, como (a &lt;&lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThan">
      <summary>Comparación "menor que", como (a &lt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual">
      <summary>Comparación "menor o igual que", como (a &lt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ListInit">
      <summary>Operación que crea un nuevo objeto <see cref="T:System.Collections.IEnumerable" /> y lo inicializa desde una lista de elementos, como new List&lt;SampleType&gt;(){ a, b, c } en C# o Dim sampleList = { a, b, c } en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Loop">
      <summary>Bucle, como for o while.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberAccess">
      <summary>Operación que realiza la lectura de un campo o una propiedad, como obj.SampleProperty.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MemberInit">
      <summary>Operación que crea un nuevo objeto e inicializa uno o más de sus miembros, como new Point { X = 1, Y = 2 } en C# o New Point With {.X = 1, .Y = 2} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Modulo">
      <summary>Operación de resto aritmético, como (a % b) en C# o (a Mod b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.ModuloAssign">
      <summary>Operación de asignación compuesta y resto aritmético, como (a %= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Multiply">
      <summary>Operación de multiplicación, como (a * b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssign">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked">
      <summary>Operación de asignación compuesta de multiplicación, como (a *= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.MultiplyChecked">
      <summary>Operación de multiplicación, como (a * b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Negate">
      <summary>Operación de negación aritmética, como (-a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NegateChecked">
      <summary>Operación de negación aritmética, como (-a), con comprobación de desbordamiento.El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.New">
      <summary>Operación que llama a un constructor para crear un nuevo objeto, como new SampleType().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayBounds">
      <summary>Operación que crea una nueva matriz en la que se especifican los límites de cada dimensión, como new SampleType[dim1, dim2] en C# o New SampleType(dim1, dim2) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NewArrayInit">
      <summary>Operación que crea una nueva matriz unidimensional y la inicializa a partir de una lista de elementos, como new SampleType[]{a, b, c} en C# o New SampleType(){a, b, c} en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Not">
      <summary>Representa una operación de complemento bit a bit o de negación lógica.En C#, su equivalente es (~a) para los tipos enteros y (!a) para los valores booleanos.En Visual Basic, su equivalente es (Not a).El objeto a no se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.NotEqual">
      <summary>Comparación de desigualdad, como (a != b) en C# o (a &lt;&gt; b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OnesComplement">
      <summary>Operación de complemento a unos, como (~a) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Or">
      <summary>Operación OR bit a bit o lógica, como (a | b) en C# o (a Or b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrAssign">
      <summary>Asignación compuesta OR bit a bit o lógica, como (a |= b) en C#.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.OrElse">
      <summary>Operación OR condicional de cortocircuito, como (a || b) en C# o (a OrElse b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Parameter">
      <summary>Referencia a un parámetro o variable que se define en el contexto de la expresión.Para obtener más información, vea <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostDecrementAssign">
      <summary>Postfijo de decremento unario, como (a--).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PostIncrementAssign">
      <summary>Postfijo de incremento unario, como (a++).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Power">
      <summary>Operación matemática que eleva un número a una potencia, como (a ^ b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PowerAssign">
      <summary>Operación de asignación compuesta que eleva un número a una potencia, como (a ^= b) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreDecrementAssign">
      <summary>Prefijo de decremento unario, como (--a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.PreIncrementAssign">
      <summary>Prefijo de incremento unario, como (++a).El objeto a se debe modificar en contexto.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Quote">
      <summary>Expresión que tiene un valor constante de tipo <see cref="T:System.Linq.Expressions.Expression" />.Un nodo <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> puede contener referencias a parámetros definidos en el contexto de la expresión que representa.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShift">
      <summary>Operación de desplazamiento a la derecha bit a bit, como (a &gt;&gt; b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RightShiftAssign">
      <summary>Operación de asignación compuesta y desplazamiento a la derecha bit a bit, como (a &gt;&gt;= b).</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.RuntimeVariables">
      <summary>Lista de variables en tiempo de ejecución.Para obtener más información, vea <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Subtract">
      <summary>Operación de resta, como (a - b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssign">
      <summary>Operación de asignación compuesta de resta, como (a -= b), sin comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked">
      <summary>Operación de asignación compuesta de resta, como (a -= b), con comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.SubtractChecked">
      <summary>Operación de resta aritmética, como (a - b), que tiene comprobación de desbordamiento, para operandos numéricos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Switch">
      <summary>Operación de modificador, como switch en C# o Select Case en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Throw">
      <summary>Operación que inicia una excepción, como throw new Exception().</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Try">
      <summary>Expresión try-catch.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeAs">
      <summary>Referencia explícita o una conversión boxing en la que se proporciona el valor null si se produce un error en la conversión, como (obj as SampleType) en C# o TryCast(obj, SampleType) en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeEqual">
      <summary>Representa una prueba para comprobar la exactitud del tipo.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.TypeIs">
      <summary>Prueba de tipo, como obj is SampleType en C# o TypeOf obj is SampleType en Visual Basic.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.UnaryPlus">
      <summary>Operación unaria +, como (+a).El resultado de una operación unaria + predefinida es el valor del operando, pero las implementaciones definidas por el usuario podrían tener resultados poco habituales.</summary>
    </member>
    <member name="F:System.Linq.Expressions.ExpressionType.Unbox">
      <summary>Operación de conversión unboxing a un tipo de valor, como las instrucciones unbox y unbox.any en MSIL. </summary>
    </member>
    <member name="T:System.Linq.Expressions.ExpressionVisitor">
      <summary>Representa un visitante o un objeto de reescritura de árboles de expresión.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.#ctor">
      <summary>Inicializa una nueva instancia de <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>Envía la lista de expresiones a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Lista de expresiones modificada, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de expresiones original.</returns>
      <param name="nodes">Expresiones que se van a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.Func{``0,``0})">
      <summary>Visita todos los nodos de la colección utilizando un visitante de elementos especificado.</summary>
      <returns>Lista de nodos modificados, si se modificó alguno de los elementos; de lo contrario, devuelve la lista de nodos original.</returns>
      <param name="nodes">Nodos que se van a visitar.</param>
      <param name="elementVisitor">Delegado que visita un único elemento, reemplazándolo opcionalmente con un elemento nuevo.</param>
      <typeparam name="T">Tipo de los nodos.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>Envía la expresión a uno de los métodos de visita más especializados de esta clase.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(System.Collections.ObjectModel.ReadOnlyCollection{``0},System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="nodes">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitAndConvert``1(``0,System.String)">
      <summary>Visita una expresión, convirtiendo de nuevo el resultado al tipo de expresión original.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <param name="callerName">Nombre del método de llamada; se utiliza para notificar un mensaje de error mejor.</param>
      <typeparam name="T">Tipo de la expresión.</typeparam>
      <exception cref="T:System.InvalidOperationException">El método Visit para este nodo devolvió un tipo diferente.</exception>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitBlock(System.Linq.Expressions.BlockExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitCatchBlock(System.Linq.Expressions.CatchBlock)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDebugInfo(System.Linq.Expressions.DebugInfoExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitDefault(System.Linq.Expressions.DefaultExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitElementInit(System.Linq.Expressions.ElementInit)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitExtension(System.Linq.Expressions.Expression)">
      <summary>Visita los elementos secundarios de la expresión de extensión.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitGoto(System.Linq.Expressions.GotoExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitIndex(System.Linq.Expressions.IndexExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabel(System.Linq.Expressions.LabelExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLabelTarget(System.Linq.Expressions.LabelTarget)">
      <summary>Visita <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
      <typeparam name="T">Tipo del delegado.</typeparam>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitLoop(System.Linq.Expressions.LoopExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberBinding(System.Linq.Expressions.MemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>Visita <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitRuntimeVariables(System.Linq.Expressions.RuntimeVariablesExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitch(System.Linq.Expressions.SwitchExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitSwitchCase(System.Linq.Expressions.SwitchCase)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTry(System.Linq.Expressions.TryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitTypeBinary(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="M:System.Linq.Expressions.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>Visita los elementos secundarios de <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
      <returns>Expresión modificada si se ha modificado esta expresión o una subexpresión cualquiera; de lo contrario, devuelve la expresión original.</returns>
      <param name="node">Expresión que se va a visitar.</param>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpression">
      <summary>Representa un salto incondicional.Esto incluye instrucciones return, break y continue, y otros saltos.</summary>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Kind">
      <summary>Tipo de la expresión "ir a".Solo tiene fines informativos.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> que representa el tipo de la expresión "ir a".</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Target">
      <summary>Etiqueta de destino a donde salta este nodo.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa la etiqueta de destino para este nodo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.GotoExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> del resultado. </param>
      <param name="value">Propiedad <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> del resultado. </param>
    </member>
    <member name="P:System.Linq.Expressions.GotoExpression.Value">
      <summary>Valor pasado al destino o null si el destino es de tipo System.Void.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor pasado al destino o null.</returns>
    </member>
    <member name="T:System.Linq.Expressions.GotoExpressionKind">
      <summary>Especifica qué tipo de salto representa esta clase <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Break">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción break.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Continue">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción continue.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Goto">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa un salto a alguna ubicación.</summary>
    </member>
    <member name="F:System.Linq.Expressions.GotoExpressionKind.Return">
      <summary>
        <see cref="T:System.Linq.Expressions.GotoExpression" /> que representa una instrucción return.</summary>
    </member>
    <member name="T:System.Linq.Expressions.IndexExpression">
      <summary>Representa la indización de una propiedad o una matriz.</summary>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Arguments">
      <summary>Obtiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</summary>
      <returns>Colección de solo lectura que contiene los argumentos que se utilizarán para indizar la propiedad o la matriz.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Indexer">
      <summary>Obtiene <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</summary>
      <returns>
        <see cref="T:System.Reflection.PropertyInfo" /> para la propiedad si la expresión representa una propiedad indizada; de lo contrario, devuelve null.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Object">
      <summary>Objeto que se va a indizar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto que se va a indizar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.IndexExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.IndexExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.InvocationExpression">
      <summary>Representa una expresión que aplica un delegado o una expresión lambda a una lista de expresiones de argumento.</summary>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Arguments">
      <summary>Obtiene los argumentos a los que se aplica el delegado o la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos a los que se aplica el delegado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Expression">
      <summary>Obtiene el delegado o la expresión lambda que se van a aplicar.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el delegado que se va a aplicar.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.InvocationExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.InvocationExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelExpression">
      <summary>Representa una etiqueta, que se puede colocar en cualquier contexto de <see cref="T:System.Linq.Expressions.Expression" />.Si se salta a ella, obtendrá el valor proporcionado por la clase <see cref="T:System.Linq.Expressions.GotoExpression" /> correspondiente.De lo contrario, recibe el valor de <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />.Si <see cref="T:System.Type" /> es igual a System.Void, no se debe proporcionar ningún valor.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.DefaultValue">
      <summary>Valor de <see cref="T:System.Linq.Expressions.LabelExpression" /> cuando se llega a la etiqueta mediante el flujo de control normal (por ejemplo, no se salta a ella).</summary>
      <returns>Objeto Expression que representa el valor de la clase <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Target">
      <summary>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</summary>
      <returns>Clase <see cref="T:System.Linq.Expressions.LabelTarget" /> a la que está asociada esta etiqueta.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="target">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> del resultado.</param>
      <param name="defaultValue">Propiedad <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LabelTarget">
      <summary>Se utiliza para representar el destino de <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Name">
      <summary>Obtiene el nombre de la etiqueta.</summary>
      <returns>Nombre de la etiqueta.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LabelTarget.ToString">
      <summary>Devuelve una instancia de <see cref="T:System.String" /> que representa el objeto <see cref="T:System.Object" /> actual.</summary>
      <returns>
        <see cref="T:System.String" /> que representa el actual elemento <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LabelTarget.Type">
      <summary>Tipo de valor que se pasa al saltar a la etiqueta (o <see cref="T:System.Void" /> si no se debe pasar ningún valor).</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo del valor que se pasa al saltar a la etiqueta o <see cref="T:System.Void" /> si no se debe pasar ningún valor.</returns>
    </member>
    <member name="T:System.Linq.Expressions.LambdaExpression">
      <summary>Describe una expresión lambda.Captura un bloque de código similar a un cuerpo de método de .NET.</summary>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Body">
      <summary>Obtiene el cuerpo de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo de la expresión lambda.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LambdaExpression.Compile">
      <summary>Genera un delegado que representa la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que contiene la versión compilada de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Name">
      <summary>Obtiene el nombre de la expresión lambda.</summary>
      <returns>Nombre de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Parameters">
      <summary>Obtiene los parámetros de la expresión lambda.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.ReturnType">
      <summary>Obtiene el tipo de valor devuelto de la expresión lambda.</summary>
      <returns>Objeto <see cref="T:System.Type" /> que representa el tipo de la expresión lambda.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.TailCall">
      <summary>Obtiene el valor que indica si la expresión lambda se compilará con la optimización de llamada de cola.</summary>
      <returns>Es true si la expresión lambda se compilará con la optimización de llamada de cola; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LambdaExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.ListInitExpression">
      <summary>Representa una llamada a un constructor que tiene un inicializador de colección.</summary>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Initializers">
      <summary>Obtiene los inicializadores de elementos que se usan para inicializar una colección.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> que representan los elementos que se usan para inicializar la colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NewExpression">
      <summary>Obtiene la expresión que contiene una llamada al constructor de un tipo de colección.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor de un tipo de colección.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Reduce">
      <summary>Reduce el nodo de expresión binario a una expresión más sencilla.</summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ListInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.ListInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> del resultado.</param>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.LoopExpression">
      <summary>Representa un bucle infinito.Se puede salir del mismo con "break".</summary>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Body">
      <summary>Obtiene el <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que es el cuerpo del bucle.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.BreakLabel">
      <summary>Obtiene el <see cref="T:System.Linq.Expressions.LabelTarget" /> usado por el cuerpo del bucle como destino de la instrucción break.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> usado por el cuerpo del bucle como destino de la instrucción break.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.ContinueLabel">
      <summary>Obtiene el <see cref="T:System.Linq.Expressions.LabelTarget" /> usado por el cuerpo del bucle como destino de la instrucción continue.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.LabelTarget" /> usado por el cuerpo del bucle como destino de la instrucción continue.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.LoopExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.LoopExpression.Update(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="breakLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> del resultado.</param>
      <param name="continueLabel">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberAssignment">
      <summary>Representa la operación de asignación de un campo o propiedad de un objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberAssignment.Expression">
      <summary>Obtiene la expresión que se asigna al campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el valor que se asigna al campo o propiedad.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberAssignment.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberBinding">
      <summary>Proporciona la clase base de la que derivan las clases que representan enlaces que se utilizan para inicializar miembros de un objeto recientemente creado.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.#ctor(System.Linq.Expressions.MemberBindingType,System.Reflection.MemberInfo)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <param name="type">
        <see cref="T:System.Linq.Expressions.MemberBindingType" /> que discrimina el tipo de enlace que se representa.</param>
      <param name="member">
        <see cref="T:System.Reflection.MemberInfo" /> que representa un campo o propiedad que va a inicializarse.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.BindingType">
      <summary>Obtiene el tipo de enlace que se representa.</summary>
      <returns>Uno de los valores de <see cref="T:System.Linq.Expressions.MemberBindingType" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberBinding.Member">
      <summary>Obtiene el campo o la propiedad que se va a inicializar.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o propiedad que va a inicializarse.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberBinding.ToString">
      <summary>Devuelve una representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
      <returns>Representación textual de <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
    </member>
    <member name="T:System.Linq.Expressions.MemberBindingType">
      <summary>Describe los tipos de enlace que se utilizan en objetos <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.Assignment">
      <summary>Un enlace que representa la inicialización de un miembro con el valor de una expresión.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.ListBinding">
      <summary>Un enlace que representa la inicialización de un miembro de tipo <see cref="T:System.Collections.IList" /> o <see cref="T:System.Collections.Generic.ICollection`1" /> de una lista de elementos.</summary>
    </member>
    <member name="F:System.Linq.Expressions.MemberBindingType.MemberBinding">
      <summary>Un enlace que representa la inicialización de forma recursiva de los miembros de un miembro.</summary>
    </member>
    <member name="T:System.Linq.Expressions.MemberExpression">
      <summary>Representa el acceso a un campo o propiedad.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Expression">
      <summary>Obtiene el objeto contenedor del campo o propiedad.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto contenedor del campo o propiedad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.Member">
      <summary>Obtiene el campo o la propiedad a los que se va a tener acceso.</summary>
      <returns>
        <see cref="T:System.Reflection.MemberInfo" /> que representa el campo o la propiedad a los que se va a obtener acceso.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberInitExpression">
      <summary>Representa la llamada a un constructor y la inicialización de uno o más miembros del nuevo objeto.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros del objeto recientemente creado.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir el nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NewExpression">
      <summary>Obtiene la expresión que representa la llamada al constructor.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.NewExpression" /> que representa la llamada al constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Reduce">
      <summary>Reduce <see cref="T:System.Linq.Expressions.MemberInitExpression" /> a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MemberInitExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberInitExpression.Update(System.Linq.Expressions.NewExpression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="newExpression">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> del resultado.</param>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberListBinding">
      <summary>Representa la inicialización de los elementos de un miembro de colección de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberListBinding.Initializers">
      <summary>Obtiene los inicializadores de elemento para inicializar un miembro de colección de un objeto que se acaba de crear.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.ElementInit" /> con que se inicializa un miembro de colección.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberListBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ElementInit})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="initializers">Propiedad <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MemberMemberBinding">
      <summary>Representa la inicialización de los miembros de un miembro de un objeto que se acaba de crear.</summary>
    </member>
    <member name="P:System.Linq.Expressions.MemberMemberBinding.Bindings">
      <summary>Obtiene los enlaces que describen cómo inicializar los miembros de un miembro.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de los objetos <see cref="T:System.Linq.Expressions.MemberBinding" /> que describen cómo inicializar los miembros del miembro.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MemberMemberBinding.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.MemberBinding})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="bindings">Propiedad <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.MethodCallExpression">
      <summary>Representa una llamada a un método estático o un método de instancia.</summary>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Arguments">
      <summary>Obtiene una colección de expresiones que representan los argumentos del método invocado.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos del método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Method">
      <summary>Obtiene el <see cref="T:System.Reflection.MethodInfo" /> del método al que se va a llamar.</summary>
      <returns>
        <see cref="T:System.Reflection.MethodInfo" /> que representa el método llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Object">
      <summary>Obtiene el <see cref="T:System.Linq.Expressions.Expression" /> que representa la instancia para llamadas a métodos de instancia o null para llamadas a métodos estáticos.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el objeto receptor del método.</returns>
    </member>
    <member name="P:System.Linq.Expressions.MethodCallExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.MethodCallExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="object">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> del resultado.</param>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewArrayExpression">
      <summary>Representa creando una nueva matriz y posiblemente inicializando los elementos de la nueva matriz.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Expressions">
      <summary>Obtiene los límites de la matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, o los valores para inicializar los elementos de la nueva matriz si el valor de la propiedad <see cref="P:System.Linq.Expressions.Expression.NodeType" /> es <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
      <returns>
        <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los límites de la matriz o los valores de inicialización.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewArrayExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewArrayExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expressions">Propiedad <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.NewExpression">
      <summary>Representa una llamada de constructor.</summary>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Arguments">
      <summary>Obtiene los argumentos para el constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Linq.Expressions.Expression" /> que representan los argumentos para el constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Constructor">
      <summary>Obtiene el constructor al que se llama.</summary>
      <returns>
        <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor llamado.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Members">
      <summary>Obtiene los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</summary>
      <returns>Una colección de objetos <see cref="T:System.Reflection.MemberInfo" /> que representan los miembros que pueden recuperar los valores de los campos que se inicializaron con argumentos de constructor.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.NewExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.NewExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.NewExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="arguments">Propiedad <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.ParameterExpression">
      <summary>Representa una expresión de parámetro con nombre.</summary>
    </member>
    <member name="M:System.Linq.Expressions.ParameterExpression.Accept(System.Linq.Expressions.ExpressionVisitor)">
      <summary>Envía la expresión al método de visita específico de este tipo de nodo.Por ejemplo, el objeto <see cref="T:System.Linq.Expressions.MethodCallExpression" /> llama al método <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
      <returns>Resultado de visitar este nodo.</returns>
      <param name="visitor">Visitante con el que se va a visitar este nodo.</param>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.IsByRef">
      <summary>Indica que esta clase ParameterExpression se va a tratar como un parámetro ByRef.</summary>
      <returns>Es true si este objeto ParameterExpression es un parámetro ByRef; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Name">
      <summary>Obtiene el nombre del parámetro o variable.</summary>
      <returns>
        <see cref="T:System.String" /> que contiene el nombre del parámetro.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.ParameterExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="T:System.Linq.Expressions.RuntimeVariablesExpression">
      <summary>Expresión que proporciona permiso de lectura y escritura en tiempo de ejecución para variables.</summary>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.RuntimeVariablesExpression.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="variables">Propiedad <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> del resultado.</param>
    </member>
    <member name="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables">
      <summary>Variables o parámetros para los que se va a proporcionar acceso en tiempo de ejecución.</summary>
      <returns>Colección de solo lectura que contiene parámetros para los que se proporcionará acceso en tiempo de ejecución.</returns>
    </member>
    <member name="T:System.Linq.Expressions.SwitchCase">
      <summary>Representa un caso de una clase <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.Body">
      <summary>Obtiene el cuerpo de este caso.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque de casos.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchCase.TestValues">
      <summary>Obtiene los valores de este caso.Este caso se selecciona para su ejecución cuando <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> coincide con cualquiera de estos valores.</summary>
      <returns>Colección de solo lectura de los valores para este bloque de casos.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.ToString">
      <summary>Devuelve una instancia de <see cref="T:System.String" /> que representa el objeto <see cref="T:System.Object" /> actual.</summary>
      <returns>
        <see cref="T:System.String" /> que representa el elemento <see cref="T:System.Object" /> actual.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchCase.Update(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="testValues">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> del resultado.</param>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SwitchExpression">
      <summary>Representa una expresión de control que administra varias selecciones pasando el control a <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Cases">
      <summary>Obtiene la colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" /> del modificador.</summary>
      <returns>Colección de objetos <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Comparison">
      <summary>Obtiene el método de comparación de igualdad, si existe.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de comparación de igualdad.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.DefaultBody">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.SwitchValue">
      <summary>Obtiene la prueba para el modificador.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.Expression" /> que representa la prueba del modificador.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SwitchExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.SwitchExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.SwitchCase},System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="switchValue">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> del resultado.</param>
      <param name="cases">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> del resultado.</param>
      <param name="defaultBody">Propiedad <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.SymbolDocumentInfo">
      <summary>Almacena información necesaria para emitir información de símbolos de depuración para un archivo de código fuente, en particular el nombre de archivo y el identificador de idioma único.</summary>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType">
      <summary>Devuelve el identificador único del tipo de documento, si existe.Tiene como valor predeterminado el GUID para un archivo de texto.</summary>
      <returns>Identificador único del tipo de documento.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.FileName">
      <summary>Nombre del archivo de código fuente.</summary>
      <returns>Cadena que representa el nombre del archivo de código fuente.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.Language">
      <summary>Devuelve el identificador único del idioma, si existe.</summary>
      <returns>Identificador único del idioma.</returns>
    </member>
    <member name="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor">
      <summary>Devuelve el identificador único del proveedor de idioma, si existe.</summary>
      <returns>Identificador único del proveedor de idioma.</returns>
    </member>
    <member name="T:System.Linq.Expressions.TryExpression">
      <summary>Representa un bloque try/catch/finally/de errores.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Body">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el cuerpo del bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Fault">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque fault.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque fault.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Finally">
      <summary>Obtiene la clase <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el bloque finally.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Handlers">
      <summary>Obtiene la colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</summary>
      <returns>Colección de expresiones <see cref="T:System.Linq.Expressions.CatchBlock" /> asociadas al bloque try.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TryExpression.Update(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.CatchBlock},System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="body">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Body" /> del resultado.</param>
      <param name="handlers">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> del resultado.</param>
      <param name="finally">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> del resultado.</param>
      <param name="fault">Propiedad <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.TypeBinaryExpression">
      <summary>Representa una operación entre una expresión y un tipo.</summary>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Expression">
      <summary>Obtiene el operando de la expresión de una operación de prueba de un tipo.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la expresión de una operación de prueba de tipo.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta expresión.Los nodos de extensión deben devolver <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> al reemplazar este método.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.ExpressionType" /> de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand">
      <summary>Obtiene el operando de tipo de una operación de prueba de tipo.</summary>
      <returns>
        <see cref="T:System.Type" /> que representa el operando del tipo de una operación de prueba de tipo.</returns>
    </member>
    <member name="M:System.Linq.Expressions.TypeBinaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="expression">Propiedad <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> del resultado.</param>
    </member>
    <member name="T:System.Linq.Expressions.UnaryExpression">
      <summary>Representa una expresión que tiene un operador unario.</summary>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.CanReduce">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión se puede reducir.</summary>
      <returns>Es true si se puede reducir un nodo; de lo contrario, es false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLifted">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador.</summary>
      <returns>true si el nodo representa una llamada elevada; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.IsLiftedToNull">
      <summary>Obtiene un valor que indica si el nodo del árbol de expresión representa una llamada elevada a un operador cuyo tipo de valor devuelto se eleva a un tipo que acepta valores null.</summary>
      <returns>true si el tipo de valor devuelto del operador se eleva a un tipo que acepta valores NULL; de lo contrario, false.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Method">
      <summary>Obtiene el método de implementación para la operación unaria.</summary>
      <returns>Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de implementación.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.NodeType">
      <summary>Devuelve el tipo de nodo de esta clase <see cref="T:System.Linq.Expressions.Expression" />.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.ExpressionType" /> que representa esta expresión.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Operand">
      <summary>Obtiene el operando de la operación unaria.</summary>
      <returns>
        <see cref="T:System.Linq.Expressions.Expression" /> que representa el operando de la operación unaria.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Reduce">
      <summary>Reduce el nodo de expresión a una expresión más sencilla. </summary>
      <returns>Expresión reducida.</returns>
    </member>
    <member name="P:System.Linq.Expressions.UnaryExpression.Type">
      <summary>Obtiene el tipo estático de la expresión que <see cref="T:System.Linq.Expressions.Expression" /> representa.</summary>
      <returns>
        <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> que representa el tipo estático de la expresión.</returns>
    </member>
    <member name="M:System.Linq.Expressions.UnaryExpression.Update(System.Linq.Expressions.Expression)">
      <summary>Crea una nueva expresión que es como esta, pero usa el elemento secundario proporcionado.Si todos los elementos secundarios son iguales, devolverá esta expresión.</summary>
      <returns>Esta expresión si no se ha cambiado ningún elemento secundario o una expresión con los elementos secundarios actualizados.</returns>
      <param name="operand">Propiedad <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> del resultado.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite">
      <summary>Clase base de un sitio de llamada dinámico.Este tipo se utiliza como un tipo de parámetro para los destinos de sitio dinámico.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite.Binder">
      <summary>Clase responsable de operaciones dinámicas de enlace en el sitio dinámico.</summary>
      <returns>Objeto <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> responsable de operaciones dinámicas de enlace.</returns>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite.Create(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea un sitio de llamada con el tipo de delegado y el enlazador dados.</summary>
      <returns>Nuevo sitio de llamada.</returns>
      <param name="delegateType">Tipo de delegado del sitio de llamada.</param>
      <param name="binder">Enlazador del sitio de llamada.</param>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSite`1">
      <summary>Tipo de sitio dinámico.</summary>
      <typeparam name="T">Tipo de delegado.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSite`1.Create(System.Runtime.CompilerServices.CallSiteBinder)">
      <summary>Crea una instancia del sitio de llamada dinámico, inicializada con el enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</summary>
      <returns>Nueva instancia de sitio de llamada dinámico.</returns>
      <param name="binder">Enlazador responsable del enlace en tiempo de ejecución de las operaciones dinámicas en este sitio de llamada.</param>
    </member>
    <member name="F:System.Runtime.CompilerServices.CallSite`1.Target">
      <summary>Caché de nivel 0: un delegado especializado basado en el historial del sitio.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSite`1.Update">
      <summary>Delegado de actualización.Se le llama cuando el sitio dinámico experimenta líneas no ejecutadas de caché.</summary>
      <returns>Delegado de actualización.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteBinder">
      <summary>Clase responsable del enlace en tiempo de ejecución de las operaciones dinámicas en el sitio de llamada dinámico.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.Bind(System.Object[],System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.LabelTarget)">
      <summary>Realiza el enlace en tiempo de ejecución de la operación dinámica sobre un conjunto de argumentos.</summary>
      <returns>Expresión que realiza pruebas sobre los argumentos de la operación dinámica y realiza la operación dinámica si las pruebas son válidas.Si se produce un error en las pruebas en las repeticiones subsiguientes de la operación dinámica, se llamará de nuevo a Bind para generar una nueva clase <see cref="T:System.Linq.Expressions.Expression" /> para los nuevos tipos de argumento.</returns>
      <param name="args">Matriz de argumentos de la operación dinámica.</param>
      <param name="parameters">Matriz de instancias de <see cref="T:System.Linq.Expressions.ParameterExpression" /> que representan los parámetros del sitio de llamada en el proceso de enlace.</param>
      <param name="returnLabel">Objeto LabelTarget utilizado para devolver el resultado del enlace dinámico.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.BindDelegate``1(System.Runtime.CompilerServices.CallSite{``0},System.Object[])">
      <summary>Proporciona compatibilidad con el enlace en tiempo de ejecución de bajo nivel.Las clases pueden reemplazarlo y proporcionar un delegado directo para la implementación de la regla.Esto puede permitir guardar reglas en el disco, tener reglas especializadas disponibles en tiempo de ejecución o proporcionar una directiva de almacenamiento en memoria caché diferente.</summary>
      <returns>Nuevo delegado que reemplaza el destino del sitio de llamada.</returns>
      <param name="site">Sitio de llamada para el que se va a realizar el enlace.</param>
      <param name="args">Argumentos para el enlazador.</param>
      <typeparam name="T">Tipo de destino del sitio de llamada.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteBinder.CacheTarget``1(``0)">
      <summary>Agrega un destino a la memoria caché de destinos conocidos.Se examinarán los destinos almacenados en memoria caché antes de llamar a BindDelegate para generar la nueva regla.</summary>
      <param name="target">Delegado de destino que se va a agregar a la memoria caché.</param>
      <typeparam name="T">Tipo de destino que se va a agregar.</typeparam>
    </member>
    <member name="P:System.Runtime.CompilerServices.CallSiteBinder.UpdateLabel">
      <summary>Obtiene una etiqueta que se puede utilizar para provocar la actualización del enlace.Indica que el enlace de la expresión ya no es válido.Normalmente se utiliza cuando la "versión" de un objeto dinámico ha cambiado.</summary>
      <returns>Objeto <see cref="T:System.Linq.Expressions.LabelTarget" /> que representa una etiqueta que se puede utilizar para desencadenar la actualización del enlace.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.CallSiteHelpers">
      <summary>Clase que contiene métodos auxiliares para sitios de llamada DLR.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.CallSiteHelpers.IsInternalFrame(System.Reflection.MethodBase)">
      <summary>Comprueba si DLR usa internamente <see cref="T:System.Reflection.MethodBase" /> y no se debe mostrar en la pila del código de idioma.</summary>
      <returns>Es true si DLR usa internamente la clase <see cref="T:System.Reflection.MethodBase" /> de entrada y no se debe mostrar en la pila del código de idioma.De lo contrario, es false.</returns>
      <param name="mb">Entrada <see cref="T:System.Reflection.MethodBase" /></param>
    </member>
    <member name="T:System.Runtime.CompilerServices.DynamicAttribute">
      <summary>Indica que el uso de <see cref="T:System.Object" /> en un miembro significa que se tratará como un tipo enviado dinámicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.DynamicAttribute.#ctor(System.Boolean[])">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />.</summary>
      <param name="transformFlags">Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.DynamicAttribute.TransformFlags">
      <summary>Especifica, en un cruce seguro de prefijo de la construcción de un tipo, que las apariciones de <see cref="T:System.Object" /> deben tratarse como un tipo enviado dinámicamente.</summary>
      <returns>Lista de apariciones de <see cref="T:System.Object" /> que deben tratarse como un tipo enviado dinámicamente.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.ExecutionScope">
      <summary>Representa el estado en tiempo de ejecución de un método generado dinámicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.CreateDelegate(System.Int32,System.Object[])">
      <summary>Crea un delegado que se puede utilizar para ejecutar un método generado dinámicamente.</summary>
      <returns>
        <see cref="T:System.Delegate" /> que puede ejecutar un método generado dinámicamente.</returns>
      <param name="indexLambda">Índice del objeto que almacena información sobre la expresión lambda asociada del método dinámico.</param>
      <param name="locals">Matriz que contiene las variables locales activadas del contexto primario.</param>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.CreateHoistedLocals">
      <summary>Crea una matriz en la que se van a almacenar las variables locales activadas.</summary>
      <returns>Matriz en la que se van a almacenar las variables locales activadas.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Globals">
      <summary>Representa las constantes no triviales y las expresiones localmente ejecutables a las que hace referencia un método generado dinámicamente.</summary>
    </member>
    <member name="M:System.Runtime.CompilerServices.ExecutionScope.IsolateExpression(System.Linq.Expressions.Expression,System.Object[])">
      <summary>Libera el árbol de expresión especificado de las referencias de parámetro externas reemplazando el parámetro con su valor actual.</summary>
      <returns>Árbol de expresión que no contiene referencias de parámetro externas.</returns>
      <param name="expression">Árbol de expresión que se va a liberar de las referencias de parámetro externas.</param>
      <param name="locals">Matriz que contiene las variables locales activadas.</param>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Locals">
      <summary>Representa las variables locales activadas del contexto primario.</summary>
    </member>
    <member name="F:System.Runtime.CompilerServices.ExecutionScope.Parent">
      <summary>Representa el ámbito de ejecución del delegado de la llamada.</summary>
    </member>
    <member name="T:System.Runtime.CompilerServices.IStrongBox">
      <summary>Define una propiedad para tener acceso al valor al que hace referencia un objeto.</summary>
    </member>
    <member name="P:System.Runtime.CompilerServices.IStrongBox.Value">
      <summary>Obtiene o establece el valor al que hace referencia un objeto.</summary>
      <returns>El valor al que hace referencia un objeto.</returns>
    </member>
    <member name="T:System.Runtime.CompilerServices.StrongBox`1">
      <summary>Contiene una referencia a un valor.</summary>
      <typeparam name="T">Tipo del valor al que <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> hace referencia.</typeparam>
    </member>
    <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor"></member>
    <member name="M:System.Runtime.CompilerServices.StrongBox`1.#ctor(`0)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> usando el valor proporcionado. </summary>
      <param name="value">Valor al que <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> hará referencia.</param>
    </member>
    <member name="P:System.Runtime.CompilerServices.StrongBox`1.System#Runtime#CompilerServices#IStrongBox#Value">
      <summary>Obtiene o establece el valor al que <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> hace referencia.</summary>
      <returns>Valor al que <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> hace referencia.</returns>
    </member>
    <member name="F:System.Runtime.CompilerServices.StrongBox`1.Value">
      <summary>Representa el valor al que <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> hace referencia.</summary>
    </member>
    <member name="T:System.Security.Cryptography.AesManaged">
      <summary>Proporciona una implementación administrada del algoritmo simétrico del estándar de cifrado avanzado (AES). </summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.#ctor">
      <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Security.Cryptography.AesManaged" />.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor">
      <summary>Crea un objeto descifrador simétrico que utiliza la clave y el vector de inicialización (IV) actuales.</summary>
      <returns>Objeto descifrador simétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto descifrador simétrico que utiliza la clave y el vector de inicialización (IV) especificados.</summary>
      <returns>Objeto descifrador simétrico.</returns>
      <param name="key">La clave secreta que se va a utilizar para el algoritmo simétrico.</param>
      <param name="iv">El vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tamaño del vector de inicialización<paramref name=" iv " />no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor">
      <summary>Crea un objeto cifrador simétrico que utiliza la clave y el vector de inicialización (IV) actuales.</summary>
      <returns>Objeto cifrador simétrico.</returns>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])">
      <summary>Crea un objeto cifrador simétrico que utiliza la clave y el vector de inicialización (IV) especificados.</summary>
      <returns>Objeto cifrador simétrico.</returns>
      <param name="key">La clave secreta que se va a utilizar para el algoritmo simétrico.</param>
      <param name="iv">El vector de inicialización que se va a utilizar para el algoritmo simétrico.</param>
      <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es null.</exception>
      <exception cref="T:System.ArgumentException">El tamaño del vector de inicialización<paramref name=" iv " />no es válido.</exception>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateIV">
      <summary>Genera un vector de inicialización aleatorio (IV) que se utiliza para el algoritmo simétrico.</summary>
    </member>
    <member name="M:System.Security.Cryptography.AesManaged.GenerateKey">
      <summary>Genera una clave aleatoria que se utiliza para el algoritmo simétrico.</summary>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.IV">
      <summary>Obtiene o establece el vector de inicialización (IV) para el algoritmo simétrico.</summary>
      <returns>Vector de inicialización que se va a utilizar para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.Key">
      <summary>Obtiene o establece la clave secreta utilizada para el algoritmo simétrico.</summary>
      <returns>Clave para el algoritmo simétrico.</returns>
    </member>
    <member name="P:System.Security.Cryptography.AesManaged.KeySize">
      <summary>Obtiene o establece el tamaño de la clave secreta utilizada para el algoritmo simétrico, en bits. </summary>
      <returns>Tamaño de la clave que utiliza el algoritmo simétrico, en bits.</returns>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Especifica si el mismo subproceso puede entrar varias veces en un bloqueo.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Si un subproceso intenta entrar en un bloqueo de forma recursiva, se inicia una excepción. Algunas clases pueden permitir cierta recursividad cuando se aplica esta configuración. </summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Un subproceso puede entrar en un bloqueo de forma recursiva. Algunas clases pueden limitar esta posibilidad. </summary>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Representa un bloqueo que se utiliza para administrar el acceso a un recurso y que permite varios subprocesos para la lectura o acceso exclusivo para la escritura.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> con los valores de propiedad predeterminados.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" /> especificando la directiva de recursividad de bloqueo.</summary>
      <param name="recursionPolicy">Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo. </param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Obtiene el número total de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</summary>
      <returns>Número de subprocesos únicos que han entrado en el bloqueo en modo de lectura.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Intenta entrar en el bloqueo en modo de lectura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en modo de lectura. -O bien-El número de recursividad superaría la capacidad del contador. Este límite es tan amplio que las aplicaciones nunca deberían alcanzarlo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Intenta entrar en el bloqueo en modo de actualización.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo. -O bien-El subproceso actual ha entrado en modo de lectura, por lo que, al intentar entrar en modo de actualización, existiría la posibilidad de interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Intenta entrar en el bloqueo en modo de escritura.</summary>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo en cualquier modo. -O bien-El subproceso actual ha entrado en modo de lectura, por lo que, si se intenta entrar en el bloqueo en modo de escritura, existiría la posibilidad de un interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Reduce el recuento de recursividad para el modo de lectura y sale del modo de lectura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de lectura.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Reduce el recuento de recursividad para el modo de actualización y sale del modo de actualización si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de actualización.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Reduce el recuento de recursividad para el modo de escritura y sale del modo de escritura si el recuento resultante es 0 (cero).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">El subproceso actual no ha entrado en el bloqueo en modo de escritura.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de lectura.</summary>
      <returns>true si el subproceso actual entró en modo de lectura, de lo contrario, false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de actualización. </summary>
      <returns>Es true si el subproceso actual entró en modo de actualización, de lo contrario, false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Obtiene un valor que indica si el subproceso actual ha entrado en el bloqueo en modo de escritura.</summary>
      <returns>true si el subproceso actual entró en modo de escritura, de lo contrario, false.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Obtiene un valor que indica la directiva de recursividad del objeto <see cref="T:System.Threading.ReaderWriterLockSlim" /> actual.</summary>
      <returns>Uno de los valores de enumeración que especifica la directiva de recursividad de bloqueo.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de lectura, como una indicación de recursividad.</summary>
      <returns>0 (cero) si el subproceso actual no ha entrado en modo de lectura, 1 si el subproceso ha entrado en modo de lectura pero no lo ha hecho de forma recursiva o n si el subproceso ha entrado de forma recursiva en el bloqueo n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de actualización, como una indicación de recursividad.</summary>
      <returns>0 (cero) si el subproceso actual no ha entrado en modo de actualización, 1 si el subproceso ha entrado en modo de actualización pero no lo ha hecho de forma recursiva o n si el subproceso ha entrado de forma recursiva en el modo de actualización n - 1 veces.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Obtiene el número de veces que el subproceso actual ha entrado en el bloqueo en modo de escritura, como una indicación de recursividad.</summary>
      <returns>0 si el subproceso actual no ha entrado en modo de escritura, 1 si el subproceso ha entrado en modo de escritura pero no lo ha hecho de forma recursiva o n si el subproceso ha entrado de forma recursiva en modo de escritura n - 1 veces.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de lectura, con un tiempo de espera entero opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, false.</returns>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de lectura, con tiempo de espera opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de lectura, de lo contrario, false.</returns>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente. </param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.-O bien-El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, false.</returns>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de actualización, con tiempo de espera opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de actualización, de lo contrario, false.</returns>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de actualización, existiría la posibilidad de un interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.-O bien-El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, false.</returns>
      <param name="millisecondsTimeout">Número de milisegundos de espera, o -1 (<see cref="F:System.Threading.Timeout.Infinite" />) para esperar indefinidamente.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="millisecondsTimeout" /> es negativo, pero no es igual que <see cref="F:System.Threading.Timeout.Infinite" /> (-1), que es el único valor negativo permitido. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Intenta entrar en el bloqueo en modo de escritura, con tiempo de espera opcional.</summary>
      <returns>true si el subproceso que realiza la llamada entró en modo de escritura, de lo contrario, false.</returns>
      <param name="timeout">Intervalo de espera, o -1 milisegundo para esperar indefinidamente.</param>
      <exception cref="T:System.Threading.LockRecursionException">La propiedad <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> es <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> y el subproceso actual ya ha entrado en el bloqueo. -O bien-El subproceso actual entró inicialmente en el bloqueo en modo de lectura y, por lo tanto, al intentar entrar en modo de escritura, existiría la posibilidad de un interbloqueo. -O bien-El número de recursividad superaría la capacidad del contador. El límite es tan amplio que las aplicaciones nunca deben alcanzarlo.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="timeout" /> es negativo, pero no es igual a -1 milisegundo, que es el único valor negativo permitido.-O bien-El valor de <paramref name="timeout" /> es mayor que <see cref="F:System.Int32.MaxValue" /> milisegundos. </exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de lectura.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de lectura.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de actualización.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de actualización.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Obtiene el número total de subprocesos que están a la espera de entrar en el bloqueo en modo de escritura.</summary>
      <returns>Número total de subprocesos que están a la espera de entrar en modo de escritura.</returns>
    </member>
    <member name="T:System.Threading.Tasks.TaskExtensions">
      <summary>Proporciona un conjunto de métodos estáticos (Shared en Visual Basic) para que funcionen con determinados tipos de instancias de <see cref="T:System.Threading.Tasks.Task" />.</summary>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
      <summary>Crea un proxy <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica de una Task&lt;Task&lt;T&gt;&gt; (C#) o Task (Of Task(Of T)) (Visual Basic).</summary>
      <returns>
        <see cref="System.Threading.Tasks.Task`1" /> que representa la operación asincrónica de la Task&lt;Task&lt;T&gt;&gt; (C#) o Task (Of Task(Of T)) (Visual Basic) proporcionada.</returns>
      <param name="task">Task&lt;Task&lt;T&gt;&gt; (C#) o Task (Of Task(Of T)) (Visual Basic) que se va a desencapsular.</param>
      <typeparam name="TResult">Tipo del resultado de la tarea.</typeparam>
      <exception cref="T:System.ArgumentNullException">La excepción que se produce si el argumento <paramref name="task" /> es NULL.</exception>
    </member>
    <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
      <summary>Crea un proxy <see cref="T:System.Threading.Tasks.Task" /> que representa el funcionamiento asincrónico de <see cref="T:System.Threading.Tasks.Task{System.Threading.Tasks.Task}" />.</summary>
      <returns>Una tarea que representa la operación asincrónica de las System.Threading.Tasks.Task(Of Task) proporcionadas.</returns>
      <param name="task">Task&lt;Task&gt; (C#) o Task (Of Task) (Visual Basic) que se va a desencapsular.</param>
      <exception cref="T:System.ArgumentNullException">La excepción que se produce si el argumento <paramref name="task" /> es NULL.</exception>
    </member>
  </members>
</doc>