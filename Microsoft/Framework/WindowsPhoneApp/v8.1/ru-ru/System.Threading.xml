<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>Исключение вызывается, когда некоторый поток получает объект <see cref="T:System.Threading.Mutex" />, брошенный другим потоком путем выхода без высвобождения.</summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" />, используя конкретиый индекс брошенного мьютекса, (если применимо), а также объект <see cref="T:System.Threading.Mutex" />, представляющий мьютекс.</summary>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.AbandonedMutexException" /> с указанным сообщением об ошибке и внутренним исключением.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="inner">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="inner" /> не равно null, текущее исключение вызывается в блоке catch, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" />, используя указанное сообщения об ошибке, внутреннее исключение, индекс брошенного мьютекса (если применимо), а также объект <see cref="T:System.Threading.Mutex" />, представляющего мьютекс.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="inner">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="inner" /> не равно null, текущее исключение вызывается в блоке catch, обрабатывающем внутреннее исключение.</param>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.AbandonedMutexException" /> указанным сообщением об ошибке, индексом брошенного мьютекса (если применимо), а также брошенным мьютексом.</summary>
      <param name="message">Сообщение об ошибке с объяснением причины исключения.</param>
      <param name="location">Индекс брошенного мьютекса в массиве дескрипторов ожидания, если выдается исключение для метода <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, или –1, если исключение выдается для методов <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> или <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Получает брошенный мьютекс, вызвавший исключение (если он известен).</summary>
      <returns>Объект <see cref="T:System.Threading.Mutex" />, представляющий брошенный мьютекс, или null, если брошенный мьютекс не может быть идентифицирован.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Получает индекс брошенного мьютекса, вызвавшего исключение (если он известен).</summary>
      <returns>Индекс в массиве дескрипторов ожидания, передаваемый в метод <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, объекта <see cref="T:System.Threading.Mutex" />, представляющего брошенный мьютекс, или же -1, если индекс брошенного мьютекса невозможно определить.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Уведомляет ожидающий поток о том, что произошло событие. Этот класс не наследуется.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.AutoResetEvent" /> логическим значением, показывающим наличие сигнального состояния.</summary>
      <param name="initialState">Значение true для задания начального состояния сигнальным; false для задания несигнального начального состояния.</param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Позволяет нескольким задачам параллельно работать с алгоритмом, используя несколько фаз.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Количество участвующих потоков.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> меньше 0 или больше 32,767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Количество участвующих потоков.</param>
      <param name="postPhaseAction">
        <see cref="T:System.Action`1" /> для исполнения после каждой фазы. Значение null (Nothing in Visual Basic) может быть передано, чтобы указать, что действия не предпринимаются.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> меньше 0 или больше 32,767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Уведомляет <see cref="T:System.Threading.Barrier" /> о добавлении дополнительного участника.</summary>
      <returns>Номер фазы барьера, в которой сначала участвуют новые участники.</returns>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Добавление участника приведет к превышению 32 767 счетчиком участников барьера. -или- Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Уведомляет барьер <see cref="T:System.Threading.Barrier" /> о добавлении дополнительных участников.</summary>
      <returns>Номер фазы барьера, в которой сначала участвуют новые участники.</returns>
      <param name="participantCount">Число дополнительных участников, которых необходимо добавить в барьер.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="participantCount" /> меньше 0. -или- Добавление участников <paramref name="participantCount" /> приведет к превышению 32 767 счетчиком участников барьера.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Получает номер текущей фазы барьера.</summary>
      <returns>Возвращает номер текущего этапа барьера.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые (а при необходимости и управляемые) ресурсы, используемые объектом <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="disposing">Значение true, чтобы освободить управляемые и неуправляемые ресурсы; значение false, чтобы освободить только неуправляемые ресурсы.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Получает общее количество участников в барьере.</summary>
      <returns>Возвращает общее количество участников в барьере.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Получает количество участников в барьере, которые еще не создали сигнал в текущей фазе.</summary>
      <returns>Возвращает количество участников в барьере, которые еще не создали сигнал на текущем этапе.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Уведомляет <see cref="T:System.Threading.Barrier" /> о удалении одного участника.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Барьер уже содержит 0 участников. -или- Метод был вызван из действия после этапа.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Уведомляет барьер <see cref="T:System.Threading.Barrier" /> об удалении нескольких участников.</summary>
      <param name="participantCount">Число дополнительных участников, которых необходимо удалить из барьера.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="participantCount" /> меньше 0.</exception>
      <exception cref="T:System.InvalidOperationException">Барьер уже содержит 0 участников. -или- Метод был вызван из действия после этапа.  -или- текущее количество участников меньше указанного participantCount</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Общее число участников меньше указанного<paramref name=" participantCount" /></exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера другими участниками.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Если создается исключение из действия следующего этапа барьера после того, как все участвующие потоки вызвали SignalAndWait, исключение будет вставлено в BarrierPostPhaseException и создано для всех участвующих потоков.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера всеми другими участниками, используя 32-разрядное знаковое целое число для измерения времени ожидания.</summary>
      <returns>Значение true, если все участники достигли барьера за указанное время; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Если создается исключение из действия следующего этапа барьера после того, как все участвующие потоки вызвали SignalAndWait, исключение будет вставлено в BarrierPostPhaseException и создано для всех участвующих потоков.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя 32-разрядное знаковое целое число для измерения времени ожидания. Кроме того, метод контролирует токен отмены.</summary>
      <returns>Значение true, если все участники достигли барьера за указанное время; в противном случае — значение false</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера  и ожидает достижения барьера всеми другими участниками. Кроме того, метод контролирует токен отмены.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <returns>Значение true, если все остальные участники достигли барьера; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунды, которое представляет неограниченное время ожидания, или превышает 32767.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Сообщает, что участник достиг барьера и ожидает достижения барьера всеми другими участниками, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени. Кроме того, метод контролирует токен отмены.</summary>
      <returns>Значение true, если все остальные участники достигли барьера; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Метод был вызван из действия после этапа, барьер в настоящий момент имеет 0 участников или барьер получает сигналы от большего числа потоков, чем зарегистрировано участников.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>Исключение, которое возникает при сбое действия барьера <see cref="T:System.Threading.Barrier" />, выполняемого в конце фазы</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> системным сообщением, содержащим описание ошибки.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с указанным внутренним исключением.</summary>
      <param name="innerException">Исключение, которое вызвало текущее исключение.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с использованием заданного сообщения, содержащего описание ошибки.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающий оператор этого конструктора необходим, чтобы убедиться, локализована ли данная строка для текущего языка и региональных параметров системы.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.BarrierPostPhaseException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающий оператор этого конструктора необходим, чтобы убедиться, локализована ли данная строка для текущего языка и региональных параметров системы.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно null, текущее исключение сгенерировано в блоке catch, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Представляет примитив синхронизации, на который отправляется сигнал при достижении его подсчетом нуля.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.CountdownEvent" /> указанным количеством.</summary>
      <param name="initialCount">Количество сигналов, первоначально необходимое для задания объекта <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Увеличивает текущий подсчет <see cref="T:System.Threading.CountdownEvent" /> на один.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан. -или- Значение параметра <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> больше или равно значению свойства <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Увеличивает текущее количество в объекте <see cref="T:System.Threading.CountdownEvent" /> на указанное значение.</summary>
      <param name="signalCount">Значение, на которое нужно увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="signalCount" /> меньше или равно 0.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан. -или- <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> равно или больше <see cref="F:System.Int32.MaxValue" /> после увеличения счета параметром <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Получает количество сигналов, оставшееся до установки события.</summary>
      <returns>Количество сигналов, оставшееся до установки события.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые (а при необходимости и управляемые) ресурсы, используемые объектом <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="disposing">Значение true, чтобы освободить управляемые и неуправляемые ресурсы; значение false, чтобы освободить только неуправляемые ресурсы.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Получает количество сигналов, изначально нужное для установки события.</summary>
      <returns>Количество сигналов, изначально нужное для установки события.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Определяет, установлено ли событие.</summary>
      <returns>Значение true, если событие установлено; в противном случае — значение false.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Сбрасывает свойство <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на значение свойства <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Присваивает свойству <see cref="P:System.Threading.CountdownEvent.InitialCount" /> заданное значение.</summary>
      <param name="count">Количество сигналов, необходимое для установки объекта <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="count" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Регистрирует сигнал с событием <see cref="T:System.Threading.CountdownEvent" />, уменьшая значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns>Значение true, если после сигнала подсчет стал равен нулю и было создано событие; в противном случае — значение false.</returns>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Регистрирует несколько сигналов с объектом <see cref="T:System.Threading.CountdownEvent" />, уменьшая значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на указанное число.</summary>
      <returns>Значение true, если после сигналов подсчет стал равен нулю и было создано событие; в противном случае — значение false.</returns>
      <param name="signalCount">Количество сигналов, которое необходимо зарегистрировать.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="signalCount" /> меньше 1.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан. - или- Или значение <paramref name="signalCount" /> больше <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Попытка увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на единицу.</summary>
      <returns>Значение true, если увеличение выполнено успешно; в противном случае — значение false. Если значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> уже равно нулю, метод возвращает значение false.</returns>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> равно <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Пытается увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> на указанное значение.</summary>
      <returns>Значение true, если увеличение выполнено успешно; в противном случае — значение false. Если значение свойства <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> уже равно нулю, возвращается значение false.</returns>
      <param name="signalCount">Значение, на которое нужно увеличить <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="signalCount" /> меньше или равно 0.</exception>
      <exception cref="T:System.InvalidOperationException">Текущий экземпляр уже задан. -или- Значение свойства<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> больше или равно значению свойства <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Блокирует текущий поток до установки <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока не установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя 32-разрядное знаковое целое число для измерения времени ожидания.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.CountdownEvent" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя 32-разрядное знаковое целое число для измерения времени ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.CountdownEvent" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток, пока не будет установлено <see cref="T:System.Threading.CountdownEvent" />, в то же время контролируя <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя значение <see cref="T:System.TimeSpan" /> для измерения времени ожидания.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.CountdownEvent" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток, пока не будет установлен объект <see cref="T:System.Threading.CountdownEvent" />, используя значение <see cref="T:System.TimeSpan" /> для измерения времени ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.CountdownEvent" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален. — или — <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Получает дескриптор <see cref="T:System.Threading.WaitHandle" />, используемый для ожидания установки события.</summary>
      <returns>Дескриптор <see cref="T:System.Threading.WaitHandle" />, используемый для ожидания установки события.</returns>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Указывает, сбрасывается ли <see cref="T:System.Threading.EventWaitHandle" /> автоматически или вручную после получения сигнала.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>При получении сигнала <see cref="T:System.Threading.EventWaitHandle" /> сбрасывается автоматически после освобождения одиночного потока. При отсутствии ожидающих потоков <see cref="T:System.Threading.EventWaitHandle" /> остается сигнальным до тех пор, пока поток не блокируется и не сбрасывается после освобождения потока.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>При получении сигнала, <see cref="T:System.Threading.EventWaitHandle" /> высвобождает все ожидающие потоки и остается сигнальным до тех пор, пока не сбрасывается вручную.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Представляет синхронизированное событие потока.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяя, получает ли сигнал, ожидающий дескриптор, и производится ли сброс автоматически или вручную.</summary>
      <param name="initialState">Значение true для задания начального состояния сигнальным; false для задания несигнального начального состояния.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" /> определяет, сбрасывается ли событие автоматически или вручную.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяющего получает ли сигнал дескриптор ожидания, если он был создан в результате данного вызова, сбрасывается ли он автоматически или вручную, а также имя системного события синхронизации.</summary>
      <param name="initialState">true, чтобы задать сигнальное начальное состояние, если создано названное событие в результате этого вызова; false, чтобы задать несигнальное начальное состояние.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" /> определяет, сбрасывается ли событие автоматически или вручную.</param>
      <param name="name">Имя общесистемного события синхронизации.</param>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, имеет настройки управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие не может быть создано, видимо потому что дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Threading.EventWaitHandle" />, определяющего, является ли дескриптор ожидания изначально сигнальным, если он был создан в результате данного вызова, происходит ли сброс автоматически или вручную, имя системного события синхронизации и логическую переменную, значение которой показывает, было ли создано системное именованное событие.</summary>
      <param name="initialState">true, чтобы задать сигнальное начальное состояние, если создано названное событие в результате этого вызова; false, чтобы задать несигнальное начальное состояние.</param>
      <param name="mode">Одно из значений <see cref="T:System.Threading.EventResetMode" /> определяет, сбрасывается ли событие автоматически или вручную.</param>
      <param name="name">Имя общесистемного события синхронизации.</param>
      <param name="createdNew">Когда данный метод возвращает значение, он содержит true, если было создано локальное событие (то есть, если <paramref name="name" /> имеет значение null или пустую строку) или было создано системное событие с заданным именем; либо значение false, если указанное именованное событие уже существовало. Этот параметр передается без инициализации.</param>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, имеет настройки управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное событие не может быть создано, видимо потому что дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Открывает указанное именованное событие синхронизации, если оно уже существует.</summary>
      <returns>Объект, представляющий именованное системное событие.</returns>
      <param name="name">Имя системного события синхронизации для открытия.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку.  -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованное системное событие не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, но у пользователя нет необходимых для его использования прав доступа.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
      </PermissionSet>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Задает несигнальное состояние события, вызывая блокирование потоков.</summary>
      <returns>true, если операция прошла успешно; в противном случае — false.</returns>
      <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="T:System.Threading.EventWaitHandle" /> ранее вызывался метод <see cref="M:System.Threading.EventWaitHandle.Close" />.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Задает сигнальное состояние события, позволяя одному или нескольким ожидающим потокам продолжить.</summary>
      <returns>true, если операция прошла успешно; в противном случае — false.</returns>
      <exception cref="T:System.ObjectDisposedException">Для данного объекта <see cref="T:System.Threading.EventWaitHandle" /> ранее вызывался метод <see cref="M:System.Threading.EventWaitHandle.Close" />.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Открывает указанное именованное событие синхронизации, если оно уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <returns>Значение true, если именованное событие синхронизации было успешно открыто; в противном случае — значение false.</returns>
      <param name="name">Имя системного события синхронизации для открытия.</param>
      <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.EventWaitHandle" />, представляющий именованное событие синхронизации, если вызов завершился успешно, или значение null, если вызов завершился ошибкой. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованное событие существует, но у пользователя нет требуемых прав доступа.</exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Предоставляет атомарные операции для переменных, общедоступных нескольким потокам.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Добавляет два 32-разрядных целых числа и заменяет первое число на сумму в одной атомарной операции.</summary>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Добавляет два 64-битовых целых числа и заменяет первое число на сумму в одной атомарной операции.</summary>
      <returns>Новое значение сохраняется в <paramref name="location1" />.</returns>
      <param name="location1">Переменная, содержащая первое добавляемое значение. Сумма двух значений сохраняется в <paramref name="location1" />.</param>
      <param name="value">Значение, добавляемое к целому в <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Сравнивает два числа с плавающей запятой с двойной точностью на равенство и, если они равны, заменяет одно из значений.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено.</param>
      <param name="value">Значение, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Сравнивает два 32-разрядных целых числа со знаком на равенство и, если они равны, заменяет одно из значений.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено.</param>
      <param name="value">Значение, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Сравнивает два 64-битовых целых числа со знаком на равенство и, если они равны, заменяет одно из значений.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено.</param>
      <param name="value">Значение, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Сравнивает два зависящих от платформы обработчика или указателя на равенство и, если они равны, заменяет одно из значений.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение <see cref="T:System.IntPtr" />, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено <paramref name="value" />.</param>
      <param name="value">Значение <see cref="T:System.IntPtr" />, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение <see cref="T:System.IntPtr" />, которое сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Сравнивает два объекта на равноправие и, если они равны, заменяет один из них.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевой объект, который будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменен.</param>
      <param name="value">Объект, который заменит целевой объект, если результатом сравнения будет равенство.</param>
      <param name="comparand">Объект, который сравнивается с объектом в <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Сравнивает два числа с плавающей запятой с обычной точностью на равенство и, если они равны, заменяет одно из значений.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено.</param>
      <param name="value">Значение, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение сравнивается со значением <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Сравнивает два экземпляра указанного ссылочного типа <paramref name="T" /> на равенство и, если это так, заменяет один из них.</summary>
      <returns>Исходное значение в <paramref name="location1" />.</returns>
      <param name="location1">Целевое значение, которое будет сравниваться со значением параметра <paramref name="comparand" /> и, возможно, будет заменено. Это ссылочный параметр (ref в C#, ByRef в Visual Basic).</param>
      <param name="value">Значение, которое заменит целевое значение, если результатом сравнения будет равенство.</param>
      <param name="comparand">Значение сравнивается со значением <paramref name="location1" />.</param>
      <typeparam name="T">Тип, используемый для <paramref name="location1" />, <paramref name="value" />, и <paramref name="comparand" />. Этот тип должен быть ссылочным типом.</typeparam>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <returns>Уменьшаемое значение.</returns>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.ArgumentNullException">Адрес, заданный в параметре <paramref name="location" />, является указателем NULL.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Уменьшает значение заданной переменной и сохраняет результат — как атомарная операция.</summary>
      <returns>Уменьшаемое значение.</returns>
      <param name="location">Переменная, у которой уменьшается значение.</param>
      <exception cref="T:System.ArgumentNullException">Адрес, заданный в параметре <paramref name="location" />, является указателем NULL.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Задает число с плавающей запятой с двойной точностью указанным значением — как атомарная операция, и возвращает исходное значение.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Присваивает 32-битовому целому числу со знаком заданное значение и возвращает исходное значение в одной атомарной операции.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Присваивает 64-битовому целому числу со знаком заданное значение и возвращает исходное значение в одной атомарной операции.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Задает указатель или обработчик, зависящий от платформы — как атомарная операция, и возвращает ссылку на исходное значение.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Задает объект указанным значением — как атомарная операция, и возвращает ссылку на исходный объект.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.ArgumentNullException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Задает число с плавающей запятой с обычной точностью указанным значением — как атомарная операция, и возвращает исходное значение.</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением.</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>Задает определенное значение для переменной указанного типа <paramref name="T" /> и возвращает исходное значение (атомарная операция).</summary>
      <returns>Исходное значение параметра <paramref name="location1" />.</returns>
      <param name="location1">Переменная, которая задается указанным значением. Это ссылочный параметр (ref в C#, ByRef в Visual Basic).</param>
      <param name="value">Значение, в которое задан параметр <paramref name="location1" />.</param>
      <typeparam name="T">Тип, используемый для <paramref name="location1" /> и <paramref name="value" />. Этот тип должен быть ссылочным типом.</typeparam>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location1" />, является указателем null.</exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <returns>Увеличиваемое значение.</returns>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location" />, является указателем NULL.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>Увеличивает значение заданной переменной и сохраняет результат в виде атомарной операции.</summary>
      <returns>Увеличиваемое значение.</returns>
      <param name="location">Переменная, у которой увеличивается значение.</param>
      <exception cref="T:System.NullReferenceException">Адрес, заданный в параметре <paramref name="location" />, является указателем NULL.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>Синхронизирует доступ к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</summary>
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>Возвращает 64-битное значение, загруженное в виде атомарной операции.</summary>
      <returns>Загруженное значение.</returns>
      <param name="location">Загружаемое 64-битное значение.</param>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>Обеспечивает процедуры неактивной инициализации.</summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>Инициализирует целевой ссылочный тип его конструктором типа по умолчанию, если он еще не инициализирован.</summary>
      <returns>Инициализируемая ссылка типа <paramref name="T" />.</returns>
      <param name="target">Ссылка типа <paramref name="T" />, которую необходимо инициализировать, если она еще не инициализирована.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">Тип <paramref name="T" /> не имеет конструктора по умолчанию.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>Инициализирует целевой ссылочный тип или тип значения его конструктором по умолчанию, если он еще не инициализирован.</summary>
      <returns>Инициализированное значение типа <paramref name="T" />.</returns>
      <param name="target">Ссылка или значение типа <paramref name="T" />, которое необходимо инициализировать, если оно еще не инициализировано.</param>
      <param name="initialized">Ссылка на логическое значение, определяющее, инициализирована ли цель.</param>
      <param name="syncLock">Ссылка на объект, используемый как взаимоисключающая блокировка для инициализации параметра <paramref name="target" />. Если <paramref name="syncLock" /> равно null, то нового объект будет создан экземпляр.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">Тип <paramref name="T" /> не имеет конструктора по умолчанию.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>Инициализирует целевой ссылочный тип или тип значения с использованием указанной функцией, если он еще не инициализирован.</summary>
      <returns>Инициализированное значение типа <paramref name="T" />.</returns>
      <param name="target">Ссылка или значение типа <paramref name="T" />, которое необходимо инициализировать, если оно еще не инициализировано.</param>
      <param name="initialized">Ссылка на логическое значение, определяющее, инициализирована ли цель.</param>
      <param name="syncLock">Ссылка на объект, используемый как взаимоисключающая блокировка для инициализации параметра <paramref name="target" />. Если <paramref name="syncLock" /> равно null, то нового объект будет создан экземпляр.</param>
      <param name="valueFactory">Функция, которая вызывается для инициализации ссылки или значения.</param>
      <typeparam name="T">Тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MemberAccessException">Разрешения на доступ к конструктору типа <paramref name="T" /> отсутствовали.</exception>
      <exception cref="T:System.MissingMemberException">Тип <paramref name="T" /> не имеет конструктора по умолчанию.</exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>Инициализирует целевой ссылочный тип с использованием указанной функцией, если он еще не инициализирован.</summary>
      <returns>Инициализированное значение типа <paramref name="T" />.</returns>
      <param name="target">Ссылка типа <paramref name="T" />, которую необходимо инициализировать, если она еще не инициализирована.</param>
      <param name="valueFactory">Функция, которая вызывается для инициализации ссылки.</param>
      <typeparam name="T">Ссылочный тип инициализируемой ссылки.</typeparam>
      <exception cref="T:System.MissingMemberException">Тип <paramref name="T" /> не имеет конструктора по умолчанию.</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> вернул значение NULL (Nothing в Visual Basic).</exception>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>Исключение генерируется, когда рекурсивная запись блокировки не совпадает с рекурсивной политикой блокировки.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> системным сообщением, содержащим описание ошибки.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> с использованием заданного сообщения, содержащего описание ошибки.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающему объекту этого конструктора необходимо убедиться, что эта строка локализована для текущего языка и региональных параметров системы.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.LockRecursionException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
      <param name="message">Сообщение с описанием исключения. Вызывающему объекту этого конструктора необходимо убедиться, что эта строка локализована для текущего языка и региональных параметров системы.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно null, текущее исключение сгенерировано в блоке catch, обрабатывающем внутреннее исключение.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>Указывает, можно ли несколько раз войти в блокировку из одного и того же потока.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>Если поток пытается войти в блокировку рекурсивно, выдается ошибка. Некоторые классы могут допускать определенные виды рекурсий при активированном параметре.</summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>Допускается рекурсивный вход потока в блокировку. Некоторые классы могут игнорировать эту возможность.</summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>Уведомляет один или более ожидающих потоков о том, что произошло событие. Этот класс не наследуется.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEvent" /> логическим значением, показывающим наличие сигнального состояния.</summary>
      <param name="initialState">Значение true для задания начального состояния сигнальным; false для задания несигнального начального состояния.</param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>Предоставляет уменьшенную версию <see cref="T:System.Threading.ManualResetEvent" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> начальным состоянием nonsignaled.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> с логическим значением, указывающим, нужно ли для начального состояния задать сигнальное значение.</summary>
      <param name="initialState">Значение true для задания начального состояния signaled; значение false для задания начального состояния nonsignaled.</param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ManualResetEventSlim" /> с логическим значением, указывающим, нужно ли для начального состояния задать сигнальное значение, а также указанным числом прокруток.</summary>
      <param name="initialState">Значение true для задания начального состояния signaled; значение false для задания начального состояния nonsignaled.</param>
      <param name="spinCount">Число ожиданий прокруток до возврата к операции ожидания на основе ядра.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> меньше 0 или больше максимального разрешенного значения.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые (а при необходимости и управляемые) ресурсы, используемые объектом <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <param name="disposing">Значение true, чтобы освободить управляемые и неуправляемые ресурсы; значение false, чтобы освободить только неуправляемые ресурсы.</param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>Получает значение, указывающее, установлено ли событие.</summary>
      <returns>Значение true, если событие установлено; в противном случае — значение false.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>Задает несигнальное состояние события, вызывая блокирование потоков.</summary>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>Устанавливает состояние события на signaled, позволяя продолжить выполнение одному или нескольким потокам, ожидающим событие.</summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>Получает число ожиданий прокруток, которые произойдут до возврата к операции ожидания на основе ядра.</summary>
      <returns>Возвращает число ожиданий прокруток, которые произойдут до возврата к операции ожидания на основе ядра.</returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>Блокирует текущий поток до установки текущего объекта <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока не установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя 32-разрядное знаковое целое число для измерения интервала времени.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя 32-разрядное знаковое целое число для измерения интервала времени. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.ManualResetEventSlim" />. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток, пока не будет установлено текущее событие <see cref="T:System.Threading.ManualResetEventSlim" />, используя объект <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект уже удален.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока не будет установлен текущий объект <see cref="T:System.Threading.ManualResetEventSlim" />, используя значение <see cref="T:System.TimeSpan" /> для измерения интервала времени. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если установлено событие <see cref="T:System.Threading.ManualResetEventSlim" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.InvalidOperationException">Превышено максимально допустимое количество ожидающих.</exception>
      <exception cref="T:System.ObjectDisposedException">Объект был удален или <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name="cancellationToken" />, был удален.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Получает базовый объект <see cref="T:System.Threading.WaitHandle" /> для данного объекта <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>Базовый объект события <see cref="T:System.Threading.WaitHandle" /> для данного объекта <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Предоставляет механизм для синхронизации доступа к объектам.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Получает эксклюзивную блокировку указанного объекта.</summary>
      <param name="obj">Объект, для которого получается блокировка монитора.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Получает монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Ожидаемый объект.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться false. Выходное значение true, если блокировка получена; в противном случае — выходное значение false. Выходное значение задается, даже если при попытке получить блокировку возникает исключение. Примечание.   Если исключение не возникает, выходное значение этого метода всегда true.</param>
      <exception cref="T:System.ArgumentException">Входное значение параметра <paramref name="lockTaken" /> — true.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Освобождает эксклюзивную блокировку указанного объекта.</summary>
      <param name="obj">Объект, блокировка которого освобождается.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Данный поток не владеет блокировкой для указанного объекта.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Определяет, является ли содержит ли текущий поток блокировку на заданном объекте.</summary>
      <returns>Значение true, если текущий поток владеет блокировкой в <paramref name="obj" />; в противном случае — значение false.</returns>
      <param name="obj">Объект для тестирования.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение null.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Уведомляет поток в очереди готовности об изменении состояния объекта с блокировкой.</summary>
      <param name="obj">Объект, которого ожидает поток.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Уведомляет все ожидающие потоки об изменении состояния объекта.</summary>
      <param name="obj">Объект, посылающий импульс.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта.</summary>
      <returns>Значение true, если текущий поток получает блокировку; в противном случае — значение false.</returns>
      <param name="obj">Объект, блокировка которого получается.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться false. Выходное значение true, если блокировка получена; в противном случае — выходное значение false. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входное значение параметра <paramref name="lockTaken" /> — true.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта на заданное количество миллисекунд.</summary>
      <returns>Значение true, если текущий поток получает блокировку; в противном случае — значение false.</returns>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>В течение заданного количества миллисекунд пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться false. Выходное значение true, если блокировка получена; в противном случае — выходное значение false. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входное значение параметра <paramref name="lockTaken" /> — true.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Пытается получить эксклюзивную блокировку указанного объекта в течение заданного количества времени.</summary>
      <returns>Значение true, если текущий поток получает блокировку; в противном случае — значение false.</returns>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда), или больше чем <see cref="F:System.Int32.MaxValue" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>В течение заданного периода времени пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
      <param name="obj">Объект, блокировка которого получается.</param>
      <param name="timeout">Период времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
      <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться false. Выходное значение true, если блокировка получена; в противном случае — выходное значение false. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
      <exception cref="T:System.ArgumentException">Входное значение параметра <paramref name="lockTaken" /> — true.</exception>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда), или больше чем <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова.</summary>
      <returns>Значение true, если вызов осуществил возврат из-за того, что вызывающий поток заново получил блокировку заданного объекта. Этот метод не осуществляет возврат, если блокировка вновь не получена.</returns>
      <param name="obj">Ожидаемый объект.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает Wait, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> данного потока.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
      <returns>true если блокировка не была получена до истечения заданного времени; false если блокировка была получена по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
      <param name="obj">Ожидаемый объект.</param>
      <param name="millisecondsTimeout">Количество миллисекунд для ожидания постановки в очередь готовности.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает Wait, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> данного потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
      <returns>true если блокировка не была получена до истечения заданного времени; false если блокировка была получена по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
      <param name="obj">Ожидаемый объект.</param>
      <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, до истечения которого поток поступает в очередь ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="obj" /> — null.</exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает Wait, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> данного потока.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда), или больше чем <see cref="F:System.Int32.MaxValue" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Примитив синхронизации, который также может использоваться в межпроцессорной синхронизации.</summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> со стандартными свойствами.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, является ли вызывающий поток изначальным владельцем мьютекса.</summary>
      <param name="initiallyOwned">Значение true для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — false.</param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> с логическим значением, показывающим необходимость наличия начального владения семафором у вызывающего потока, и строкой, являющейся именем семафора.</summary>
      <param name="initiallyOwned">Значение true для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае – значение false.</param>
      <param name="name">Имя объекта <see cref="T:System.Threading.Mutex" />. Если значение равно null, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не может быть создан; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, строкой, являющейся именем мьютекса, и логическим значением, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</summary>
      <param name="initiallyOwned">Значение true для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае – значение false.</param>
      <param name="name">Имя объекта <see cref="T:System.Threading.Mutex" />. Если значение равно null, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
      <param name="createdNew">При возврате из метода содержит логическое значение true, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение null или содержит пустую строку) или был создан именованный системный мьютекс; значение false, если указанный именованный системный мьютекс уже существует. Этот параметр передается без инициализации.</param>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не может быть создан; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
      <exception cref="T:System.ArgumentException">Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
      <returns>Объект, представляющий именованный системный мьютекс.</returns>
      <param name="name">Имя системного мьютекса для открытия.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет необходимой для его использования безопасности доступа.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
      </PermissionSet>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</summary>
      <exception cref="T:System.ApplicationException">Вызывающий поток не является владельцем мьютекса.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <returns>Значение true, если именованный мьютекс был успешно открыт; в противном случае — значение false.</returns>
      <param name="name">Имя системного мьютекса для открытия.</param>
      <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение null, если вызов завершился ошибкой. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет необходимой для его использования безопасности доступа.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> значениями свойств по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> с указанием политики рекурсии блокировки.</summary>
      <param name="recursionPolicy">Одно из значений перечисления, определяющее политику рекурсии блокировки.</param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Возвращает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</summary>
      <returns>Количество уникальных потоков, вошедших в блокировку в режиме чтения.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Пытается выполнить вход в блокировку в режиме чтения.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в режим чтения.  -или- Глубина рекурсии превышает емкость счетчика. Это ограничение настолько велико, что оно не должно достигаться приложениями на практике.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Пытается выполнить вход в блокировку в обновляемом режиме.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  -или- Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Пытается выполнить вход в блокировку в режиме записи.</summary>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.  -или- Текущий поток вошел в режим чтения, поэтому попытка войти в блокировку в обновляемом режиме создаст риск взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Уменьшает счетчик глубины рекурсии для режима чтения, и выходит из режима чтения, если значение счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме чтения.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Уменьшает счетчик глубины рекурсии для обновляемого режима, и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в обновляемом режиме.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Уменьшает счетчик глубины рекурсии для режима записи, и выходит из режима записи, если счетчик принял значение 0 (нуль).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме записи.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</summary>
      <returns>Значение true, если текущий поток вошел в режим чтения, в противном случае – false.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</summary>
      <returns>Значение true, если текущий поток вошел в обновляемый режим, противном случае – false.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</summary>
      <returns>Значение true, если текущий поток вошел в режим записи, в противном случае – false.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>Возвращает значение, указывающее политику рекурсии для текущего объекта <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <returns>Одно из значений перечисления, определяющее политику рекурсии блокировки.</returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>Возвращает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</summary>
      <returns>0 (нуль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не вошел в него рекурсивно, или n, если поток вошел в блокировку рекурсивно n - 1 раз.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>Возвращает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</summary>
      <returns>0 (нуль), если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или n, если поток вошел в обновляемый режим рекурсивно n - 1 раз.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>Возвращает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</summary>
      <returns>0 (нуль), если текущий поток, не вошел в режим записи, 1, если поток вошел в режим записи, но не вошел в него рекурсивно, или n, если поток вошел в режим записи рекурсивно n - 1 раз.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</summary>
      <returns>Значение true, если вызывающий поток вошел в режим чтения, иначе — false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) для неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
      <returns>Значение true, если вызывающий поток вошел в режим чтения, иначе — false.</returns>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания неограниченное время.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением. -или- Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      <returns>Значение true, если вызывающий поток вошел в обновляемый режим, иначе — false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) для неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      <returns>Значение true, если вызывающий поток вошел в обновляемый режим, иначе — false.</returns>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания неограниченное время.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением. -или- Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      <returns>Значение true, если вызывающий поток вошел в режим записи, иначе — false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) для неограниченного времени ожидания.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      <returns>Значение true, если вызывающий поток вошел в режим записи, иначе — false.</returns>
      <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания неограниченное время.</param>
      <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.  -или- Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  -или- Глубина рекурсии превышает емкость счетчика. Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением. -или- Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>Возвращает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</summary>
      <returns>Общее количество потоков, ожидающих вхождения в режим чтения.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>Возвращает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</summary>
      <returns>Общее количество потоков, ожидающих входа в обновляемый режим.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>Возвращает общее количество потоков, ожидающих входа в блокировку в режиме записи.</summary>
      <returns>Общее количество потоков, ожидающих входа в режим записи.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>Ограничивает число потоков, которые могут одновременно получать доступ к ресурсу или пулу ресурсов.</summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" /> с заданием максимального количества одновременных входов и необязательным резервированием нескольких входов.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1. -или- Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" /> с заданием максимального количества одновременных входов, необязательным резервированием нескольких входов для вызывающего потока и необязательным заданием имени объекта системного семафора.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <param name="name">Имя объекта именованного системного семафора.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1. -или- Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, имеет параметры безопасности управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не может быть создан, видимо потому что дескриптор ожидания другого типа имеет то же имя.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" /> с заданием максимального количества одновременных входов, необязательным резервированием нескольких входов для вызывающего потока, необязательным заданием имени объекта системного семафора и заданием переменной, получающей значение, которое указывает на то, был ли создан новый системный семафор.</summary>
      <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
      <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
      <param name="name">Имя объекта именованного системного семафора.</param>
      <param name="createdNew">При возврате из метода содержит логическое значение true, если был создан локальный семафор (то есть, если параметр <paramref name="name" /> имеет значение null или содержит пустую строку) или был создан заданный именованный системный семафор; значение false, если указанный именованный семафор уже существовал. Этот параметр передается без инициализации.</param>
      <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1. -или- Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, имеет параметры безопасности управления доступом, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не может быть создан, видимо потому что дескриптор ожидания другого типа имеет то же имя.</exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
      <returns>Объект, представляющий именованный системный семафор.</returns>
      <param name="name">Имя системного семафора для открытия.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет необходимых для его использования прав доступа.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
      </PermissionSet>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>Выходит из семафора и возвращает последнее значение счетчика.</summary>
      <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />. -или- Текущий семафор представляет именованный системный семафор, но он не был открыт с правами доступа <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>Выходит из семафора указанное число раз и возвращает последнее значение счетчика.</summary>
      <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
      <param name="releaseCount">Количество требуемых выходов из семафора.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />. -или- Текущий семафор представляет именованный системный семафор, но он не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>Открывает указанный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      <returns>Значение true, если именованный семафор был успешно открыт; в противном случае — значение false.</returns>
      <param name="name">Имя системного семафора для открытия.</param>
      <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Semaphore" />, представляющий именованный семафор, если вызов завершился успешно, или значение null, если вызов завершился ошибкой. Этот параметр обрабатывается как неинициализированный.</param>
      <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> содержит пустую строку. -или- Длина параметра <paramref name="name" /> превышает 260 символов.</exception>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="name" /> имеет значение null.</exception>
      <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет необходимых для его использования прав доступа.</exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>Исключение, выдаваемое при вызове метода <see cref="Overload:System.Threading.Semaphore.Release" /> для семафора, значение счетчика которого уже равно максимальному.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreFullException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно null, текущее исключение сгенерировано в блоке catch, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>Упрощенная альтернатива семафору <see cref="T:System.Threading.Semaphore" />, ограничивающая количество потоков, которые могут параллельно обращаться к ресурсу или пулу ресурсов.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreSlim" />, указывая первоначальное число запросов, которые могут выполняться одновременно.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SemaphoreSlim" />, указывая изначальное и максимальное число запросов, которые могут выполняться одновременно.</summary>
      <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
      <param name="maxCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> меньше 0 или <paramref name="initialCount" /> больше, чем <paramref name="maxCount" />, или <paramref name="maxCount" /> меньше или равен 0.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>Возвращает дескриптор <see cref="T:System.Threading.WaitHandle" />, который может использоваться для ожидания семафора.</summary>
      <returns>Дескриптор <see cref="T:System.Threading.WaitHandle" />, который может использоваться для ожидания семафора.</returns>
      <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.SemaphoreSlim" /> ликвидирован.</exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>Получает количество потоков, которым будет разрешено входить в семафор <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Текущее количество в семафоре <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>Освобождает неуправляемые (а при необходимости и управляемые) ресурсы, используемые объектом <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <param name="disposing">Значение true позволяет освободить управляемые и неуправляемые ресурсы; значение false позволяет освободить только неуправляемые ресурсы.</param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>Выполняет однократный выход из <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Предыдущее количество в семафоре <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> уже достиг максимального размера.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>Выходит из <see cref="T:System.Threading.SemaphoreSlim" /> указанное число раз.</summary>
      <returns>Предыдущее количество в семафоре <see cref="T:System.Threading.SemaphoreSlim" />.</returns>
      <param name="releaseCount">Количество требуемых выходов из семафора.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> уже достиг максимального размера.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>Блокирует текущий поток, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное знаковое целое число, которое определяет время ожидания.</summary>
      <returns>Значение true, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32-разрядное знаковое целое число, которое определяет время ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение false.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или значение <see cref="F:System.Threading.Timeout.Infinite" /> (-1) для неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр <see cref="T:System.Threading.SemaphoreSlim" /> был удален, или объект <see cref="T:System.Threading.CancellationTokenSource" />,<paramref name="" />создавший<paramref name=" cancellationToken" />, был удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален. -или- Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name=" cancellationToken" />, уже удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя значение <see cref="T:System.TimeSpan" /> для определения времени ожидания.</summary>
      <returns>Значение true, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр semaphoreSlim был уничтожен<paramref name="." /></exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Блокирует текущий поток до тех пор, пока он не сможет войти в <see cref="T:System.Threading.SemaphoreSlim" />, используя значение <see cref="T:System.TimeSpan" />, которое определяет время ожидания. Кроме того, метод контролирует токен <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Значение true, если текущий поток успешно передан в объект <see cref="T:System.Threading.SemaphoreSlim" />; в противном случае — значение false.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> был отменен.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Экземпляр semaphoreSlim был уничтожен<paramref name="." /><paramref name="-or-" />Класс <see cref="T:System.Threading.CancellationTokenSource" />, создавший <paramref name=" cancellationToken" />, уже удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />.</summary>
      <returns>Задача, которая завершается, когда семафор будет введен.</returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32битовое целое число со знаком для измерения интервала времени.</summary>
      <returns>Задача, которая будет завершаться с результатом true, если текущий поток успешно ввел <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом false в противном случае.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя 32битовое целое число со знаком для измерения интервала времени, соблюдая <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Задача, которая будет завершаться с результатом true, если текущий поток успешно ввел <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом false в противном случае.</returns>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <param name="cancellationToken">Токен отмены <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, соблюдая <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Задача, которая завершается, когда семафор будет введен.</returns>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя <see cref="T:System.TimeSpan" /> для измерения интервала времени.</summary>
      <returns>Задача, которая будет завершаться с результатом true, если текущий поток успешно ввел <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом false в противном случае.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже был удален.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.  -или-  Время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Асинхронно ожидает входа в <see cref="T:System.Threading.SemaphoreSlim" />, используя<see cref="T:System.TimeSpan" /> для измерения интервала времени, соблюдая <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>Задача, которая будет завершаться с результатом true, если текущий поток успешно ввел <see cref="T:System.Threading.SemaphoreSlim" />, и с результатом false в противном случае.</returns>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="cancellationToken">Токен <see cref="T:System.Threading.CancellationToken" />, который следует контролировать.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания. -или- Время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>Указывает метод, вызываемый при отправке сообщения в контекст синхронизации.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SendOrPostCallback.#ctor(System.Object,System.IntPtr)">
    </member>
    <member name="M:System.Threading.SendOrPostCallback.BeginInvoke(System.Object,System.AsyncCallback,System.Object)">
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SendOrPostCallback.EndInvoke(System.IAsyncResult)">
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SendOrPostCallback.Invoke(System.Object)">
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>Предоставляет примитив взаимно исключающей блокировки, в котором поток, пытающийся получить блокировку, ожидает в состоянии цикла, проверяя доступность блокировки.</summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>Инициализирует новый экземпляр структуры <see cref="T:System.Threading.SpinLock" /> параметром для отслеживания идентификаторов потоков для повышения качества отладки.</summary>
      <param name="enableThreadOwnerTracking">Следует ли перенаправлять и использовать идентификаторы потоков для отладки.</param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>Получает блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова Enter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>Снимает блокировку.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">Включено отслеживание владения потоков и текущий поток не является владельцем этой блокировки.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>Снимает блокировку.</summary>
      <param name="useMemoryBarrier">Логическое значение, указывающее, следует ли выпустить барьер памяти, чтобы немедленно опубликовать операцию выхода для других потоков.</param>
      <exception cref="T:System.Threading.SynchronizationLockException">Включено отслеживание владения потоков и текущий поток не является владельцем этой блокировки.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>Получает значение, определяющее, имеет ли какой-либо поток блокировку в настоящий момент.</summary>
      <returns>Значение true, если в настоящее время блокировка удерживается каким-либо потоком; в противном случае — значение false.</returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>Получает значение, определяющее, имеет ли текущий поток блокировку.</summary>
      <returns>Значение true, если блокировка удерживается текущим потоком; в противном случае — значение false.</returns>
      <exception cref="T:System.InvalidOperationException">Отслеживание владения потоков отключено.</exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>Получает значение, указывающее, включено ли отслеживание владельца потока для данного экземпляра.</summary>
      <returns>Значение true, если для данного экземпляра включено отслеживание владельца потока; в противном случае — значение false.</returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>Пытается получить блокировку надежным способом, то есть даже если в вызове метода возникает исключение, <paramref name="lockTaken" /> можно надежно изучить и определить, была ли получена блокировка.</summary>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</param>
      <param name="lockTaken">Значение true, если блокировка получена; в противном случае — значение false. Перед вызовом этого метода необходимо инициализировать параметр <paramref name="lockTaken" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом, отличным от значения -1 миллисекунды, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ArgumentException">Аргумент <paramref name="lockTaken" /> должен быть инициализирован в false до вызова TryEnter.</exception>
      <exception cref="T:System.Threading.LockRecursionException">Включено отслеживание владения потоками, и текущий поток уже получил эту блокировку.</exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>Предоставляет поддержку ожидания на основе прокруток.</summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>Получает число раз, которое <see cref="M:System.Threading.SpinWait.SpinOnce" /> был вызван для этого экземпляра.</summary>
      <returns>Возвращает целое число, представляющее количество вызовов метода <see cref="M:System.Threading.SpinWait.SpinOnce" /> для данного экземпляра.</returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>Получает значение, показывающее, даст ли следующий вызов к <see cref="M:System.Threading.SpinWait.SpinOnce" /> доступ к процессору, запуская обязательное переключение контекста.</summary>
      <returns>Даст ли следующий вызов к <see cref="M:System.Threading.SpinWait.SpinOnce" /> доступ к процессору, запуская обязательное переключение контекста.</returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>Сбрасывает подсчет прокруток.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>Выполняет одну прокрутку.</summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>Выполняет прокрутки до удовлетворения заданного условия.</summary>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <exception cref="T:System.ArgumentNullException">Аргументом параметра <paramref name="condition" /> является null.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>Выполняет прокрутки до удовлетворения заданного условия или истечения заданного времени ожидания.</summary>
      <returns>Значение true, если условие удовлетворено до истечения времени ожидания; в противном случае — значение false.</returns>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <param name="millisecondsTimeout">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Аргументом параметра <paramref name="condition" /> является null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от -1, которое представляет неограниченное время ожидания.</exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>Выполняет прокрутки до удовлетворения заданного условия или истечения заданного времени ожидания.</summary>
      <returns>Значение true, если условие удовлетворено до истечения времени ожидания; в противном случае — значение false.</returns>
      <param name="condition">Делегат для циклического выполнения до возврата этим делегатом значения true.</param>
      <param name="timeout">Объект <see cref="T:System.TimeSpan" />, указывающий время ожидания в миллисекундах, или TimeSpan, представляющий значение -1 миллисекунда, в случае неограниченного ожидания.</param>
      <exception cref="T:System.ArgumentNullException">Аргументом параметра <paramref name="condition" /> является null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> является отрицательным числом отличный значение -1 миллисекунд, которое представляет неограниченное время ожидания - или - время ожидания больше <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>Обеспечивает базовую функциональность для распространения контекста синхронизации в различных моделях синхронизации.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>Создание нового экземпляра класса <see cref="T:System.Threading.SynchronizationContext" />.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>При переопределении в производном классе создает полную копию контекста синхронизации.</summary>
      <returns>Новый объект <see cref="T:System.Threading.SynchronizationContext" />.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>Получает контекст синхронизации для текущего потока</summary>
      <returns>Объект <see cref="T:System.Threading.SynchronizationContext" />, представляющий текущий контекст синхронизации.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>При переопределении в производном классе отвечает уведомлением о завершении операции.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>При переопределении в производном классе отвечает уведомлением о запуске операции.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>При переопределении в производном классе отправляет асинхронное сообщение в контекст синхронизации.</summary>
      <param name="d">Вызываемый делегат <see cref="T:System.Threading.SendOrPostCallback" />.</param>
      <param name="state">Передаваемый делегату объект.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>При переопределении в производном классе отправляет синхронное сообщение в контекст синхронизации.</summary>
      <param name="d">Вызываемый делегат <see cref="T:System.Threading.SendOrPostCallback" />.</param>
      <param name="state">Передаваемый делегату объект.</param>
      <exception cref="T:System.NotSupportedException">Метод был вызван в приложении для Магазина Windows. Реализация класса <see cref="T:System.Threading.SynchronizationContext" /> для приложений для Магазина Windows не поддерживает метод <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" />.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>Задает текущий контекст синхронизации.</summary>
      <param name="syncContext">Задаваемый объект <see cref="T:System.Threading.SynchronizationContext" />.</param>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence, ControlPolicy" />
      </PermissionSet>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>Исключение, которое выдается в то время, когда методу требуется вызвавший его объект для получения блокировки данного Monitor, а метод вызван объектом, не являющимся владельцем блокировки.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> со стандартными свойствами.</summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.SynchronizationLockException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно null, текущее исключение сгенерировано в блоке catch, обрабатывающем внутреннее исключение.</param>
    </member>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>Предоставляет хранилище для данных, локальных для потока.</summary>
      <typeparam name="T">Задает тип данных, хранимых для каждого потока.</typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="trackAllValues">Следует ли отслеживать все значения, заданные в экземпляре, и представлять их с помощью свойства <see cref="P:System.Threading.ThreadLocal`1.Values" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> с заданной функцией <paramref name="valueFactory" />.</summary>
      <param name="valueFactory">Объект <see cref="T:System.Func`1" />, вызываемый для получения неактивно инициализированного значения при совершении попытки получить <see cref="P:System.Threading.ThreadLocal`1.Value" /> без предварительной инициализации.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> является пустой ссылкой (Nothing в Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>Инициализирует экземпляр <see cref="T:System.Threading.ThreadLocal`1" /> с заданной функцией <paramref name="valueFactory" />.</summary>
      <param name="valueFactory">Объект <see cref="T:System.Func`1" />, вызываемый для получения неактивно инициализированного значения при совершении попытки получить <see cref="P:System.Threading.ThreadLocal`1.Value" /> без предварительной инициализации.</param>
      <param name="trackAllValues">Следует ли отслеживать все значения, заданные в экземпляре, и представлять их с помощью свойства <see cref="P:System.Threading.ThreadLocal`1.Values" />.</param>
      <exception cref="T:System.ArgumentNullException">Параметр <paramref name="valueFactory" /> является пустой (null) ссылкой (Nothing в Visual Basic).</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>Освобождает ресурсы, используемые данным экземпляром <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
      <param name="disposing">Логическое значение, указывающее, вызывается ли данный метод из-за вызова метода <see cref="M:System.Threading.ThreadLocal`1.Dispose" />.</param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>Освобождает ресурсы, используемые данным экземпляром <see cref="T:System.Threading.ThreadLocal`1" />.</summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>Получает значение, указывающее, инициализирован ли объект <see cref="P:System.Threading.ThreadLocal`1.Value" /> в текущем потоке.</summary>
      <returns>Значение true, если <see cref="P:System.Threading.ThreadLocal`1.Value" /> инициализируется в текущем потоке; в противном случае — значение false.</returns>
      <exception cref="T:System.ObjectDisposedException">Экземпляр класса <see cref="T:System.Threading.ThreadLocal`1" /> был удален.</exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>Создает и возвращает строковое представление данного экземпляра для текущего потока.</summary>
      <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Threading.ThreadLocal`1.Value" />.</returns>
      <exception cref="T:System.ObjectDisposedException">Экземпляр класса <see cref="T:System.Threading.ThreadLocal`1" /> был удален.</exception>
      <exception cref="T:System.NullReferenceException">
        <see cref="P:System.Threading.ThreadLocal`1.Value" /> для текущего потока представляет пустую ссылку (Nothing в Visual Basic).</exception>
      <exception cref="T:System.InvalidOperationException">Инициализация попыталась создать рекурсивную ссылку <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Не предоставляются конструктор по умолчанию и значение фабрики.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>Получает или задает значение данного экземпляра для текущего потока.</summary>
      <returns>Возвращает экземпляр объекта, за инициализацию которого ответственен данный ThreadLocal.</returns>
      <exception cref="T:System.ObjectDisposedException">Экземпляр класса <see cref="T:System.Threading.ThreadLocal`1" /> был удален.</exception>
      <exception cref="T:System.InvalidOperationException">Инициализация попыталась создать рекурсивную ссылку <see cref="P:System.Threading.ThreadLocal`1.Value" />.</exception>
      <exception cref="T:System.MissingMemberException">Не предоставляются конструктор по умолчанию и значение фабрики.</exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>Получает список всех значений, хранящихся в настоящий момент всеми потоками, которые получили доступа к данному экземпляру.</summary>
      <returns>Список всех значений, хранящихся в настоящий момент всеми потоками, которые получили доступа к данному экземпляру.</returns>
      <exception cref="T:System.ObjectDisposedException">Экземпляр класса <see cref="T:System.Threading.ThreadLocal`1" /> был удален.</exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>Содержит методы для выполнения операций энергозависимой памяти.</summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>Считывает значение указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанное значение. Это значение является последним, записанным любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>Считывает ссылку на объект из указанного поля. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется после данного метода в коде, процессор не сможет переместить ее перед этим методом.</summary>
      <returns>Прочитанная ссылка на объект <paramref name="T" />. Эта ссылка является последней, записанной любым процессором компьютера, независимо от количества процессоров и от состояния кэша процессоров.</returns>
      <param name="location">Считываемое поле.</param>
      <typeparam name="T">Тип считываемого поля. Должен быть ссылочным типом или типом значения.</typeparam>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция памяти появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>Записывает заданное значение в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается значение.</param>
      <param name="value">Записываемое значение. Значение записывается немедленно, так что оно становится видимым для всех процессоров компьютера.</param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>Записывает заданную ссылку на объект в указанное поле. В системах, которым это необходимо, вставляет барьер памяти, не позволяющий процессору изменять порядок операций памяти следующим образом: если операция чтения или записи появляется перед данным методом в коде, процессор не сможет поместить ее после этого метода.</summary>
      <param name="location">Поле, в которое записывается ссылка на объект.</param>
      <param name="value">Записываемая ссылка на объект. Ссылка записывается немедленно, так что она становится видимой для всех процессоров компьютера.</param>
      <typeparam name="T">Тип поля, в которое выполняется запись. Должен быть ссылочным типом или типом значения.</typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>Исключение, которое выдается при попытке открыть не существующий в системе семафор или мьютекс.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> значениями по умолчанию.</summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> с указанным сообщением об ошибке.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> с указанным сообщением об ошибке и ссылкой на внутреннее исключение, вызвавшее это исключение.</summary>
      <param name="message">Сообщение об ошибке с объяснением причин исключения.</param>
      <param name="innerException">Исключение, которое вызвало текущее исключение. Если значение параметра <paramref name="innerException" /> не равно null, текущее исключение сгенерировано в блоке catch, обрабатывающем внутреннее исключение.</param>
    </member>
  </members>
</doc>